# 第08章：杯子塔与后悔药的哲学

*栈如同我们叠起的盘子，最后放上的总是最先被拿走。生活中的许多美好瞬间也是如此——最近的回忆总是最容易想起，而深埋的往事需要我们一层层地回溯。*

周五的午后，DSA Lab意外地安静。安妮独自坐在角落里，面前摆着一个奇怪的"建筑"——用实验室的咖啡杯和小盘子搭成的高塔，看起来摇摇欲坠。

"安妮，你在做什么呀？"伊莎贝尔端着刚泡好的花茶走过来，声音里带着好奇的温柔。

"我在想昨天黛芙学姐提到的'栈'，"安妮头也不抬地继续叠着杯子，"她说栈就像叠盘子一样，我想亲自体验一下这种感觉。"

黛芙走近看了看，忍不住笑了："你这个塔快要倒了吧？而且......"她指着最下面，"为什么最底下是我的咖啡杯？"

"咦？"安妮有点慌，"因为、因为它最大最稳？"

"那是我最爱的马克杯！"黛芙佯装生气，但眼中有笑意，"如果你想拿我的杯子，至少得先把上面的都拿掉吧？"

安妮伸手想直接抽出底下的杯子，整个塔立刻开始晃动。

"等等！"黛芙连忙阻止，"你这样会全塌的！这就是栈的核心特点——后进先出，Last In First Out，简称LIFO。"

"啊？"安妮停下手，疑惑地看着她。

这时希娅也进来了，明眸撇过两人，忍不住捂嘴轻笑："看起来有人在用最直观的方式学习数据结构呢。"

"希娅学姐！"安妮有点不好意思，"我只是想体验一下栈的感觉，但是......好像搞砸了。"

希娅走过来，仔细观察了这个摇摇欲坠的塔："其实你的想法很对。栈确实像叠盘子，但重点不是叠多高，而是理解它的规则。"

她轻柔地从最上面拿下一个小碟子："看，我们只能从顶部操作。这个操作叫做......?"

"pop？"安妮试探性地说。

"对！"希娅微笑，"从栈顶移除元素叫pop。那如果我要放一个新碟子呢？"

"push！放到最顶上！"安妮立刻回答。

黛芙这时也被她们的互动逗乐了："不错，看来昨天没白听。不过，安妮，你知道为什么我刚才说不能直接拿底下的杯子吗？"

安妮想了想："因为......因为栈只能在一端操作？就像这个塔，我只能从上面拿？"

"聪明！"黛芙赞许地点点头，"这一端叫做栈顶。另一端虽然存在，但我们称它为栈底，不能直接访问。但现在我有个问题——如果我真的很想要我的杯子，但又不想让其他杯子掉到地上摔碎，你会怎么办？"

安妮眨眨眼，突然灵光一闪："我知道了！我要先把上面的都拿下来，小心地放到别的地方，然后拿你的杯子，再把其他的按原来的顺序放回去！"

伊莎贝尔指着黛芙的马克杯："如果我想知道最底下是什么，但又不想真的拿出来，有办法吗？"

希娅思考了一下："在栈这个数据结构中，我们通常只能看到栈顶的元素。有一个操作叫peek或者top，可以查看栈顶元素但不移除它。"

```
栈的状态：
     ┌─────┐  ← 栈顶 (最后进入， 最后出去)
     │ 🥛  │
     ├─────┤
     │ 🍽️  │
     ├─────┤
     │ ☕  │  ← 栈底 (最先进入， 最后出去)
     └─────┘

操作：
push(🧃) → 在顶部添加新元素
pop()     → 移除并返回顶部元素
peek()    → 查看顶部元素但不移除
is_empty()      - 检查栈是否为空
size()          - 返回栈中元素的个数
```

"但是底部的元素呢？"安妮追问。

"那就需要把上面的都pop出来了。"黛芙微笑，"除非......"

"除非什么？"安妮好奇地问。

黛芙转身，银色头发划过一个优美的弧度。她在白板上画下栈的示意图：

```
使用辅助栈访问栈底：

原栈：           步骤1：全部倒入辅助栈    步骤2：查看辅助栈顶
┌─────┐         ┌─────┐    ┌─────┐     ┌─────┐    ┌─────┐
│  D  │         │     │    │  D  │     │     │    │  A  │ ← 原来的栈底,成了栈顶，可以用peek/top查看
├─────┤   →     ├─────┤    ├─────┤  →  ├─────┤    ├─────┤
│  C  │         │     │    │  C  │     │     │    │  B  │
├─────┤         ├─────┤    ├─────┤     ├─────┤    ├─────┤
│  B  │         │     │    │  B  │     │     │    │  C  │
├─────┤         ├─────┤    ├─────┤     ├─────┤    ├─────┤
│  A  │         │     │    │  A  │     │     │    │  D  │
└─────┘         └─────┘    └─────┘     └─────┘    └─────┘
 原栈            空栈       辅助栈        空栈       辅助栈

步骤3：再倒回原栈，恢复原状
┌─────┐    ┌─────┐
│  D  │    │     │
├─────┤    ├─────┤
│  C  │    │     │
├─────┤    ├─────┤
│  B  │    │     │
├─────┤    ├─────┤
│  A  │    │     │
└─────┘    └─────┘
原栈恢复    空栈
```

"噢！"安妮兴奋地说，"就像我刚才想要拿黛芙姐的杯子一样！先把上面的杯子一个个放到别的地方，看到目标杯子，然后再把其他杯子按相反顺序放回去！"

"没错！"希娅鼓掌，"这种技巧在解决复杂问题时经常用到。"

黛芙眼中闪过狡黠的光芒："说到这个，我想起一个有趣的问题。安妮，如果我现在给你两个栈，你能用它们模拟一个队列吗？"

"队列？"安妉困惑地问，"那是什么？"

"队列是另一种数据结构，"伊莎贝尔温柔地解释，"它是先进先出的，First In First Out。就像排队买奶茶一样，最先排队的人最先买到奶茶。"

黛芙接着道，"这是个经典的面试题呢。提示一下——如果你有两个栈，一个用来接收新元素，另一个用来输出元素......"

安妮皱着眉头思考："栈是后进先出，队列是先进先出......它们完全相反啊！怎么可能用栈来实现队列？"

"这确实看起来不可能，"黛芙轻笑，引导安妮，"想想你刚才学到的辅助栈技巧......"

安妮的眼睛慢慢亮了起来，她走到白板前，开始画图：

```
用两个栈实现队列：

输入栈（input_stack）：负责接收新元素
输出栈（output_stack）：负责输出元素

情况1：入队操作 (enqueue)
新元素总是放入输入栈：
     入队(A)      入队(B)      入队(C)
输入栈：          输入栈：      输入栈：✨
┌─────┐          ┌─────┐      ┌─────┐
│  A  │    →     │  B  │  →   │  C  │
└─────┘          ├─────┤      ├─────┤
                 │  A  │      │  B  │
                 └─────┘      ├─────┤
                              │  A  │
                              └─────┘
输出栈：          输出栈：      输出栈：
┌─────┐          ┌─────┐      ┌─────┐
│     │          │     │      │     │
└─────┘          └─────┘      └─────┘

情况2：出队操作 (dequeue)
如果输出栈为空，就把输入栈的所有元素倒过去：

步骤1：倒转            步骤2：出队
输入栈：  →  输出栈：    输出栈：
┌─────┐     ┌─────┐    ┌─────┐
│     │     │  A  │    │  B  │ ← 下次出队
└─────┘     ├─────┤    ├─────┤
            │  B  │    │  C  │
            ├─────┤    └─────┘
            │  C  │    
            └─────┘    ⚡️返回：A (最先入队的！)
```

"我懂了！"安妮激动地拍手，"当我需要出队的时候，如果输出栈是空的，就把输入栈的所有元素都倒到输出栈里！这样，原来在输入栈最底下的元素（最先入队的）就变成了输出栈最顶上的元素！"

"brilliant！"黛芙赞许道，"这样就实现了先进先出！"

"让我们看看具体的代码实现吧，"黛芙说着，开始在白板上写代码。

```python
# 栈的基本实现 - 就像管理一摞盘子
class Stack:
    def __init__(self):
        self.items = []      # 列表的末尾是栈顶，开头是栈底
    
    def push(self, item):   # 将元素压入栈顶
        self.items.append(item)    # 在列表末尾添加元素，时间复杂度 O(1)
    
    def pop(self):  # 弹出并返回栈顶元素
        if self.is_empty():
            raise IndexError("栈是空的，无法pop！")
        item = self.items.pop()  # pop移除并返回列表的最后一个元素，时间复杂度 O(1)
        return item
    
    def peek(self):  # 查看栈顶元素但不移除
        if self.is_empty():
            raise IndexError("栈是空的，无法peek！")

        # -1 是Python的负索引，表示"倒数第一个"
        return self.items[-1]  # 访问列表的最后一个元素（栈顶）

# 用两个栈实现队列 - 黛芙的挑战题解答
class QueueUsingStacks:
    def __init__(self):
        self.input_stack = Stack()      # 输入栈：接收所有新入队的元素
        self.output_stack = Stack()     # 输出栈：负责出队操作
    
    def enqueue(self, item):    # 入队操作：新元素总是放入输入栈
        self.input_stack.push(item)
        print(f"🟢 入队: {item}")
    
    def dequeue(self):   # 出队操作：从输出栈弹出元素
        if self.output_stack.is_empty():    # 如果输出栈为空，需要从输入栈倒转元素
            if self.input_stack.is_empty():
                raise IndexError("队列是空的，没有元素可以出队！")
            
            print("🔄 输出栈为空，正在从输入栈倒转元素...")
            while not self.input_stack.is_empty():  # 将输入栈的所有元素倒入输出栈
                element = self.input_stack.pop()
                self.output_stack.push(element)
       
        item = self.output_stack.pop()  # 从输出栈弹出元素（这就是最先入队的元素）
        print(f"🟡 出队: {item}")
        return item
    
    def is_empty(self):  # 当两个栈都为空时，队列才为空
        return self.input_stack.is_empty() and self.output_stack.is_empty()
    
    def size(self):     # 队列大小 = 两个栈的大小之和
        return self.input_stack.size() + self.output_stack.size()
```

安妮看着白板，"为什么用`self.items[-1]`而不是`self.items[len(self.items)-1]`呢？"

伊莎贝尔温柔地解释："这是Python的一个贴心设计。负索引让我们可以从后往前数元素。"

她在白板角落画了个小图：

```python
# Python的负索引系统
items = ["🍎", "🍌", "🍊", "🥝"]
#          0     1     2     3    ← 正向索引（从0开始）
#         -4    -3    -2    -1    ← 负向索引（从-1开始）

items[3]   # 🥝 (正向索引：第4个位置)
items[-1]  # 🥝 (负向索引：倒数第1个，也就是最后一个)
items[-2]  # 🍊 (负向索引：倒数第2个)

# 对于栈来说，我们最关心的是"最后一个"（栈顶）
# 所以用 items[-1] 比 items[len(items)-1] 更直观
```

黛芙指着代码："还有一个重要的概念需要理解——时间复杂度。"

```
栈操作的时间复杂度分析：

操作          时间复杂度    说明
--------      -----------   --------------------------------
push()        O(1)         直接在列表末尾添加，非常快
pop()         O(1)         直接删除列表末尾，非常快  
peek()        O(1)         直接访问列表末尾，非常快
is_empty()    O(1)         只需检查长度是否为0
size()        O(1)         Python列表维护长度信息

为什么这些操作都是O(1)？
因为我们使用列表的末尾作为栈顶！

对比：如果用列表开头作为栈顶会怎样？
push(item)：需要insert(0, item) → O(n) 很慢！
pop()：需要pop(0) → O(n) 很慢！

为什么慢？因为需要移动所有其他元素：
插入到开头：[A,B,C] → insert(0,X) → [X,A,B,C]
              所有元素都要往后挪一位！

删除开头： [A,B,C] → pop(0) → [B,C]  
           所有元素都要往前挪一位！
```

"所以，"安妮总结道，"我们把列表的末尾当作栈顶，这样所有操作都很快！如果把开头当栈顶，就需要移动很多元素，会很慢。"

"完全正确！"黛芙满意地点头，"这就是数据结构设计的智慧——选择合适的底层实现来优化性能。"

"让我们测试一下这些代码，"伊莎贝尔提议。

```python
print("\n=== 测试用栈实现队列操作 ===")
queue = QueueUsingStacks()

# 模拟奶茶店排队
queue.enqueue("👩 小红")      # 第一个排队
queue.enqueue("👨 小明")      # 第二个排队  
queue.enqueue("👩 小花")      # 第三个排队

# 按排队顺序服务客人
print("\n开始服务客人:")
queue.dequeue()  # 👩 小红 (最先排队的最先服务)
queue.dequeue()  # 👨 小明
queue.dequeue()  # 👩 小花

# 输出结果示例：
# 🟢 入队: 👩 小红
# 🟡 出队: 👩 小红
```

"太神奇了！"安妮兴奋地说，"队列真的按先进先出的顺序工作了！"

希娅补充道："而且注意到了吗？第一次出队时，需要倒转元素，但如果连续出队，就不需要重复倒转了，很高效。"

黛芙点头："这个队列实现的平均时间复杂度是O(1)。虽然偶尔需要O(n)时间来倒转，但分摊下来还是很快的。"

希娅轻拍了拍安妮的肩膀："刚才我们用Python列表实现了栈的操作，但如果没有现成的列表，你会怎么从零开始构建一个栈？"

"从零开始？"安妮眨眨眼，抱住脑袋思考，"那我就......我就用之前学过的链表！"

"聪明！"黛芙赞许地点头，"用链表来实现栈，就是链式栈，和我们刚才看到的顺序栈有些不同。"

伊莎贝尔走到白板前："让我们来看看链式栈是如何工作的。"

链式栈的结构：

![链式栈的结构](/assets/images/ch08_link_stack.png)

"我懂了！"安妮兴奋地说，"链式栈就像用绳子把杯子串起来，每个杯子都知道下面连着哪个杯子！"

"很形象的比喻，"黛芙微笑，"让我们看看push操作的具体实现。"

![push](/assets/images/ch08_link_stack_push.png)

```python
# 链式栈的节点定义
class StackNode:
    def __init__(self, data):
        self.data = data      # 存储数据
        self.next = None      # 指向下一个节点的指针，初始为None

# 链式栈的实现
class LinkedStack:
    def push(self, data):   # 将元素压入栈顶
        new_node = StackNode(data)       # 步骤1：创建新节点
        new_node.next = self.top      # 步骤2：新节点指向当前栈顶（即使栈为空，指向None也是正确的）
        self.top = new_node     # 步骤3：更新栈顶指针
        self.count += 1     # 步骤4：更新计数  
```

黛芙指着代码："注意看这个细节——`new_node.next = self.top`。这一行很关键。"

"我明白了！"安妮拍手，"新节点总是插在最前面，然后top指针就指向新节点。这样新加入的元素就成了栈顶！"

"push的时间复杂度是O(1)，因为只涉及指针操作。空间复杂度：O(1)，只创建一个新节点。"伊莎贝尔温柔地说，"pop操作也是类似的，只是反过来。"

![pop](/assets/images/ch05_link_stack_pop.png)

```python
def pop(self):   # 弹出栈顶元素
    if self.is_empty():
        raise IndexError("链式栈为空，无法pop！")
    
    data = self.top.data     # 保存要返回的数据
    self.top = self.top.next    # 更新栈顶指针（相当于"删除"当前栈顶节点）
    self.count -= 1     # 更新计数

    return data
```

"pop操作的时间复杂度也是O(1)，只涉及指针操作。"黛芙接着说道，"入栈和出栈的操作都只在链表的表头进行。"

"原来如此！"希娅若有所思。

"下面我们对比一下顺序栈和链式栈的特性。"伊莎贝尔笑着总结。

| 特性           | 顺序栈（列表）       | 链式栈（链表）         |
|----------------|----------------------|------------------------|
| 存储方式     | 连续内存空间     | 节点 + 指针      |
| 空间效率       | 高（无额外指针）     | 较低（每节点需指针）   |
| 时间效率       | 所有操作 O(1)        | 所有操作 O(1)          |
| 内存分配       | 预分配空间       | 动态分配        |
| 大小限制       | 受列表最大长度限制   | 仅受系统内存限制       |
| 访问方式     | 随机访问         | 顺序访问  
| 实现复杂度     | 简单                 | 稍复杂（需管理指针）   |
| 内存连续性     | 连续存储             | 散布在内存各处         |
| 缓存友好性     | 好（连续内存）       | 较差（指针跳转）       |

### 栈的应用

"我想到一个问题，"安妮举手，"栈除了实现队列和撤销操作，还有其他用途吗？"

"太多了！"伊莎贝尔眼中闪着光芒，"比如浏览器的前进后退、函数调用、数学表达式求值......"

"函数调用？"安妮好奇地问。

黛芙走到白板前："想象一下，当你调用函数的时候......"

#### 栈的函数调用

```python
def function_A():
    print("A开始")
    function_B()      # 调用B
    print("A结束")

def function_B():  
    print("B开始")
    function_C()      # 调用C
    print("B结束")

def function_C():
    print("C开始")
    print("C结束")

# 调用过程：
# 每个函数调用都会在栈中推入一个"帧"，函数返回时就从栈中弹出对应的帧！
```

输出结果如下：
| 步骤 | 栈的变化       | 输出内容   |
|------|----------------|------------|
| 1    | []             |            |
| 2    | [A]            | A开始      |
| 3    | [A, B]         | B开始      |
| 4    | [A, B, C]      | C开始      |
| 5    | [A, B, C]      | C结束      |
| 6    | [A, B]         | C返回      |
| 7    | [A, B]         | B结束      |
| 8    | [A]            | B返回      |
| 9    | [A]            | A结束      |
| 10   | []             | A返回      |
   
"哦！"安妮恍然大悟，"所以最后调用的函数最先返回，就像栈一样！"

"正是如此，"黛芙微笑，"这就是为什么叫'调用栈'。"

伊莎贝尔补充："还有括号匹配也用到栈。比如检查`((()))`是否匹配。"

#### 括号匹配算法

```
字符串: "((()))"
栈的变化:

读取 '(' → 栈: ['(']
读取 '(' → 栈: ['(', '('] 
读取 '(' → 栈: ['(', '(', '(']
读取 ')' → 与栈顶'('匹配，弹出 → 栈: ['(', '(']
读取 ')' → 与栈顶'('匹配，弹出 → 栈: ['(']  
读取 ')' → 与栈顶'('匹配，弹出 → 栈: []

最后栈为空 → 括号完全匹配！

如果是 "(((" → 栈不为空 → 不匹配
如果是 "())" → 栈已空还有')' → 不匹配
```

"栈的应用真是无处不在呢，"安妮感叹道。

黛芙看看时间，决定做个小总结："让我们整理一下今天学到的关键概念。"

```
🌵 今日栈知识总结 by 黛芙

核心概念：
• 栈 (Stack)：后进先出 (LIFO) 的线性数据结构
• 只允许在栈顶进行插入和删除操作
• 就像叠盘子：最后放上的最先拿掉

基本操作：
• push(item)：将元素压入栈顶，O(1)
• pop()：弹出栈顶元素并返回，O(1)  
• peek()/top()：查看栈顶元素但不移除，O(1)
• is_empty()：检查栈是否为空，O(1)
• size()：返回栈中元素个数，O(1)

两种实现方式：

🌿顺序栈（基于列表/数组）：
• 使用列表末尾作为栈顶，保证O(1)的操作效率
• 负索引 items[-1] 访问栈顶元素
• 内存连续，缓存友好，空间效率高
• 可能需要动态扩容，偶尔O(n)复杂度

🎋链式栈（基于链表）：
• 使用链表头部作为栈顶，top指针指向栈顶节点
• 动态内存分配，无大小限制
• 每个节点包含数据和指向下一节点的指针
• 内存开销较大，但灵活性强

🌿何时选择顺序栈？
- 元素数量相对固定
-  对内存效率要求高
-  需要频繁访问元素（虽然栈不常这样做）
-  实现简单，易于理解

🎋何时选择链式栈？
-  元素数量变化很大
-  不确定栈的最大大小
-  系统内存充足
-  需要频繁动态调整


经典应用：
• 函数调用栈：管理函数调用和返回
• 撤销操作：文本编辑器的Ctrl+Z
• 括号匹配：检查表达式的括号是否配对
• 浏览器历史：后退功能
• 用两个栈实现队列：巧妙的数据结构转换



设计思想：
• 栈天然适合处理"最近的优先"的问题
• 通过限制操作方式，简化问题复杂度
• 后进先出的特性可以自然地逆转顺序
• 递归算法与栈的天然对应关系
```


安妮看着自己面前已经整理好的杯子们，若有所思地说："其实生活中到处都有栈的影子呢。"

"比如？"希娅好奇地问。

"比如叠衣服、摞书、甚至......"安妮脸红了一下，"甚至记忆也是这样的。最近发生的事情最容易想起来，要回忆很久以前的事情，就需要一层层地往回想。"

伊莎贝尔温柔地笑了："安妮说得真好。数据结构不只是计算机科学的概念，它们反映了我们思考和组织世界的方式。"

黛芙收拾着白板，突然说："对了，安妮，下次如果你想做物理实验来理解数据结构......"

"嗯？"安妮期待地看着她。

"记得先问问那个数据结构的拥有者同不同意把他们的杯子当实验道具。"黛芙假装严肃地说。

"黛芙学姐！"安妮脸红了，不好意思地低头。

黛芙眼睛闪过笑意，她走到安妮面前，轻轻摸了摸她的头："看到你这么认真地学习，我很高兴。这个杯子，就当是给你的奖励吧。"

安妮接过马克杯，上面写着"Algorithm 🩷" 。

黄昏时分，夕阳透过实验室的大窗户洒进来，在四个女孩身上投下温暖的光影。她们围坐在一起，分享着今天的学习心得，每个人的脸上都带着满足的笑容。

### 🌸 安妮的奇妙比喻集

今天学栈的时候，我突然发现生活中到处都是栈的影子！洗完的盘子叠在一起，最后洗的最先用；看过的书摞成一堆，最上面的是最近看的。

最有趣的是，我发现栈就像时光机一样！每次pop操作都能让我们回到上一个状态，就像按了"撤销"键。难怪计算机要用栈来实现撤销功能，原来栈天生就是个"后悔药"呀！

而且黛芙学姐说的函数调用栈也超级形象——就像我们平时聊天一样，如果小花正在跟我聊天，然后小明过来问问题，我会先回答小明，再继续跟小花聊天。最后问的问题最先回答，这不就是栈吗？

伊莎贝尔学姐教的链式栈让我想到了串糖葫芦！每个糖葫芦（节点）都用竹签（指针）连着下一个，最顶上的糖葫芦就是栈顶。要吃糖葫芦的时候，只能从最顶上开始吃，这不就是LIFO吗？而且串糖葫芦的时候，新加的总是在最顶上，就像push操作一样！

链式栈和顺序栈就像两种不同的收纳方式：顺序栈像是把东西放在固定大小的盒子里，整齐紧凑但空间有限；链式栈像是用绳子把东西串起来，虽然需要额外的绳子，但想放多少就放多少，特别灵活！

最神奇的是函数调用栈的机制！黛芙学姐演示的函数调用过程让我明白了为什么程序能够记住"回到哪里"——就像我看书时用书签标记当前页面，当我放下书去做别的事情时，书签帮我记住应该回到哪一页继续阅读。函数调用栈就像程序的"书签系统"，让每个函数都知道执行完毕后应该回到哪里继续！

今天最大的收获是学会了用两个栈实现队列！感觉自己就像魔法师一样，把"后进先出"变成了"先进先出"。黛芙学姐说这是经典面试题，我现在也会了！嘻嘻，下次别人问我的时候，我就可以得意地画图解释啦！

---

> 栈（Stack）：后进先出（LIFO）的线性数据结构，仅允许在栈顶进行插入（push）和删除（pop）操作。栈的这种操作限制使其成为处理"最近访问优先"问题的理想选择，广泛应用于函数调用管理、表达式求值、撤销操作等场景。

**🌺 今日关键词**

- **栈 (Stack)**：后进先出的线性数据结构，只能在栈顶操作
- **LIFO (Last In First Out)**：最后进入的元素最先出来的原则  
- **push操作**：将元素压入栈顶，时间复杂度O(1)
- **pop操作**：弹出并返回栈顶元素，时间复杂度O(1)
- **peek/top操作**：查看栈顶元素但不移除，时间复杂度O(1)
- **栈顶 (Top)**：栈中唯一可以进行操作的位置
- **栈底 (Bottom)**：栈的另一端，不能直接访问
- **顺序栈**：使用数组/列表实现的栈，内存连续，空间效率高
- **链式栈**：使用链表实现的栈，动态分配内存，大小灵活
- **栈节点 (StackNode)**：链式栈中的基本单元，包含数据和指向下一节点的指针
- **栈顶指针 (top)**：链式栈中指向当前栈顶节点的指针
- **函数调用栈**：程序运行时管理函数调用和返回的栈结构
- **辅助栈技巧**：使用额外栈来实现复杂操作的方法
- **用栈实现队列**：经典算法问题，使用两个栈模拟队列的FIFO特性

**🎯 推荐练习**

*基础入门（必做）⭐⭐*
- LeetCode 20. 有效的括号 - 栈的经典应用，检验对push/pop操作的理解
- LeetCode 155. 最小栈 - 学会在栈中维护额外信息的设计技巧  
- LeetCode 232. 用栈实现队列 - 巩固今天学习的双栈技巧
- LeetCode 1047. 删除字符串中的所有相邻重复项 - 体验栈的消除匹配功能

*进阶应用（推荐）⭐⭐⭐*  
- LeetCode 225. 用队列实现栈 - 反向思考，用队列模拟栈操作
- LeetCode 739. 每日温度 - 单调栈的入门应用，解决"下一个更大元素"类问题
- LeetCode 496. 下一个更大元素 I - 进一步练习单调栈和哈希表结合

*挑战提升（选做）⭐⭐⭐⭐*
- LeetCode 84. 柱状图中最大的矩形 - 单调栈的高级应用
- LeetCode 42. 接雨水 - 经典难题，可用栈或双指针解决
- LeetCode 85. 最大矩形 - 二维问题转化为一维栈问题的综合应用 