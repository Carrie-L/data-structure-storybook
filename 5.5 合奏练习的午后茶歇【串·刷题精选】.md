### **5.5 合奏练习的午后茶歇【串·刷题精选】**

*"当理论的乐谱化为指尖的合奏，每一次按下运行键，都是对理解的最好加冕。"*

窗外的天色由明亮的钴蓝，渐渐染上了一层柔和的橘调。KMP算法那场堪称"脑力过山车"的研习刚刚结束，社团活动室里弥漫着一股奇异的宁静——那是智力高速运转后，混合着疲惫与满足的特殊气息。

伊莎贝尔适时地端上了她精心准备的下午茶：冒着热气的伯爵红茶，以及一盘烤得金黄酥脆的苹果派。派的表面用糖粉细细筛出了一行字："Hello, World!"。

"先休息一下吧，"她微笑着，将茶杯分给每个人，"把刚才吸收的知识，像泡开的茶叶一样，在脑海里慢慢舒展开来。"

"呜……"安妮捧着温热的茶杯，长长地舒了一口气，感觉自己紧绷的神经终于放松了下来，"KMP算法好厉害，但也感觉……好抽象。像是听了一首非常华丽但又复杂的协奏曲，总担心自己会跟不上节奏。"

"有这种感觉就对啦！"希娅咬了一大口苹果派，含糊不清地说道，"理论学得再溜，不拉出来练练，永远都是纸上谈兵。所谓'合奏练习'，就是检验我们能不能跟上乐队的节拍！"

她说着，把自己的笔记本电脑转过来，屏幕上是一个简洁的编程挑战网站界面。

"锵锵！我找到了一个最经典的练习曲目——'实现 `strStr()`'。翻译过来就是，在一个大字符串（`haystack`，干草堆）里，找出第一个匹配到的小字符串（`needle`，绣花针）的位置。这不就是我们这两天一直在做的事情嘛！"

#### **从朴素到精妙：两种算法的对决**

黛芙看着题目，点了点头："很基础，但也最能体现不同算法的差异。安妮，如果是你，你会怎么在这座'干草堆'里找到那根'绣花针'呢？用我们最开始学的方法。"

安妮的思绪立刻被拉回了前一天的"月下寻影"。她想了想，试探着说："用最朴素的办法？就像伊莎贝尔学姐教的那样，把'绣花针'从'干草堆'的第一个字符开始，一个一个地对齐比较。如果中途有一个字符对不上，就把'绣花针'往后挪一个位置，再从头开始比？"

"完全正确，这就是我们学过的BF算法。"黛芙赞许道，"它的逻辑最直观，我们先把它实现出来看看。"

希娅手指翻飞，很快就在屏幕上敲出了代码：

```python
def strStr_BF(haystack: str, needle: str) -> int:
    """使用朴素的BF(Brute-Force)算法实现字符串匹配"""
    if not needle:  # 空模式串，返回0
        return 0
    
    # 主串长度为m，模式串长度为n
    m, n = len(haystack), len(needle)
    
    # 主串指针i最多移动到 m-n 位置
    for i in range(m - n + 1):
        # 检查从位置i开始是否匹配
        j = 0
        while j < n and haystack[i + j] == needle[j]:
            j += 1
        
        if j == n:  # 完全匹配
            return i
            
    return -1  # 未找到
```

"看，这就是BF算法的'实况录像'，"黛芙在白板上画了起来，"如果我们的干草堆是`aabaabaafa`，绣花针是`aabaaf`："

```ascii
步骤1: i=0, 从位置0开始匹配
haystack: a a b a a b a a f a
          ↑ ↑ ↑ ↑ ↑ ↑
needle:   a a b a a f
          ↑ ↑ ↑ ↑ ↑ ✗ (不匹配！)

步骤2: i=1, 从位置1开始匹配  
haystack: a a b a a b a a f a
            ↑ ✗ (第一个字符就不匹配)
needle:     a a b a a f

步骤3: i=2, 从位置2开始匹配
haystack: a a b a a b a a f a
              ↑ ✗ (第一个字符就不匹配)
needle:       a a b a a f

步骤4: i=3, 从位置3开始匹配
haystack: a a b a a b a a f a
                ↑ ↑ ↑ ↑ ↑ ↑ (全部匹配！)
needle:         a a b a a f
                
返回索引3
```

#### **BF算法复杂度分析：一步步推导**

"现在我们来详细分析BF算法的时间复杂度，"黛芙在白板上开始画图，"这是理解算法效率的关键。"

"首先，我们要明确两个变量：主串长度`m = len(haystack)`，模式串长度`n = len(needle)`。"

黛芙画出了分析框架：

```ascii
BF算法复杂度分析：

外层循环：i从0到m-n，共执行(m-n+1)次
内层循环：每次最多比较n个字符

┌─────────────────────────────────────────┐
│ 情况分析：                              │
├─────────────────────────────────────────┤
│ 最好情况：第一次就匹配成功              │
│ - 外层循环：1次                         │
│ - 内层循环：n次比较                     │
│ - 总复杂度：O(n)                        │
├─────────────────────────────────────────┤
│ 最坏情况：每次都比较到最后才失败        │
│ - 外层循环：(m-n+1)次                   │
│ - 内层循环：每次n次比较                 │
│ - 总比较次数：(m-n+1) × n               │
│ - 当n远小于m时，约等于m×n               │
│ - 总复杂度：O(mn)                       │
└─────────────────────────────────────────┘
```

"让我们用一个具体例子来看最坏情况，"黛芙继续画道：

```ascii
最坏情况示例：
haystack = "aaaaaaaaab" (长度m=10)
needle   = "aaaab"     (长度n=5)

比较次数统计：
位置0: a a a a a  vs  a a a a b  → 比较5次，第5次失败
位置1: a a a a a  vs  a a a a b  → 比较5次，第5次失败  
位置2: a a a a a  vs  a a a a b  → 比较5次，第5次失败
位置3: a a a a a  vs  a a a a b  → 比较5次，第5次失败
位置4: a a a a a  vs  a a a a b  → 比较5次，第5次失败
位置5: a a a a b  vs  a a a a b  → 比较5次，全部匹配！

总比较次数 = 6 × 5 = 30次
公式验证：(m-n+1) × n = (10-5+1) × 5 = 6 × 5 = 30 ✓
```

安妮看着这个详细的分析，恍然大悟："原来复杂度分析就是这样一步步推导出来的！不是凭空给出一个O(mn)，而是要算出具体的比较次数！"

"BF算法就像一个很有耐心但有点固执的新手，"伊莎贝尔柔声比喻道，"每次失败，它都会退回原点，重新开始，不放过任何一个角落，但有时候会做很多无用功。"

"是哦，"安妮看着图，恍然大悟，"尤其是当'绣花针'有很多重复字符的时候，比如`aaaaab`，在`aaaaaaaaab`里找，那得重复比较多少次啊！"

"那么，刚出炉的'魔法武器'KMP，能在这里派上用场吗？"黛芙看向安妮，目光带着一丝考较的意味。

安妮的心跳快了一拍。她努力回忆着刚才黛芙讲解的`next`数组的奥秘——那个能记录前缀和后缀最长公共元素长度的"暗号"。

"应、应该可以！"安妮鼓起勇气说，"KMP的精髓，就是'绣花针'在匹配失败时，不会傻傻地回到起点，而是根据`next`数组的指示，'滑动'到一个最有可能成功的位置！"

"说得好！"希娅兴奋地打了个响指，"快，我们来给这个`aabaaf`的'绣花针'制作它的专属`next`暗号表！"

#### **KMP算法的完整实现与复杂度分析**

黛芙清空白板，开始展示KMP算法的完整实现：

```python
def build_next(pattern: str) -> list:
    """构建KMP算法的next数组（失效函数）"""
    n = len(pattern)
    next_arr = [0] * n  # next[0]总是0
    
    # j指向当前最长公共前后缀的长度
    j = 0
    
    # i从1开始遍历模式串
    for i in range(1, n):
        # 当不匹配时，j回退到next[j-1]
        while j > 0 and pattern[i] != pattern[j]:
            j = next_arr[j - 1]
        
        # 如果匹配，j前进一位
        if pattern[i] == pattern[j]:
            j += 1
        
        # 记录当前位置的next值
        next_arr[i] = j
    
    return next_arr

def strStr_KMP(haystack: str, needle: str) -> int:
    """使用KMP算法实现字符串匹配"""
    if not needle:
        return 0
    
    # 构建next数组
    next_arr = build_next(needle)
    
    m, n = len(haystack), len(needle)
    i = j = 0  # i指向主串，j指向模式串
    
    while i < m:
        # 匹配成功，两指针都前进
        if haystack[i] == needle[j]:
            i += 1
            j += 1
        
        # 找到完整匹配
        if j == n:
            return i - j
        
        # 匹配失败
        elif i < m and haystack[i] != needle[j]:
            if j != 0:
                # 利用next数组跳转，i不回退
                j = next_arr[j - 1]
            else:
                # j已经在起始位置，i前进
                i += 1
    
    return -1
```

"现在让我们一步步看看，对于模式串`aabaaf`，next数组是如何构建的：" 黛芙在白板上详细展示：

```ascii
构建next数组的过程：
模式串: a a b a a f
索引:   0 1 2 3 4 5

步骤详解：
i=0: next[0] = 0 (固定)
i=1: pattern[1]='a' vs pattern[0]='a' → 匹配! j=1, next[1]=1
i=2: pattern[2]='b' vs pattern[1]='a' → 不匹配! j回退到0, next[2]=0  
i=3: pattern[3]='a' vs pattern[0]='a' → 匹配! j=1, next[3]=1
i=4: pattern[4]='a' vs pattern[1]='a' → 匹配! j=2, next[4]=2
i=5: pattern[5]='f' vs pattern[2]='b' → 不匹配! j回退到next[1]=1
     pattern[5]='f' vs pattern[1]='a' → 不匹配! j回退到0, next[5]=0

最终: next = [0, 1, 0, 1, 2, 0]
```

#### **KMP算法复杂度分析：详细推导过程**

"现在是关键部分——KMP算法的复杂度分析，"黛芙在白板上画出了详细的分析图：

```ascii
KMP算法复杂度分析：

阶段1：构建next数组
┌─────────────────────────────────────────┐
│ build_next函数分析：                    │
├─────────────────────────────────────────┤
│ 外层循环：i从1到n-1，执行(n-1)次        │
│ 内层while循环：关键分析点！             │
│                                         │
│ 关键洞察：j的总移动次数                 │
│ - j只能通过if语句增加：最多增加n-1次    │
│ - j通过while语句减少：最多减少n-1次     │
│ - 总的while循环执行次数 ≤ n-1           │
│                                         │
│ 结论：构建next数组 = O(n)               │
└─────────────────────────────────────────┘

阶段2：字符串匹配过程
┌─────────────────────────────────────────┐
│ strStr_KMP函数分析：                    │
├─────────────────────────────────────────┤
│ 关键洞察：i指针的移动特性               │
│ - i只会向前移动，从0到m-1               │
│ - i最多移动m次                          │
│                                         │
│ j指针的移动分析：                       │
│ - j通过匹配增加：最多增加m次            │
│ - j通过next数组减少：最多减少m次        │
│ - 总的操作次数 ≤ 2m                     │
│                                         │
│ 结论：匹配过程 = O(m)                   │
└─────────────────────────────────────────┘

总体复杂度：O(n) + O(m) = O(m+n)
```

"让我用一个具体例子来验证这个分析，"黛芙继续画道：

```ascii
KMP匹配过程示例：haystack='aabaabaafa', needle='aabaaf'

i指针移动轨迹：
0→1→2→3→4→5→6→7→8→9 (最多移动m=10次)

j指针移动轨迹：
0→1→2→3→4→5(失配)→2→3→4→5→6(匹配完成)

j的移动统计：
- 向前移动：0→1→2→3→4→5→2→3→4→5→6 (10次)
- 向后跳转：5→2 (1次，通过next[4]=2)
- 总移动：11次 < 2m=20 ✓

验证：总操作次数远小于BF算法的最坏情况30次
```

安妮看着详细的算法流程，感觉心中那团关于KMP的迷雾豁然开朗。原来，`next`数组就像是为"绣花针"内置的导航仪，在迷路时能立刻给出最佳的下一条路线建议。

"我……我好像真的明白了！"安妮激动地说，"它就像是在玩拼图，当一块拼图对不上时，我们不会把这块拼图扔回盒子从头找，而是会看看这块拼图的边缘形状（后缀），去找盒子里跟它形状相似（前缀）的下一块来尝试！"

#### **next数组的神奇应用**

"嘿，我再给你们看个更好玩的！"希娅又在电脑上调出了另一道题——**LeetCode 459. 重复的子字符串**。"题目是问，一个字符串是否可以由它的某个子串重复多次构成。比如`abab`就是由`ab`重复两次构成的。"

"这怎么用KMP解？"安妮完全想不出头绪。

"这就要用到`next`数组一个隐藏的魔法属性了。"黛芙解释道，"一个字符串`s`如果能由子串重复构成，那它本身的最长公共前后缀（不含自身）一定很长。"

她在白板上写下几个例子：

```ascii
例子1: s = "abab"
最长公共前后缀: "ab" (长度=2)
字符串长度: 4
重复单元长度: 4-2=2, 对应子串"ab"
验证: 4 % 2 == 0 ✓ 是重复子串

例子2: s = "abcabcabc"  
最长公共前后缀: "abcabc" (长度=6)
字符串长度: 9
重复单元长度: 9-6=3, 对应子串"abc"
验证: 9 % 3 == 0 ✓ 是重复子串

例子3: s = "abcdef"
最长公共前后缀: "" (长度=0)
验证: 6 % 6 != 0 ✗ 不是重复子串
```

她写下判断公式：
```python
def repeatedSubstringPattern(s: str) -> bool:
    """判断字符串是否由重复子串构成"""
    next_arr = build_next(s)
    n = len(s)
    lps = next_arr[n - 1]  # 最长公共前后缀长度
    
    # 如果lps > 0 且 n % (n - lps) == 0，则是重复子串
    return lps > 0 and n % (n - lps) == 0
```

#### **性能对比与可视化分析**

"最后，我们来分析一下两种算法的性能差异，"黛芙在白板上画出对比表：

```ascii
算法性能对比表：

BF算法 (朴素匹配):
┌─────────────┬─────────────┬─────────────┬─────────────┐
│   情况      │ 时间复杂度  │ 空间复杂度  │   特点      │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 最好情况    │   O(n)      │   O(1)      │ 第一次匹配  │
│ 平均情况    │   O(mn)     │   O(1)      │ 随机文本    │  
│ 最坏情况    │   O(mn)     │   O(1)      │ 重复字符多  │
└─────────────┴─────────────┴─────────────┴─────────────┘

KMP算法:
┌─────────────┬─────────────┬─────────────┬─────────────┐
│   阶段      │ 时间复杂度  │ 空间复杂度  │   特点      │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ 预处理      │   O(m)      │   O(m)      │ 构建next数组│
│ 匹配过程    │   O(n)      │   O(m)      │ 线性扫描    │
│ 总体        │   O(m+n)    │   O(m)      │ 最优解      │
└─────────────┴─────────────┴─────────────┴─────────────┘

其中: n = len(haystack), m = len(needle)

性能提升可视化：
当n=1000, m=100时的比较次数：

BF最坏情况：  ████████████████████████████████████████ 90,100次
KMP算法：     ████ 1,100次

效率提升：约82倍！
```

"KMP算法用额外的空间存储`next`数组，换来了时间复杂度的巨大提升，"黛芙总结道，"特别是在模式串有很多重复字符的情况下，优势更加明显。"

#### **算法选择策略**

伊莎贝尔温柔地补充道："就像选择不同的乐器演奏不同的曲目，算法的选择也要看具体场景：

- **简单场景**：模式串很短，或者只需要偶尔查找，BF算法简单直接
- **高性能要求**：大文本搜索，或者需要频繁匹配，KMP算法是首选
- **内存受限**：如果内存非常紧张，BF算法的O(1)空间复杂度可能更合适"

一下午的时光，就在这样轻松愉快的"合奏练习"中悄然流逝。从最基础的`strStr`到奇妙的"重复子串"，安妮感觉自己不再是那个只能旁听的观众。她开始能跟上学姐们的节奏，甚至能在她们的引导下，弹出几个属于自己的、虽然简单但却和谐的音符。

当她成功地向学姐们复述出KMP算法在`strStr`问题中的移动逻辑时，黛芙的嘴角，再次勾起了一抹几乎看不见，却无比真实的微笑。

---

🌸 **字符串匹配算法核心要点** 🌸

**1. 算法设计的根本思想**
- **信息复用原则：** 避免重复计算已知信息，KMP通过next数组记住"失败中的成功"
- **预处理与在线处理分离：** 将模式分析（预处理）与文本扫描（匹配）解耦，提升整体效率
- **最坏情况优化：** 从BF的O(n×m)到KMP的O(n+m)，体现了算法设计中"最坏情况分析"的重要性

**2. 核心设计哲学**
- **"智能跳跃"vs"盲目回溯"：** KMP的本质是用空间换时间，通过预存信息避免无效比较
- **模式自相似性利用：** next数组实际上是在挖掘模式串内部的重复结构，这是很多高效算法的共同思路
- **渐进复杂度的意义：** 从平方级到线性级的跨越，展现了算法优化的巨大价值

**3. 算法思维的启发**
- **分治思想：** 将复杂问题分解为"预处理模式"和"扫描文本"两个子问题
- **动态规划思维：** next数组的构建过程体现了"利用子问题最优解构造原问题最优解"的思想
- **工程权衡：** 简单的BF算法 vs 高效的KMP算法，体现了"简单性"与"效率"之间的经典权衡

---

🎀 **安妮的小小日记本**

今天真是超有成就感的一天！

之前学的那些字符串操作，还有BF和KMP算法，感觉就像是一堆漂亮的、但不知道怎么用的乐高零件。可是今天，通过解决"干草堆里找绣花针"这样的实际问题，我才发现，这些"零件"真的可以组合起来，造出解决问题的好用"工具"！

特别是看到黛芙学姐一步步展示KMP算法的完整实现，还有那个详细的复杂度分析，我感觉自己一下子就开窍了！原来复杂度分析不是凭空给出一个O(mn)，而是要一步步推导指针移动次数，计算循环执行次数。原来`next`数组的构建过程是这样的，原来匹配失败时的跳转逻辑是这样的！

虽然还有很多神奇的技巧我没完全搞懂，比如`next`数组和重复子串的关系，但心里一点也不慌了。因为我知道，只要跟着学姐们，多做这样的"合奏练习"，再复杂的乐章，我也一定能弹出自己的旋律！

---

> 字符串匹配（String Matching）是计算机科学中的一类基础且核心的问题，旨在在一个较长的文本串（Text）中查找一个或多个较短的模式串（Pattern）的出现位置。其应用极为广泛，从文本编辑器的查找替换功能，到生物信息学中的基因序列分析，再到网络安全中的入侵检测系统，都离不开高效的字符串匹配算法。算法的优劣主要通过其在不同情况下的时间复杂度和空间复杂度来衡量，其中，预处理阶段（如KMP的`next`数组构建）和匹配阶段的效率是评估的关键。

### 今日关键词

- **strStr():** 一个经典的函数命名，意为"string search string"，功能是在一个字符串中查找另一个子字符串的首次出现位置。
- **Haystack (干草堆):** 在字符串匹配问题中，通常用来比喻被搜索的长字符串（主串）。
- **Needle (绣花针):** 在字符串匹配问题中，通常用来比喻要查找的短字符串（模式串）。
- **Brute-Force (BF算法):** 朴素匹配算法，通过将模式串与主串的所有可能位置进行逐一比较来查找，实现简单但效率较低。
- **next数组 (失效函数):** KMP算法的核心数据结构，存储模式串每个位置的最长公共前后缀长度，用于指导匹配失败时的跳转。
- **最长公共前后缀 (LPS):** 一个字符串的前缀和后缀中最长的相同部分，是构建next数组的基础概念。
- **模式串跳转:** KMP算法的核心思想，匹配失败时根据next数组智能跳转，避免不必要的比较。
- **重复子串模式:** 利用next数组的性质判断字符串是否由某个子串重复构成的技巧。
- **复杂度分析:** 通过分析算法中基本操作的执行次数来评估算法效率的方法，包括最好、平均、最坏情况的分析。
- **指针移动分析:** 在字符串匹配算法中，通过追踪主串指针和模式串指针的移动次数来计算时间复杂度的技术。

### 名词小传

**KMP算法**由Donald Knuth、James Morris和Vaughan Pratt于1977年共同提出，是第一个在最坏情况下仍能保持线性时间复杂度的字符串匹配算法。该算法的核心创新在于通过预处理模式串构建失效函数（next数组），避免了朴素算法中的重复比较，为后续的字符串匹配算法奠定了理论基础。

### 字符串匹配算法定义

字符串匹配算法是一系列用于在主文本串T中定位一个或多个模式串P的出现位置的方法。这些算法的核心目标是高效地完成查找任务，通常通过对模式串进行预处理（如KMP、Boyer-Moore）或对文本串构建高级数据结构（如后缀树、后缀数组）来优化匹配过程，以降低在最坏情况下的时间复杂度，使其优于朴素的暴力搜索。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium  
> 建议顺序：基础 ➜ 进阶 ➜ 面试 ➜ 考研  
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 10 题）**  
1.  LC 20 Valid Parentheses ⭐ —— 栈最经典应用，结果立判成败。  
2.  LC 28 Implement strStr()（BF） ⭐ —— 朴素子串搜索，直观理解双层比较。  
3.  LC 58 Length of Last Word ⭐ —— 单向遍历+边界处理的起点。  
4.  LC 344 Reverse String ⭐ —— 双指针雏形，“看得见”的反转效果。  
5.  LC 557 Reverse Words in a String III ⭐ —— 把第 4 题升级到“按单词”操作。  
6.  LC 14 Longest Common Prefix ⭐ —— 横向扫描，训练子串裁剪。  
7.  LC 709 To Lower Case ⭐ —— 字符编码基础，熟悉 ASCII 偏移。  
8.  LC 242 Valid Anagram ⭐ —— 数组哈希计数零基础范例。  
9.  LC 387 First Unique Character in a String ⭐⭐ —— 频次统计+一次遍历拿答案。  
10. LC 125 Valid Palindrome ⭐⭐ —— 双指针+字符过滤，练边界思维。  

**进阶巩固（练习 10 题）**  
11. LC 67 Add Binary ⭐⭐ —— 模拟二进制加法，巩固从末尾遍历。  
12. LC 389 Find the Difference ⭐⭐ —— 异或 or 计数两种方案对比。  
13. LC 443 String Compression ⭐⭐ —— 指针写压缩，考循环不变量。  
14. LC 1768 Merge Strings Alternately ⭐ —— 交替遍历，手感题。  
15. LC 409 Longest Palindrome ⭐⭐ —— 计数+贪心构造回文长度。  
16. LC 696 Count Binary Substrings ⭐⭐ —— 连续段统计，锻炼窗口思想。  
17. LC 459 Repeated Substring Pattern ⭐⭐ —— 利用 next 数组性质，KMP 练手。  
18. LC 796 Rotate String ⭐⭐ —— 拼接+子串搜索的小技巧。  
19. LC 151 Reverse Words in a String ⭐⭐ —— “去多空格 ➜ 整体 ➜ 局部”三步翻转。  
20. LC 28 Implement strStr()（KMP 版） ⭐⭐ —— 在第 2 题基础上升级线性解。  

**面试常见（冲刺 10 题）**  
21. LC 3 Longest Substring Without Repeating Characters ⭐⭐ —— 滑动窗口入门模板。  
22. LC 49 Group Anagrams ⭐⭐ —— 哈希键设计 + 排序思路对比。  
23. LC 680 Valid Palindrome II ⭐⭐ —— “可删 1 字符”考察双指针回溯。  
24. LC 541 Reverse String II ⭐⭐ —— 分段反转，让指针更灵活。  
25. LC 451 Sort Characters by Frequency ⭐⭐ —— 桶排序思路首次落地。  
26. LC 1876 Substrings of Size Three with Distinct Characters ⭐ —— 固定窗口，三字符练手。  
27. LC 567 Permutation in String ⭐⭐ —— 窗口 + 计数数组综合。  
28. LC 415 Add Strings ⭐ —— 大数加法，考字符串与数字转换。  
29. LC 1209 Remove All Adjacent Duplicates II ⭐⭐ —— 单调栈 / 计数双解对比。  
30. LC 5 Longest Palindromic Substring ⭐⭐ —— 中心扩展版回文“毕业设计”。  

**考研重点（408方向 · 10 题）**  
31. LC 28 strStr() 递归版 ⭐ —— 体会递归与迭代差异，408 手写题常见。  
32. 408 真题·模式匹配 BF 步数推导 ⭐ —— 计算最坏比较次数，练复杂度证明。  
33. 408 真题·KMP next 数组填空 ⭐ —— 熟练手算 next 表。  
34. LC 459 Repeated Substring Pattern（解析版） ⭐⭐ —— KMP 性质再巩固。  
35. LC 686 Repeated String Match ⭐⭐ —— “重复拼接”与 KMP 结合，408 拓展。  
36. LC 767 Reorganize String ⭐⭐ —— 计数贪心 + 408“字符重排”经典。  
37. 408 真题·串存储结构比较 ⭐ —— 理论题，写出顺序/链式优劣。  
38. LC 72 Edit Distance（简输入版） ⭐⭐ —— DP 奠基石，408 必考。  
39. LC 680 → 161 One Edit Distance ⭐⭐ —— “是否相距一步”考察编辑距离思维。  
40. 408 真题·KMP 与 BM 算法比较 ⭐ —— 述评题，准备论述答案。  

// ... existing code ...