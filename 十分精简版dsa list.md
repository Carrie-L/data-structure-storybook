- 数组（Array）：在连续内存中按索引存储元素，支持 O(1) 随机访问但中间插删需移动元素。
- 动态数组（Dynamic Array）：容量可自动扩容的数组，实现均摊 O(1) 末尾插入。
- 单向链表（Singly Linked List）：节点仅存后继指针，插删 O(1) 但按位置访问须顺序遍历。
- 双向链表（Doubly Linked List）：每节点含前驱后继指针，可双向遍历并 O(1) 删除任意已知节点。
- 栈（Stack）：后进先出结构，仅在栈顶 O(1) 压栈弹栈，用于函数调用和括号匹配等。
- 队列（Queue）：先进先出结构，队尾入队队首出队，常用于按层遍历或任务排队。
- 循环队列（Circular Queue）：用环形数组实现队列，节省移动开销并区分满空状态。
- 双端队列（Deque）：首尾均可 O(1) 插删，兼具栈和队列功能，常用于滑动窗口。
- 散列表（Hash Table）：用哈希函数将键映射到桶，实现均摊 O(1) 插查删。
- Bloom Filter：位图+多哈希的概率集合，常数空间查询但有假阳性无假阴性。
- Hash Set：基于散列表实现的无序集合，提供 O(1) 存在性检测与插删。
- Bitset：以位数组压缩存布尔集合，按位操作高效且省内存。
- 二叉树（Binary Tree）：每节点最多两子节点的层次结构，广泛用于表达式和搜索树。
- 二叉搜索树（BST）：左小右大性质支持平均 O(log n) 查插删，最坏退化成链。
- 堆（Binary Heap）：完全二叉树维持堆序，可 O(log n) 插删堆顶、O(1) 取极值。
- 优先队列（Priority Queue）：按优先级出队的队列，通常用堆实现。
- 线段树（Segment Tree）：以树分割区间，支持 O(log n) 区间查询与更新。
- 树状数组（Fenwick Tree）：利用二进制拆分维护前缀和，实现 O(log n) 单点改区间和。
- Trie（前缀树）：按字符层级存串，查插与长度线性，擅长前缀检索。
- Skip List：多层索引链表，概率 O(log n) 查插删，简单替代平衡树。
- LRU 缓存（LRU Cache）：双链表+哈希表在 O(1) 更新最近最少使用淘汰策略。
- 图（Graph）：由顶点和边组成的关系模型，可表示社交、路网等复杂连接。
- 有向图（Directed Graph）：边有方向的图，用邻接表记录出边入度。
- 加权图（Weighted Graph）：每条边带权值，支持最短路和最小生成树算法。
- 并查集（Union‑Find）：用路径压缩与按秩合并维护不相交集合，近乎 O(1) 合并查询。
- 拓扑排序（Topological Order, DS View）：将 DAG 顶点线性化的数据结构基础操作。
- B‑树（B‑Tree）：多路平衡搜索树，节点存多键，磁盘友好且查插删 O(log n)。
- B+‑树（B+ Tree）：数据仅存叶节点并串联链表，范围扫描更快，数据库索引主力。
- AVL 树（AVL Tree）：严格平衡 BST，任意节点左右高差≤1，查插删最坏 O(log n)。
- 红黑树（Red‑Black Tree）：较宽松平衡 BST，旋转少，标准库 map/set 实现。
- 斐波那契堆（Fibonacci Heap）：摊还 O(1) 插并，O(log n) 删除最小，适合 Dijkstra。
- Splay 树（伸展树）：每次访问后旋转到根，适应性好，序列局部性强时近 O(1)。
- Treap：键满足 BST，随机优先级满足堆，期望 O(log n) 平衡简单。
- K‑d 树：递归按维度分割空间，支持多维最近邻与范围查询。
- Quad Tree：将二维空间递归四分，用于碰撞检测与图像压缩。
- Counting Bloom Filter：计数版布隆，可支持删除但空间略增。
- Cuckoo Hashing：两哈希两表位冲突时搬移，查找 O(1) 且负载高。
- Sparse Table：预处理倍增区间静态 RMQ，查询 O(1) 更新不支持。
- 后缀数组（Suffix Array）：排序后缀的数组，线性构建，字符串匹配高效。
- 后缀树（Suffix Tree）：压缩字典树表示所有后缀，子串查询线性时间。
- Patricia Trie：压缩路径的二进制 Trie，路由表和 IP 匹配常用。
- Min‑Max Heap：同时支持取最小和最大，双堆性质维护极值。
- Rope：以平衡树存字符串块，优化大量拼接与切割。
- Cartesian Tree：根据键顺序和优先级建堆排序树，求 RMQ 与序列重构。
- Segment Tree Beats：在线段树上细粒度拆区间标记，处理困难区间最值问题。
- 持久化数据结构（Persistent DS）：保留旧版本可共享节点实现时间穿梭。
- 不可变链表（Immutable List）：节点只读，共享结构实现函数式列表。
- 双重散列（Double Hashing）：开放地址哈希碰撞再加第二哈希步长探查。
- HyperLogLog：基于桶中首1位位置估计基数，1.5 KB 估千万去重。
- 并发队列（Concurrent Queue）：支持多线程安全入出队，常用锁分段或无锁环形缓冲。
- 选择排序（Selection Sort）：每趟选最小交换到前，比较 n² 次交换少。
- 冒泡排序（Bubble Sort）：相邻比较交换，将大元素不断冒到末尾，最坏 n²。
- 插入排序（Insertion Sort）：逐个插入已排序列，几乎有序时近线性。
- 归并排序（Merge Sort）：分治后合并，稳定且 O(n log n) 但需线性额外空间。
- 快速排序（Quick Sort）：随机选枢轴分区，平均 O(n log n) 原地最快，最坏 n²。
- 堆排序（Heap Sort）：建最大堆后反复取顶，原地 O(n log n) 无最坏退化。
- 计数排序（Counting Sort）：按键范围计频再累加，线性排序但需额外空间。
- 基数排序（Radix Sort）：低到高位稳定排序多轮，整数/定长字符串线性时间。
- 二分查找（Binary Search）：在有序数组对半缩范围，查找 O(log n)。
- 双指针（Two Pointers）：两索引协同遍历降低复杂度，典型快慢和对撞用法。
- 滑动窗口（Sliding Window）：动态维护区间统计，元素进出各一次整体线性。
- 递归（Recursion）：函数自调用分解子问题，需终止条件并消耗调用栈。
- 分治算法（Divide and Conquer）：拆分子问题递归解后合并，如归并排序。
- 贪心算法（Greedy Algorithm）：每步局部最优希望整体最优，需可证明贪心性质。
- 回溯（Backtracking）：深度搜索遇非法即撤销，枚举组合排列与数独等。
- 广度优先搜索（BFS）：按层遍历图，求无权最短路与拓扑层次。
- 深度优先搜索（DFS）：沿路径深入回溯，连通分量与拓扑排序常用。
- Dijkstra：非负权图单源最短路，堆优化 O(E log V)。
- Bellman‑Ford：允许负边单源最短路，V‑1 轮松弛并可检测负环。
- Floyd‑Warshall：三重循环求所有点对最短路，复杂度 O(V³)。
- A*：启发式最短路，g+h 估价引导搜索，若启发 admissible 得最优。
- 拓扑排序（Topo Sort, Algo）：线性排 DAG 依赖，Kahn BFS 或 DFS 后序。
- Kahn 算法：基于入度的 BFS 拓扑排序，队列逐步弹零入度。
- Kruskal：边权升序并查集选边，构造最小生成树。
- Prim：从一点扩张小根堆取最小边，生成 MST。
- 最小生成树（MST）：连接所有顶点成本最小的无向树，常用 Prim/Kruskal 算。
- LCA（Lowest Common Ancestor）：树上两节点最近公共祖先，可倍增或线段树维护。
- 动态规划（Dynamic Programming）：记忆子问题避免重复，解决最优子结构问题。
- 0/1 背包（0/1 Knapsack）：DP 在容量维度转移选择拿或不拿求最大价值。
- LCS（最长公共子序列）：二维 DP 求两序列最长保持顺序的公共子序列。
- 单调队列优化（Monotone Queue）：用递增/递减队列优化 DP 或滑窗最值到 O(1)。
- Bitmask DP：用位集表示状态的 DP，解决小 n 组合优化如旅行商。
- 朴素字符串匹配（Naïve Match）：逐位对齐比较，最坏 O(n·m)。
- KMP：前缀函数加速失配位移，文本匹配线性时间。
- Rabin‑Karp：滚动哈希滑窗匹配，多模式平均线性。
- Z‑Algorithm：构建 Z 数组一次遍历得每前缀匹配长度。
- Boyer‑Moore：坏字符+好后缀启发逆向匹配，实际极快。
- Manacher：线性时间求字符串最长回文子串，利用对称半径。
- 后缀自动机（SAM）：线性构建最小状态机，解决不同子串计数等问题。
- FFT（Fast Fourier Transform）：将时域序列转到频域，卷积多项式 O(n log n)。
- 欧几里得算法（GCD）：递归取余求最大公约数，复杂度 O(log n)。
- 模幂运算（Modular Exponentiation）：二分幂取模，log n 计算大指数模值。
- 埃拉托斯特尼筛（Sieve of Eratosthenes）：迭代标记倍数线性‑log 生成素数表。
- 中国剩余定理（CRT）：将同余方程组合并成唯一模 M 解。
- 蒙特卡洛方法（Monte Carlo）：用随机样本估计数值或概率，结果有置信误差。
- 随机 Quickselect：随机枢轴线性期望找第 k 小元素。
- 单纯形法（Simplex）：在线性规划顶点间沿成本下降边迭代至最优解。
- 最大流 Ford‑Fulkerson：迭代寻找增广路增流，残量网络直至无路。
- 最小费用最大流：在残流图上用最短路迭代增流，兼顾容量与费用。
- Heavy‑Light Decomposition：将树剖成重轻链以支持子树/路径查询 O(log² n)。