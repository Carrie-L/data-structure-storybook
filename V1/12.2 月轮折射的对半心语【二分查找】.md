### **12.2 月轮折射的对半心语【二分查找】**

*"我立于世界中央，一次回眸，便舍弃一半的星辰。只因我确信，你一定在另一半的苍穹里。"*

在理解了顺序查找那朴素而坚定的“地毯式搜索”后，女孩们围坐在山顶的一处观景台，夜色渐浓，一轮皎洁的满月升上天空，如同一面巨大的银盘，清辉遍洒。

“顺序查找虽然可靠，但如果数据量很大，效率确实太低了。”安妮回想着O(N)的复杂度，不禁说道，“就像要在整片森林里找一片特定的叶子，太难了。”

“说得对，”黛芙点头，“所以，为了实现更高效的查找，我们通常会有一个前提条件——数据是‘有序’的。这就像我们之前学习排序的意义所在。”

伊莎贝尔指着天上的明月，柔声问道：“安妮，我们来玩一个猜数字的游戏。我在心里想一个1到100之间的数字，你来猜。你每猜一次，我只会告诉你‘大了’、‘小了’或‘猜中了’。你会怎么猜？”

“我……会先猜50？”安妮试探着说。

“为什么是50？”

“因为50在最中间。如果你说‘小了’，那我就知道答案在51到100之间，一下子就排除了近一半的数字！如果说‘大了’，那答案就在1到49之间。接下来，我再猜剩下那一半的中间数……”

“完美！”伊莎贝尔的眼中充满了赞许，“安妮，你刚刚描述的，就是‘二分查找’（Binary Search）的完整思想。它就像这轮明月，每一次都用自己的光辉，将我们寻找的夜空，清晰地分割成两半。”

#### **对半的艺术：二分查找的逻辑**

“二分查找，是一种在‘有序数组’中查找特定元素的高效算法。”黛芙开始在白板上进行讲解，她写上一个有序数组：`[ 2, 5, 7, 8, 11, 12, 15, 19, 22 ]`，目标是查找 `12`。

“我们需要三个指针来辅助我们完成这场‘对半游戏’：`left` 指向数组的起始，`right` 指向数组的末尾，`mid` 指向它们的中间。”

```ascii
查找过程演示: target = 12

初始状态:
arr = [ 2, 5, 7, 8, 11, 12, 15, 19, 22 ]
      L↑                      R↑

第一轮:
1. mid = (L+R)/2 = (0+8)/2 = 4。arr[mid] = arr[4] = 11。
   [ 2, 5, 7, 8, 11, 12, 15, 19, 22 ]
   L↑            M↑             R↑
2. 比较 target(12) 和 arr[mid](11)。 12 > 11。
3. 这意味着目标一定在 mid 的右半部分。我们舍弃左半边，更新 L = M + 1。
   [ 2, 5, 7, 8, 11, 12, 15, 19, 22 ]
                     L↑          R↑

第二轮:
1. mid = (L+R)/2 = (5+8)/2 = 6。arr[mid] = arr[6] = 15。
   [ 2, 5, 7, 8, 11, 12, 15, 19, 22 ]
                     L↑ M↑       R↑
2. 比较 target(12) 和 arr[mid](15)。 12 < 15。
3. 这意味着目标一定在 mid 的左半部分。我们舍弃右半边，更新 R = M - 1。
   [ 2, 5, 7, 8, 11, 12, 15, 19, 22 ]
                     L↑R↑

第三轮:
1. mid = (L+R)/2 = (5+5)/2 = 5。arr[mid] = arr[5] = 12。
   [ 2, 5, 7, 8, 11, 12, 15, 19, 22 ]
                     L,M,R↑
2. 比较 target(12) 和 arr[mid](12)。 12 == 12。
3. 查找成功！返回索引 5。
```

“太快了！”安妮惊叹道，“一个9个元素的数组，只比较了3次就找到了！要是用顺序查找，得比较6次。”

#### **代码实现：循环与边界**

“二分查找的思路很简单，但它的代码实现却有很多细节，尤其是‘边界条件’，很容易出错。”希娅一边说，一边展示了最常见的实现模板。

```python
def binary_search(arr: list, target) -> int:
    left, right = 0, len(arr) - 1
    
    # 循环条件：当 left <= right 时，表示查找区间仍然有效
    while left <= right:
        # mid = (left + right) // 2  # 这种写法可能在某些语言中导致整数溢出
        mid = left + (right - left) // 2 # 更稳妥的写法
        
        if arr[mid] == target:
            return mid # 找到目标
        elif arr[mid] < target:
            # 目标在右半区
            left = mid + 1
        else:
            # 目标在左半区
            right = mid - 1
            
    return -1 # 未找到
```

“看这几个关键点，”希娅强调，“`while left <= right` 保证了即使`left`和`right`重合（只剩一个元素）时，循环依然会执行。`left = mid + 1` 和 `right = mid - 1` 则确保了查找范围在每一轮都必定会缩小，避免死循环。”

#### **复杂度分析：log(N) 的威力**

“现在，我们来分析一下，为什么二分查找如此高效。”黛芙的表情严肃起来。

```ascii
二分查找复杂度分析：

令 N 为序列的长度

┌─────────────────────────────────────────┐
│ 时间复杂度分析 (Time Complexity):         │
├─────────────────────────────────────────┤
│ 假设我们经过 k 轮查找，找到了元素。
│ - 第一轮后，剩余元素数量: N/2
│ - 第二轮后，剩余元素数量: N/4
│ - 第 k 轮后，剩余元素数量: N / 2^k
│
│ 在最坏情况下，查找到只剩 1 个元素时才找到目标。
│ N / 2^k = 1  =>  N = 2^k  =>  k = log₂(N)
│
│ 每一轮都只进行常数次比较，所以总时间复杂度与轮数 k 成正比。
│
│ 结论：最好、最坏、平均时间复杂度均为 O(logN)
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 空间复杂度分析 (Space Complexity):        │
├─────────────────────────────────────────┤
│ - 算法只需要 left, right, mid 等常数个额外变量。 │
│ - 结论：O(1)                              │
└─────────────────────────────────────────┘
```

“从O(N)到O(logN)，这是一个巨大的飞跃。”黛芙在白板上画出了对比图。

```ascii
数据规模 N        顺序查找(N)        二分查找(logN)
-----------------------------------------------------
1,024             ~1,024 次          ~10 次
1,048,576         ~100万 次          ~20 次
1,000,000,000     ~10亿 次           ~30 次
```

“天哪！”安妮看着这个对比，被log(N)的威力深深震撼了，“即使数据量达到10亿，也只需要30次左右的比较！这简直是魔法！”

月光下，女孩们都陷入了对数之美的沉思。二分查找，这个看似简单的算法，却以一种极致优雅的方式，诠释了“信息”的力量。每一次比较，都能排除掉一半的可能性，这正是建立在“有序”这一信息基础之上的、最高效的决策。

---

🌸 **查找算法核心要点** 🌸

**1. 算法设计的根本思想**
- **利用有序性：** 二分查找的强大威力，完全建立在“数据有序”这一前提之上。它将元素的“大小信息”转化为“位置信息”，通过一次比较，就能判断目标在哪一个“位置区间”。
- **减治思想：** 二分查找是减治思想（Decrease and Conquer）的又一典范。它通过将问题规模减半（而不是像递归那样减一或减常数），实现了对数级别的时间复杂度。
- **边界控制：** 算法的正确性高度依赖于对查找区间`[left, right]`的精确定义和更新。`left <= right`的循环条件、`mid`的计算方式、`left`和`right`的更新策略，共同构成了二分查找的“三位一体”，任何一个细节出错都可能导致失败。

**2. 核心设计哲学**
- **确定性的排除：** 与顺序查找的“逐一确认”不同，二分查找的核心是“批量排除”。每一步操作的目标，不是为了“找到”，而是为了“排除尽可能多的不可能选项”。
- **对数复杂度的力量：** O(logN)是计算机科学中一种非常理想的时间复杂度。它意味着算法的运行时间增长得极其缓慢，即使数据规模爆炸式增长，算法的性能也几乎不受影响。二分查找是体验这种力量的最佳入门。
- **简单思想的严谨实现：** “对半查找”的思想非常简单，但要写出一个完全正确、没有bug的二分查找代码却非易事。这深刻地体现了将一个简单的算法思想，转化为严谨、可靠的工程代码之间存在的鸿沟。

**3. 算法思维的启发**
- **前提的重要性：** 二分查找的例子告诉我们，为了获得高效的算法，有时需要付出预处理的代价（如先进行排序）。O(N logN)的排序 + O(logN)的查找，在多次查找的场景下，远比每次都O(N)的顺序查找要高效。
- **抽象问题的转化：** 很多看似与查找无关的问题，如“寻找第一个大于X的数”、“寻找峰值”等，其本质都可以抽象为在一个具有“单调性”的序列上进行查找，从而应用二分查找的思想来解决。
- **代码的健壮性：** `mid = left + (right - left) // 2` 这个细节，提醒我们在编写代码时，要考虑到潜在的极端情况（如整数溢出），追求代码的健壮性和可移植性。

---

🎀 **安妮的小小日记本**

今晚的月亮真美！伊莎贝尔学姐用猜数字游戏来教我二分查找，我感觉自己一下子就懂了！

“每次都猜中间”，这个想法虽然简单，但威力也太巨大了吧！O(logN)的复杂度，让我第一次直观地感受到了数学的力量。10亿的数据，30次比较，这比我翻书找一页还要快！

不过，希娅学姐也提醒我，二分查找的“边界”很容易出错。`left`、`right`、`mid`这三个小指针，就像在跳一支非常精确的芭蕾舞，多一步、少一步、错一步都不行。我一定要多练习，把它的所有舞步都刻在脑子里！

从今天起，如果再有人让我猜东西，我一定先问：“这个范围是有序的吗？” 哈哈！

---

### 今日关键词

- **二分查找 (Binary Search):** 一种在有序数组中查找某一特定元素的搜索算法。通过将查找区间一分为二，来逐步缩小查找范围。
- **有序数组 (Sorted Array):** 二分查找能够使用的前提条件，指数组中的元素按照某种顺序（升序或降序）排列。
- **对数时间复杂度 (Logarithmic Time Complexity):- O(logN)。这是非常高效的时间复杂度，常见于采用分治策略（特别是问题规模减半）的算法。
- **边界条件 (Boundary Conditions):** 在算法实现中，对循环的起始、终止条件以及索引的更新等边缘情况的处理。二分查找因其边界问题而闻名。
- **单调性 (Monotonicity):** 指序列中的元素遵循某种持续增加或持续减少的规律。一个函数或序列如果具有单调性，通常就可以考虑使用二分查找的思想。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶 ➜ 面试
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 4 题）**  
1.  LC 704 Binary Search ⭐ —— 这是最标准、最纯粹的二分查找模板题，是入门的必经之路。
2.  LC 35 Search Insert Position ⭐ —— 二分查找的简单变体。当找不到目标时，需要返回它应该被插入的位置，能让你思考`left`指针的最终含义。
3.  LC 278 First Bad Version ⭐⭐ —— 一个经典的二分查找应用。问题被包装成寻找第一个“坏”版本，本质是在一个`[F, F, F, T, T, T]`的序列中寻找第一个`T`。
4.  LC 374 Guess Number Higher or Lower ⭐ —— 与本章开头的猜数字游戏一模一样，是二分查找思想最直接的体现。

**进阶巩固（变体应用）**  
5.  LC 34 Find First and Last Position of Element in Sorted Array ⭐⭐ —— 考察如何通过两次二分查找，分别找到目标的“左边界”和“右边界”。这是二分查找处理重复元素的经典考题。
6.  LC 153 Find Minimum in Rotated Sorted Array ⭐⭐ —— 在一个旋转过的有序数组中寻找最小值（转折点）。这需要你通过比较`arr[mid]`和`arr[right]`，来判断哪一半是单调的，从而决定搜索区间。
7.  LC 33 Search in Rotated Sorted Array ⭐⭐ —— 上一题的升级版，不仅要找到转折点，还要在旋转数组中找到目标值。是二分查找应用的综合考验。
8.  LC 162 Find Peak Element ⭐⭐ —— 寻找数组中的“峰值”。利用题目给出的`nums[i] != nums[i+1]`的条件，可以通过比较`nums[mid]`和`nums[mid+1]`来确定峰值在哪一半，是二分思想的巧妙应用。

**面试常见（抽象应用）**  
9.  LC 69 Sqrt(x) ⭐ —— 用二分查找来寻找一个数的平方根。将问题转化为：在`[0, x]`的范围内，寻找一个数`k`，使得`k*k`最接近`x`。
10. LC 875 Koko Eating Bananas ⭐⭐⭐ —— “二分答案”的经典入门题。问题要求最小的进食速度，我们可以对“速度”这个值进行二分查找，然后在`check`函数中判断以当前速度能否在规定时间内吃完所有香蕉。
11. LC 410 Split Array Largest Sum ⭐⭐⭐ —— “二分答案”的又一经典难题。对“子数组各自和的最大值”进行二分查找，判断是否存在一种分割方案，使得这个最大值不超过我们二分出的`mid`。
