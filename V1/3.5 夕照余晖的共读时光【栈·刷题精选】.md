### **3.5 夕照余晖的共读时光【栈·刷题精选】**

*"当夕阳的余晖，为书页镀上金边，我们于这静谧的共读时光中，将所有关于栈的思绪，沉淀为指尖的、一行行坚实的代码。"*

在系统地学习了栈的原理、实现、经典应用与复杂度分析后，关于“栈”的理论篇章，也即将画上句号。春日祭典的喧嚣渐渐远去，一个宁静的傍晚，女孩们再次聚集在图书馆，享受着夕阳余晖下的共读时光。

“栈，这位‘后进先出’的智者，它的故事，我们已经基本了解了。”黛芙合上一本厚厚的典籍，“现在，是时候，通过一场最后的‘解谜游戏’，来将它的智慧，真正地，化为我们自己的能力了。”

希娅早已准备好了她的“谜题”——几道精选的、极具代表性的栈相关的LeetCode题目。这些题目，将从不同的角度，考验她们对LIFO原则的理解和应用能力。

#### **第一道谜题：最小栈的追问 (Min Stack)**

希娅展示了第一题，一道她们之前讨论过，但尚未亲手实现的经典设计题：**LC 155. 最小栈**。

“要求我们设计一个栈，除了支持常规的`push`, `pop`, `top`操作外，还必须支持一个`getMin`操作，它能以**O(1)的时间复杂度**，返回当前栈中的最小值。”

“我记得了！”安妮立刻说，“关键在于，不能只用一个变量来记录最小值，因为当这个最小值被弹出后，我们就不知道‘第二小’的值是多少了。我们需要一个‘**辅助栈**’！”

**解题思路：辅助栈法**

-   **数据结构：** 创建两个栈，一个`data_stack`用于正常存储数据，另一个`min_stack`用于存储“**每个阶段的最小值**”。
-   **`push(x)` 操作:**
    1.  `data_stack`正常`push(x)`。
    2.  对于`min_stack`，我们查看它当前的栈顶`min_top`。如果`min_stack`为空，或者新元素`x`小于等于`min_top`，我们就将`x`也压入`min_stack`。
-   **`pop()` 操作:**
    1.  从`data_stack`弹出的元素，我们称之为`popped_val`。
    2.  **关键：** 我们检查一下，这个`popped_val`，是否恰好等于`min_stack`当前的栈顶元素。如果是，那么`min_stack`也必须**同步地**`pop`一下，以“暴露”出下一个阶段的最小值。
-   **`getMin()` 操作:**
    1.  直接返回`min_stack`的栈顶元素即可。

“这个解法，比我们之前讨论的‘同步压入’的版本，在空间上更优化一些。”黛芙补充道，“它只有在遇到‘新的’最小值时，才向`min_stack`中压入元素，避免了存储大量重复的最小值。”

安妮立刻动手，将这个思路，实现为清晰的代码。当看到屏幕上出现“Accepted”时，她对这种“用一个数据结构，去辅助另一个数据结构”的组合思想，有了更深的体会。

#### **第二道谜题：温度的预言 (Daily Temperatures)**

“下一题，是我们之前在‘解题流程’章节，由安妮独立推导出的那道题。”伊莎贝尔微笑着，点开了 **LC 739. 每日温度**。

“现在，让我们完整地，再实现一次这个‘**单调栈**’的经典应用。”

**问题回顾：** 给定一个每日温度列表，为每一天，计算需要等待多少天，才能等到一个更暖和的日子。

**单调栈思路：**
1.  初始化一个空栈`stack`（用来存放**下标**），和一个全为0的结果数组`result`。
2.  从左到右，遍历温度数组`temperatures`。
3.  对于当前温度`T[i]`，进入一个`while`循环：
    -   只要栈不为空，并且当前温度`T[i]`，**大于**栈顶下标所对应的温度`T[stack.top()]`，就说明，我们为栈顶的那个“寒冷的日子”，找到了它等待的“温暖的一天”！
    -   于是，我们`pop`出栈顶的下标`prev_index`，并计算等待天数`i - prev_index`，存入`result[prev_index]`。
    -   不断重复，直到栈为空，或`T[i]`不再大于栈顶温度。
4.  将当前这一天的下标`i`，压入栈中，让它也开始“等待”一个比它更暖和的未来。

“单调栈，维护了一个‘**单调递减**’的温度序列（的下标）。”黛芙总结道，“它像一个‘等候区’，所有‘暂时找不到答案’的日子，都在里面排队。一旦一个‘温暖’的日子到来，所有比它‘冷’的等待者，就都得到了救赎。”

#### **第三道谜题：雨水的容量 (Trapping Rain Water)**

“最后，是一道‘史诗级’的难题，也是对栈应用理解的终极考验。”希娅的眼中，闪烁着挑战的光芒。**LC 42. 接雨水**。

“给定一个非负整数数组，代表一个海拔高度图。计算在下雨之后，这个地形图，总共能‘接住’多少雨水。”

```ascii
   #
 # #   #
 # ## # #
##########
[0,1,0,2,1,0,1,3,2,1,2,1]
```

这个问题，让安妮陷入了沉思。她能感觉到，一个位置能接住水，取决于它“左边”和“右边”的高度。

“这道题，可以用DP，也可以用双指针来解。”黛芙说，“但它同样，可以用‘单调栈’，给出一个非常巧妙的、虽然不那么直观，但逻辑自洽的解法。”

**单调栈解法思路：**
-   我们同样，维护一个“单调递减”的栈，但这次，栈里存的，是柱子的**下标**。
-   我们遍历高度图。当遇到一个柱子`height[i]`时：
    -   如果它比栈顶的柱子“矮”或相等，就直接入栈。我们在构建一个“凹”形的左半部分。
    -   如果它比栈顶的柱子“高”，机会来了！一个“凹”形结构，出现了！
        -   `stack.top()`就是“凹”形的“**底**”。
        -   新来的`height[i]`，是“凹”形的“**右墙**”。
        -   而`pop`出栈顶后，新的栈顶，就是“凹”形的“**左墙**”！
        -   我们就可以计算出，由这个“左墙”、“右墙”和“底”，所构成的这个“凹槽”，能接多少雨水了！
        -   我们不断地`pop`，直到栈顶不再比`height[i]`矮，即填满了所有能填的雨水。
    -   最后，将当前的`i`入栈，作为未来可能的新“墙”或新“底”。

这个解法，非常精妙，也有些晦涩。女孩们在白板上，反复地画图、推演，才最终，理解了这每一次出栈入栈背后，那计算“凹槽”容量的深刻含义。

夕阳的余晖，透过图书馆的玻璃，为整个房间，镀上了一层温暖的金色。安妮感觉，自己的大脑，像一块被反复锤炼的精钢，变得滚烫，却也更加坚韧、更加锋利。栈，这个简单的、只有两个操作的工具，在这些复杂的谜题中，竟能爆发出如此惊人的、构建逻辑的力量。

---

🌸 **栈应用核心要点** 🌸

**1. 算法设计的根本思想**
- **单调栈模型：** （回顾）“下一个更大/更小元素”问题，是“单调栈”的典型应用场景。其核心，是维护一个具有单调性的栈，通过与新元素的比较，来处理栈顶元素的“出路”问题。它是一种用O(N)时间，解决一类特定序列问题的强大模型。
- **数据结构的组合与增强：** （回顾）“最小栈”问题，展现了如何通过“组合”两个基础数据结构（两个栈），来实现一个“增强”的、具有新功能的数据结构。这种“辅助数据结构”的思想，在设计复杂系统时非常常见。
- **用栈来处理“几何”问题：** “接雨水”问题，巧妙地，将一个看似是“几何”或“双指针”的问题，转化为了一个“单调栈”可以处理的“凹槽计算”问题。这展现了算法思想之间，奇妙的、跨领域的联系。

**2. 核心设计哲学**
- **延迟处理（Deferred Processing）：** （回顾）单调栈的思想，可以看作是一种“延迟处理”。当一个元素`x`入栈时，我们并不立刻确定它的答案，而是将它“暂存”起来。直到一个能“触发计算”的元素`y`出现时，栈中的一个或多个元素的“命运”才被确定。
- **状态的同步维护：** （回顾）在最小栈的设计中，`data_stack`和`min_stack`的`push`和`pop`操作，必须是严格同步的（或有明确的对应关系），以保证在任何时刻，`min_stack`的栈顶，都对应着`data_stack`当前状态下的最小值。

**3. 算法思维的启发**
- **寻找“最近的相关性”：** 栈的LIFO特性，天然地，与“寻找左边/右边第一个……”这类问题相契合。当你发现问题的解，只依赖于其“近邻”的、满足某种条件的元素时，就可以考虑用栈来优化查找过程。
- **“凹”与“凸”的形状识别：** 单调栈在“接雨水”、“柱状图最大矩形”等问题中的应用，都与识别和计算“凹”形或“凸”形的几何结构有关。栈，成为了动态寻找和定义这些“形状”的有力工具。

---

🎀 **安妮的小小日记本**

今天的刷题茶会，更像是一场“下午茶头脑风暴”！

我发现，栈，这位“一根筋”的朋友，它的性格，真的太适合解决一类问题了——那些需要“回头看”，而且只关心“最近那一个”的问题。

比如“下一个更大元素”，我站在队伍里，想找右边第一个比我高的人。我不需要看很远，我只需要，让所有比我先进队伍、但比我矮的人，都先出局。然后，留在我前面的那个人，就是我的答案！这个“单调栈”的思路，真的好形象！

而“接雨水”那道题，真的好难，但也真的好酷！用栈，来寻找一个个可以存水的“凹槽”。每当一个高的墙出现，就回头，看看能不能和更早的墙，形成一个“碗”，把中间的“坑”给填满。这个过程，就像是在玩一个“俄罗斯方块”的变种游戏。

我感觉，栈，就像一个时间机器。它能让我们，在一次线性的遍历中，随时“回到过去”，去查询和利用那些“刚刚发生”的历史信息。这种能力，真的太强大了！

---

### 今日关键词

- **单调栈 (Monotonic Stack):** （回顾）一种内部元素（从栈底到栈顶）始终保持单调递增或单调递减的栈结构。常用于解决“下一个更大/更小元素”等问题。
- **辅助栈 (Auxiliary Stack):** （回顾）在设计新的数据结构时，用于辅助主数据结构，完成特定功能（如记录最小值）的额外栈。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> （本章的练习题已在3.1和3.3节中详细列出，此处不再重复。请参考之前的推荐列表，并额外挑战以下几道经典题目，以深化对栈应用的理解。）

**额外挑战**
1.  LC 84. Largest Rectangle in Histogram ⭐⭐⭐ —— 柱状图中最大的矩形。单调栈最经典、也最困难的应用之一。通过维护一个单调递增的栈，可以在O(N)时间内，为每个柱子，找到它左边和右边第一个比它矮的柱子，从而确定以它为高的最大矩形面积。
2.  LC 42. Trapping Rain Water ⭐⭐⭐ —— （回顾）接雨水。这道题除了用双指针和DP，也可以用单调栈来解决。是检验对单调栈理解深度的绝佳题目。
3.  LC 316. Remove Duplicate Letters ⭐⭐⭐ —— 去除重复字母。要求在去除重复字母后，使得结果的字典序最小。需要用一个栈，来维护一个单调递增的、且符合条件的字符序列，是一个贪心+栈的综合难题。
