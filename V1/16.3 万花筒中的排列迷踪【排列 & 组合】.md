### **16.3 万花筒中的排列迷踪【排列 & 组合】**

"转动万花筒，每一次的色彩交错，都是一次排列的幻化；每一次的元素拾取，都是一幅组合的剪影。于有限中，窥见无穷。"

在解决了N皇后这个精巧的棋盘对弈后，安妮对回溯算法“在约束中跳舞”的能力，有了深刻的体会。为了让大家更系统地掌握回溯的应用，黛芙决定，用几个最基础、最核心的组合数学问题，来彻底拆解回溯的通用框架。

“N皇后问题，可以看作是在一个N×N的格子里，选择N个位置的‘组合’问题，并附加了行列斜线的约束。”黛芙说，“今天，我们抛开复杂的约束，来研究最纯粹的‘**排列**’、‘**组合**’和‘**子集**’问题。它们是回溯算法的‘三大基本功’，几乎所有更复杂的组合搜索问题，都是它们的变体。”

伊莎贝尔拿出一个万花筒，递给安妮。“你看，这里面只有几种颜色的玻璃碎片（元素集合）。但你轻轻一转，它们就能组合出无穷无尽的美丽图案。回溯算法，就是那个能系统地‘转动’万花筒，并记录下每一种独特图案的‘魔法’。”

#### **问题一：子集 (Subsets)**

“我们从最简单的开始：**求一个集合的所有子集**。”

**问题：** 给定一个不含重复元素的整数数组 `nums`，返回其所有可能的子集（幂集）。
例如: `nums = [1, 2, 3]`
结果: `[ [], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3] ]`

“这个问题，可以怎么用回溯来思考？”黛芙提问。

安妮想了想，说：“对于集合里的每一个元素，我们都面临一个选择：‘选它’，或者‘不选它’。”

“正是如此！”黛芙画出了一棵决策树。

```ascii
                []
               /  \
           选1 /    \ 不选1
             /      \
           [1]        []
          /  \      /  \
      选2 /    \不选2/    \不选2
        /      \  /      \
      [1,2]      [1] []       [2]
      / \        / \/ \      / \
  选3/   \不选3 ...
    /     \
[1,2,3]  [1,2]
```

“我们从一个空集开始，遍历`nums`中的每个数，对每个数都做‘选’与‘不选’的决策，递归下去，就能得到所有结果。”

```python
# 子集问题的回溯实现
def subsets(nums: list[int]) -> list[list[int]]:
    result = []
    path = []

    def backtrack(start_index: int):
        # 每一个节点，本身都是一个合法的子集，先加入结果
        result.append(path[:])
        
        # 从 start_index 开始，遍历选择列表
        for i in range(start_index, len(nums)):
            # 做出选择
            path.append(nums[i])
            # 进入下一层决策 (注意：下一层的选择要从 i+1 开始，避免重复)
            backtrack(i + 1)
            # 撤销选择
            path.pop()

    backtrack(0)
    return result
```

#### **问题二：组合 (Combinations)**

“接下来，是**组合**问题。”

**问题：** 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。
例如: `n = 4, k = 2`
结果: `[ [1,2], [1,3], [1,4], [2,3], [2,4], [3,4] ]`

“组合，讲究的是‘选哪几个’，而不在乎它们的顺序。`[1,2]`和`[2,1]`是同一个组合。”希娅补充道。

“这个问题，和子集问题非常像！”安妮立刻发现了关联，“它就像是‘求所有大小为k的子集’！”

“完全正确！”黛芙笑道，“所以，我们几乎可以复用子集问题的代码，只需要加一个‘结束条件’的判断。”

```python
# 组合问题的回溯实现
def combine(n: int, k: int) -> list[list[int]]:
    result = []
    path = []

    def backtrack(start_num: int):
        # 剪枝：如果剩余元素都不够凑成k个，就没必要继续了
        # if len(path) + (n - start_num + 1) < k: return

        # 结束条件：当路径长度等于k时，找到了一个组合
        if len(path) == k:
            result.append(path[:])
            return

        # 从 start_num 开始，遍历选择列表
        for i in range(start_num, n + 1):
            path.append(i)
            backtrack(i + 1) # 递归
            path.pop() # 回溯

    backtrack(1)
    return result
```

#### **问题三：排列 (Permutations)**

“最后，是‘**排列**’问题。它不仅关心‘选哪几个’，还关心它们的‘顺序’。”

**问题：** 给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。
例如: `nums = [1, 2, 3]`
结果: `[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]`

“排列和组合的核心区别在于，”黛芙讲解道，“组合问题中，我们传入`start_index`来避免重复选择，`[1,2]`和`[2,1]`只取其一。但在排列问题中，`[1,2]`和`[2,1]`是不同的解，我们需要考虑所有顺序。”

“这意味着，在每一层决策中，我们的‘选择列表’，都是‘所有尚未被使用过’的元素。”

“所以，我们需要一个`used`数组来标记哪些元素已经在当前路径中了！”安妮抢答。

```python
# 排列问题的回溯实现
def permute(nums: list[int]) -> list[list[int]]:
    result = []
    path = []
    used = [False] * len(nums)

    def backtrack():
        # 结束条件：当路径长度等于元素总数时，找到了一个排列
        if len(path) == len(nums):
            result.append(path[:])
            return

        # 遍历所有元素作为选择列表
        for i in range(len(nums)):
            # 剪枝：如果元素已经被使用过，则跳过
            if used[i]:
                continue
            
            # 做出选择
            path.append(nums[i])
            used[i] = True
            
            backtrack() # 递归
            
            # 撤销选择
            used[i] = False
            path.pop()

    backtrack()
    return result
```

转动万花筒，镜面的每一次反射，都严格地遵循着光学的定律。安妮看着这三份高度相似、却又在细节处各有不同的代码，彻底理解了回溯算法那个通用模板的强大。子集、组合、排列，这三个组合数学的基石，在回溯这支统一的“舞步”下，呈现出了各自不同的、和谐而曼妙的舞姿。

--- 

🌸 **回溯算法核心要点** 🌸

**1. 算法设计的根本思想**
- **抽象为树形结构：** 解决组合、排列、子集问题的核心，是能将问题抽象为一棵“决策树”或“状态空间树”。每个节点代表一个中间状态，每条边代表一个决策，从根到叶的路径构成一个解。
- **选择、递归、撤销：** 这是回溯“三部曲”。“选择”是在当前节点，决定走哪条分支；“递归”是深入到下一个节点；“撤销”则是当子树探索完毕后，返回当前节点，准备探索其他分支。
- **通过参数控制搜索范围：** 在组合和子集问题中，通过传递`start_index`参数，巧妙地保证了元素不会被重复使用，且解集不会包含重复的组合（如`[1,2]`和`[2,1]`）。这是避免组合问题重复的关键技巧。

**2. 核心设计哲学**
- **排列与组合的本质区别：**
    -   **组合**关心“选了谁”，不关心“顺序”。实现上，通过`start_index`控制，保证下一次选择总是在当前选择之后，从而避免了顺序颠倒的重复情况。
    -   **排列**既关心“选了谁”，也关心“顺序”。实现上，需要一个`used`数组来记录路径上已有的元素，每一层都可以从“所有未使用过”的元素中进行选择。
- **剪枝的两种类型：**
    -   **可行性剪枝：** 如排列中的`if used[i]`，如果一个选择会让解变得不合法，则直接剪掉。
    -   **最优性剪枝：** （在求最优解的回溯问题中）如果当前路径的成本已经超过了已知的最优解，或者其预估成本也无法超越最优解，则可以剪枝。
- **结果的拷贝：** 在将`path`加入`result`时，必须使用`path[:]`或`list(path)`进行一次拷贝。因为`path`本身是一个在整个回溯过程中被反复修改的“共享”变量，如果不拷贝，最终`result`里的所有引用都会指向最后一次的状态。

**3. 算法思维的启发**
- **识别问题类型：** 看到“所有可能”、“全部方案”这类字眼，就要本能地联想到回溯法。然后，再仔细分析问题，判断它属于“子集”、“组合”还是“排列”模型，或其变体。
- **处理重复元素：** 当输入集合中包含重复元素时，回溯问题会变得更复杂，需要额外的“去重”逻辑。通常的策略是“先排序，再剪枝”，即在遍历选择列表时，如果当前元素和前一个元素相同，并且前一个元素“刚刚被撤销选择”，则跳过当前选择。
- **回溯是“框架”而非“算法”：** 回溯本身不是一个具体的算法，而是一个解决问题的“元框架”（Meta-framework）。我们需要根据具体问题，去填充这个框架的各个部分（如选择列表、结束条件、剪枝逻辑）。

--- 

🎀 **安妮的小小日记本**

今天就像上了一堂数学课，但比数学课有趣一百倍！子集、组合、排列，这些以前在数学书上让我头疼的概念，今天在回溯算法的框架下，变得如此清晰！

我发现它们三个，就像是亲兄弟，都用着同一套“回溯”心法，但性格各不相同。

-   **子集**最随和，每个元素都可以“要”或“不要”，非常自由。
-   **组合**有点小洁癖，它只关心你选了哪几个，不在乎你怎么排列它们，所以它总是“向前看”，绝不回头选已经路过的元素。
-   **排列**最讲究，不仅要选出来，还得给它们排好队，顺序错了都不行。所以它需要一个“记名册”(`used`数组)，确保每个队员只出场一次。

理解了它们之间的区别和联系，我感觉自己好像掌握了一把能打开很多组合问题大门的钥匙。回溯算法，真是一个神奇的万花筒！

--- 

### 今日关键词

- **子集 (Subset):** 一个集合中，任意选择零个或多个元素组成的集合。
- **组合 (Combination):** 从n个不同元素中，取出m个元素的所有组合的集合，不考虑元素的顺序。
- **排列 (Permutation):** 从n个不同元素中，取出m个元素进行排列，需要考虑元素的顺序。
- **幂集 (Power Set):** 一个集合的所有子集所组成的集合。
- **used数组:** 在排列等回溯问题中，用于标记一个元素在当前路径中是否已被使用，以避免重复选择。
- **深拷贝 (Deep Copy):** 在将路径`path`加入结果集`result`时，需要创建一个`path`的完整独立副本，而不是仅仅复制引用。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（三大模型练习）**  
1.  LC 78. Subsets ⭐⭐ —— （回顾）子集问题的标准模板题。
2.  LC 77. Combinations ⭐⭐ —— （回顾）组合问题的标准模板题。
3.  LC 46. Permutations ⭐⭐ —— （回顾）全排列问题的标准模板题。

**进阶巩固（处理重复元素）**  
4.  LC 90. Subsets II ⭐⭐ —— 输入数组含重复元素，要求子集不能重复。需要在排序后，增加剪枝逻辑来“去重”。
5.  LC 40. Combination Sum II ⭐⭐ —— （回顾）组合总和问题，输入数组含重复元素，要求结果不重复。
6.  LC 47. Permutations II ⭐⭐ —— 全排列问题，输入数组含重复元素。同样需要排序和剪枝来避免产生重复的排列。

**综合应用**
7.  LC 17. Letter Combinations of a Phone Number ⭐⭐ —— 电话号码的字母组合。一个经典的回溯问题，通过一个Map建立数字到字母的映射，然后对输入的数字字符串进行回溯，构建所有可能的字母组合。
8.  LC 216. Combination Sum III ⭐⭐ —— 寻找k个不同的数，使得它们的和为n，数的范围是1-9。是组合问题和组合总和问题的结合体。
