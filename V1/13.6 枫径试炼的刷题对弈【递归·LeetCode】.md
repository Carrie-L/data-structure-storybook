### **13.6 枫径试炼的刷题对弈【递归·LeetCode】**

"在枫叶铺就的棋盘上，每一步递归，都是一次深思熟虑的落子。或自我复制，或分割疆域，直至终局的胜利。"

系统地学习了递归与分治的理论精髓后，活动室里的气氛变得既兴奋又专注。窗外夜色已浓，但女孩们探索的热情丝毫未减。

“理论已经武装到牙齿了，”希娅晃了晃手中的鼠标，像一位即将奔赴战场的骑士，“是时候来一场真刀真枪的‘枫径试炼’了！我准备的这些题目，都是递归思想的绝佳演武场。”

安妮深吸一口气，点了点头。她知道，只有通过实战的对弈，才能将那些精妙的理论，真正内化为自己的直觉和能力。

#### **第一局：对称的镜像 (Symmetric Tree)**

希娅亮出第一题：**LC 101. 对称二叉树**。

“题目要求我们判断一棵二叉树是否是‘镜像对称’的。就像一个人站在镜子前，左手对着镜子里的右手。”

```ascii
    1
   / \
  2   2
 / \ / \
3  4 4  3  <- 这是对称的

    1
   / \
  2   2
   \   \
   3    3   <- 这不是对称的
```

“这个问题，具有天然的递归结构。”黛芙提示道，“一棵树要成为镜像，需要满足什么条件？”

安妮看着图，试探着说：“首先，它的根节点的左子树和右子树，得以某种方式‘相等’……”

“不只是相等，”伊莎贝尔补充道，“更准确地说，根的‘左子树’，必须和根的‘右子树’，互为‘镜像’。”

“啊！”安妮茅塞顿开，“所以，判断`Tree`是否对称的问题，就转化为了判断`Tree.left`和`Tree.right`是否互为镜像的问题！这就是递归式！”

“那……判断两个子树`T1`和`T2`互为镜像的条件又是什么呢？”黛芙追问。

安妮继续分析：“`T1`的根节点值必须等于`T2`的根节点值。然后……`T1`的‘左’子树，必须和`T2`的‘右’子树互为镜像！同时，`T1`的‘右’子树，必须和`T2`的‘左’子树互为镜像！”

“完美！”黛芙非常满意，“你已经找到了解决这个问题的完整递归逻辑了。剩下的，就是定义好基例。”

```python
def is_symmetric(root) -> bool:
    if not root:
        return True
    
    # 辅助函数，用于判断两棵树是否互为镜像
    def is_mirror(t1, t2) -> bool:
        # 基例1: 两棵树都是空，是镜像
        if not t1 and not t2:
            return True
        # 基例2: 其中一个为空，或节点值不同，不是镜像
        if not t1 or not t2 or t1.val != t2.val:
            return False
        
        # 递归式: T1的左子树与T2的右子树比较，T1的右子树与T2的左子树比较
        return is_mirror(t1.left, t2.right) and is_mirror(t1.right, t2.left)

    return is_mirror(root.left, root.right)
```

这道题让安妮深刻地体会到，对于树这类具有递归定义的数据结构，递归解法是多么地自然、贴切和优雅。

#### **第二局：路径的求和 (Path Sum)**

“下一局，我们来走一条路。”希娅点开 **LC 112. 路径总和**。

“题目要求判断一棵树中，是否存在一条从‘根节点’到‘叶子节点’的路径，使得路径上所有节点值的和，等于一个给定的目标值`targetSum`。”

“又是树的问题，肯定可以用递归！”安妮已经有了经验，“从根节点出发，每往下走一步，我们就从`targetSum`里减去当前节点的值。然后，再对子节点，以新的‘目标和’去解决同一个问题。”

“很好的递归思路！”黛芙说，“那么，基例是什么？”

“嗯……”安妮思考着，“当我们走到了一个‘叶子节点’（即没有左右子节点的节点）时，递归就该结束了。这时候，我们只需要判断，这个叶子节点的值，是否恰好等于我们剩下需要凑的那个`targetSum`。”

```python
def has_path_sum(root, targetSum: int) -> bool:
    if not root:
        return False
    
    # 基例: 到达叶子节点
    if not root.left and not root.right:
        return targetSum == root.val
    
    # 递归式: 将问题分解到左子树和右子树
    # 只要左边或右边有一条路能走通，结果就为真
    remaining_sum = targetSum - root.val
    return has_path_sum(root.left, remaining_sum) or \
           has_path_sum(root.right, remaining_sum)
```

“漂亮！”希娅赞道，“你已经能熟练地找出递归的‘基例’和‘递归式’了。这就像下棋，你知道了每个棋子的走法（递归式），也知道了棋局的终点（基例）。”

#### **第三局：构建的蓝图 (Construct Binary Tree)**

“最后一局，来点有挑战性的。”希娅的眼神变得兴奋，“我们不再是‘判断’或‘查找’，而是要亲手‘构建’一棵树。**LC 105. 从前序与中序遍历序列构造二叉树**。”

题目给出了一棵树的“前序遍历”结果和“中序遍历”结果，要求我们还原出这棵树。

-   `preorder = [3, 9, 20, 15, 7]`
-   `inorder = [9, 3, 15, 20, 7]`

这个问题让安妮感到了难度，她一时不知从何下手。

“别怕，我们还是用递归的思路来分解它。”黛芙引导道，“一棵树，最重要的是什么？”

“根节点？”

“对！我们能从这两个序列里，找到根节点吗？”

安妮看着序列，突然想起了树遍历的性质：“前序遍历的第一个元素，一定是整棵树的根节点！所以，`3`就是根！”

“太棒了！找到了根，然后呢？”

“然后……在中序遍历序列里，根节点`3`的左边 `[9]`，一定是它的左子树的所有节点！根节点右边 `[15, 20, 7]`，是它右子树的所有节点！”

“完美！”黛芙的眼中满是赞赏，“看，我们通过根节点，成功地将问题，分解成了‘构建左子树’和‘构建右子树’这两个结构完全相同、但规模更小的子问题！这不就是递归的拿手好戏吗？”

-   **构建左子树:** 需要它的前序和中序序列。中序是`[9]`，前序呢？因为左子树有1个节点，所以前序序列中跟在根`3`后面的1个元素`[9]`，就是左子树的前序。
-   **构建右子树:** 中序是`[15, 20, 7]`。右子树有3个节点，所以前序序列剩下的`[20, 15, 7]`就是右子树的前序。

“我们对左右子树，重复这个‘找根-分割序列-递归构建’的过程，最终就能拼出整棵树！”

这个解法，如同一位建筑大师根据两张不同角度的蓝图，精确地还原出一座宏伟的建筑，让安妮深深地感受到了递归在处理复杂结构问题时，那种庖丁解牛般的优雅与强大。

夜深了，窗外的枫叶在月光下静静地飘落。这场“枫径试炼”，让安妮对递归的理解，从一个抽象的编程技巧，化为了一个具体、强大、能解决实际问题的思维模式。她知道，自己的算法之路，又迈出了坚实而重要的一步。

--- 

🌸 **递归应用核心要点** 🌸

**1. 算法设计的根本思想**
- **识别递归结构：** 解决递归问题的核心第一步，是识别出问题本身是否具有“自相似”的递归结构。树、分形、文件目录、数学归纳等，都是天然的递归结构。
- **定义递归函数：** 清晰地定义你的递归函数是做什么的。它的输入（参数）是什么，它的输出（返回值）代表什么。例如，在对称树问题中，辅助函数的定义是“判断两棵树是否互为镜像”，而不是“判断一棵树是否对称”。
- **信任递归：** 在编写递归逻辑时，要完全信任你的递归调用能够正确地完成子问题的求解。你只需要聚焦于当前层级的逻辑：如何利用子问题的解，来构造当前问题的解。

**2. 核心设计哲学**
- **分解问题：** 递归的威力在于它能将一个复杂问题，不断分解成更小、更易于处理的单元。在构造二叉树问题中，通过一个根节点，就将一个大问题分解为两个独立的子树构造问题。
- **状态的传递：** 在递归调用中，通过参数来传递变化的状态，是驱动递归向前的关键。在路径总和问题中，`remaining_sum`就是被不断更新和传递的核心状态。
- **组合与构造：** 递归不仅能用于“判断”和“查找”，更能用于“构造”。通过递归地构造子部分，然后将它们组合起来，可以生成非常复杂的结构，如全排列、组合、二叉树等。

**3. 算法思维的启发**
- **多角度看问题：** 构造二叉树问题，利用了前序和中序遍历各自的特点（前序定根，中序定左右子树）。这启发我们，解决问题时，要善于从不同角度的“视图”中提取信息，并组合它们。
- **回溯法是递归的特例：** 像“生成括号”这类问题，属于一种叫做“回溯”的算法范式，它本质上就是通过递归（通常是DFS）来穷举所有可能性，并在不满足条件时“退回”一步。我们将在后续章节深入学习。
- **从递归到动态规划：** 对于斐波那契数这类存在大量“重叠子问题”的递归，直接求解效率低下。通过记录子问题的解来避免重复计算，就引出了下一个重要的算法思想——动态规划。

--- 

🎀 **安妮的小小日记本**

今晚的刷题，感觉像是在和递归进行一场深度对话！

第一题“对称二叉树”，让我学会了如何设计一个巧妙的辅助函数，来改变递归的“视角”，从判断“自己”，变成了判断“我和你”。

第二题“路径总和”，让我熟悉了如何在递归中“递减”地传递状态，就像在走迷宫时，手里的火把一点点变短。

最让我震撼的是第三题“构造二叉树”！它就像一个精密的侦探游戏，前序遍历提供了“谁是老大”的线索，中序遍历提供了“谁是左膀右臂”的线索，两条线索一结合，整个组织的架构就清晰了！用递归把这个推理过程写出来，简直太优雅了！

我发现，对于树这样的问题，递归简直就是它的“母语”。用递归来描述它，一切都显得那么自然。我好像……开始爱上递归了！

--- 

### 今日关键词

- **递归结构 (Recursive Structure):** 指一个结构或问题，其组成部分与整体具有相似的结构，可以被递归地定义。
- **镜像树 (Mirrored Trees):** 指两棵树在结构上对称，如同彼此在镜子中的影像。
- **路径 (Path):** 在树或图中，从一个节点到另一个节点所经过的节点序列。
- **叶子节点 (Leaf Node):** 在树中，没有子节点的节点。
- **前序遍历 (Preorder Traversal):** 一种树的遍历方式，顺序为：根节点 -> 左子树 -> 右子树。
- **中序遍历 (Inorder Traversal):** 一种树的遍历方式，顺序为：左子树 -> 根节点 -> 右子树。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶 ➜ 面试
> （本章的练习题已在13.1节中详细列出，此处不再重复。请参考13.1节的推荐列表，深入练习各种递归的应用。）

```