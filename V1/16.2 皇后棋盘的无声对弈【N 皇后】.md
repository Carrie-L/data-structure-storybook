### **16.2 皇后棋盘的无声对弈【N 皇后】**

*"在纵横交错的棋盘上，每一位皇后都孤傲而强大。她们彼此牵制，却又寻求共存的可能。这，是一场关于位置与约束的无声对弈。"*

在理解了回溯算法“深度优先+剪枝+状态恢复”的核心思想后，黛芙决定，用一个极具代表性的经典问题，来让大家真正上手实践这种“在约束中求解”的艺术。

她没有用电脑，而是从储物柜里，拿出了一张国际象棋的棋盘和几个皇后的棋子，一股沉静的、属于智力游戏的氛围瞬间弥漫开来。

“今天我们的试炼场，就是这张棋盘。”黛芙说，“我们要解决的是著名的‘**N皇后问题**’。”

“问题是这样的：在一个 N×N 的棋盘上，我们要放置 N 个皇后，要求是任何两个皇后都不能处于同一行、同一列或同一条斜线上。我们需要找出所有可能的摆放方案。”

希娅拿起一个皇后棋子，放在棋盘上。“皇后的走法是横、竖、斜都可以，所以它的攻击范围非常广。要让N个皇后在棋盘上‘和平共处’，确实很困难。”

#### **回溯法的应用**

“这个问题，暴力穷举所有位置的组合，数量会极其巨大。”黛芙说，“但它完美地符合了回溯算法的应用场景。”

“我们来套用一下回溯的模板，以 N=4 为例。”

1.  **选择路径与选择列表：**
    -   “我们可以一行一行地来放置皇后。`path`可以记录每一行皇后的列位置。比如`path = [1, 3, 0, 2]`就代表第一行的皇后在第1列，第二行的在第3列……”
    -   “我们的‘选择列表’，就是在当前行，我们可以选择将皇后放在哪一‘列’。”

2.  **递归函数定义：**
    -   `backtrack(row, current_board)`: 尝试在第`row`行放置一个皇后。

3.  **结束条件：**
    -   “当`row == N`时，说明我们已经成功地在所有N行都放下了皇后，这就找到了一个解。”安妮抢答道。

4.  **剪枝（约束检测）：**
    -   “这正是N皇后问题的核心！”黛芙强调，“当我们在第`row`行，尝试将皇后放在第`col`列时，我们必须检查，这个位置是否会被之前已经放置的皇后（在`0`到`row-1`行）攻击到？”
    -   **检查列：** 之前的皇后有没有已经占了`col`这一列的？
    -   **检查斜线：** 这是最难的部分。如何判断两个皇后`(r1, c1)`和`(r2, c2)`在同一条斜线上？
        -   “主对角线（左上到右下）：行号和列号的‘差’相等，即 `r1 - c1 == r2 - c2`。”
        -   “副对角线（右上到左下）：行号和列号的‘和’相等，即 `r1 + c1 == r2 + c2`。”

#### **状态的记录与剪枝的实现**

“为了高效地进行剪枝，我们不需要每次都遍历整个棋盘。”黛芙说，“我们可以用几个辅助的集合（或布尔数组）来‘记录’哪些位置已经被占用了。”

-   `cols`: 一个集合，记录哪些**列**已经被占用。
-   `diag1`: 一个集合，记录哪些**主对角线**已经被占用（用 `row - col` 来标识）。
-   `diag2`: 一个集合，记录哪些**副对-角线**已经被占用（用 `row + col` 来标识）。

“这样，我们在尝试一个新位置`(row, col)`时，只需要O(1)的时间，就能检查它是否合法！”

#### **代码实现：优雅的棋局**

```python
def solve_n_queens(n: int) -> list[list[str]]:
    result = []
    # 用一维数组表示棋盘，board[row] = col
    board = [-1] * n
    
    # 辅助集合用于剪枝
    cols = set()
    diag1 = set()
    diag2 = set()
    
    def backtrack(row: int):
        # 结束条件
        if row == n:
            # 构建输出格式并添加到结果中
            solution = []
            for c in board:
                solution.append("." * c + "Q" + "." * (n - c - 1))
            result.append(solution)
            return

        # 遍历当前行的所有列
        for col in range(n):
            # 剪枝：检查冲突
            if col in cols or (row - col) in diag1 or (row + col) in diag2:
                continue
            
            # 做出选择
            board[row] = col
            cols.add(col)
            diag1.add(row - col)
            diag2.add(row + col)
            
            # 进入下一行
            backtrack(row + 1)
            
            # 撤销选择 (回溯)
            cols.remove(col)
            diag1.remove(row - col)
            diag2.remove(row + col)
            # board[row] = -1 (这步可以省略，因为下一轮循环会覆盖)

    backtrack(0)
    return result
```

女孩们围在白板前，看着这段优雅的代码。安妮感觉，这已经不仅仅是代码了，它就像一位冷静而理智的棋手，在进行一场无声的推演。它在棋盘上落下（做出选择），检查局势（剪枝），如果发现是步坏棋，它会毫不犹豫地拿起棋子（撤销选择），回到上一步，去尝试其他的可能，不带一丝情感，直到找出所有能“将死”这个问题的方案。

“回溯算法，真的是解决这类‘组合搜索’和‘约束满足’问题的终极武器。”伊莎贝尔看着窗外的星空，轻声感叹，“它让我们有能力，去系统地探索一个看似无穷的、由选择构成的宇宙。”

---

🌸 **回溯算法核心要点** 🌸

**1. 算法设计的根本思想**
- **约束下的搜索：** N皇后问题的本质，是在一个巨大的搜索空间中，寻找所有满足特定约束条件的解。回溯算法通过“剪枝”操作，将约束条件融入搜索过程，极大地减少了实际需要探索的状态数量。
- **状态的表示：** 如何高效地表示和检查“状态”是回溯算法性能的关键。N皇后问题中，用三个集合来记录列和对角线的占用情况，将O(N)的冲突检查优化到了O(1)，是该解法的精髓所在。
- **解的构建：** 回溯算法是一个“构建解”的过程。它通过递归，一步步地向一个部分解中添加元素，直到形成一个完整的、符合条件的解。

**2. 核心设计哲学**
- **“行”与“列”的智慧：** 通过“按行放置”的策略，我们天然地避免了“行冲突”，使得每一行只需要考虑“列冲突”和“斜线冲突”。这种通过固定一个维度来简化问题的方式，是解决二维矩阵类问题时的常用技巧。
- **空间换时间：** 使用`cols`, `diag1`, `diag2`这三个辅助集合，是典型的空间换时间。我们用O(N)的额外空间，换取了每次决策时O(1)的判断效率。
- **对称性与优雅：** N皇后问题的解法，充满了逻辑的对称性与数学的优雅。对角线的判断`row-col`和`row+col`，以及回溯时“选择”与“撤销”的成对操作，都体现了算法设计中的结构之美。

**3. 算法思维的启发**
- **将约束转化为代码：** 学习N皇后问题，让我们学会如何将抽象的“约束条件”（不在同一行/列/斜线），精确地转化为计算机可以理解和执行的“代码逻辑”（如检查集合中是否存在某个值）。
- **可视化思考：** 面对N皇后、数独这类棋盘问题，在脑中或纸上进行可视化推演，是理清思路、找到状态表示和剪枝方法的有效途径。
- **回溯是“万能钥匙”：** 对于许多没有明显多项式时间解法（如DP或贪心）的搜索和组合问题，回溯提供了一种“最后的、可靠的”解决方案。它虽然可能是暴力的，但却是系统的、完备的。

---

🎀 **安妮的小小日记本**

N皇后问题，听起来就很高贵冷艳！

一开始我真的被“不能在同一行、同一列、同一斜线”这个规则搞晕了，感觉要判断的东西好多。但是，当黛芙学姐把“按行放置”的策略和那三个神奇的“占用集合”拿出来之后，整个问题瞬间就清晰了！

原来，我们可以通过聪明的“记账”，让每次的判断都变得超级简单。`cols`集合记录哪条竖路被占了，`diag1`和`diag2`则像是两条交叉的、记录斜向道路占用情况的“结界”。任何一个新皇后想落下，都得先问问这三个“账本”同不同意。

写回溯代码的感觉，真的就像在下一步很长的棋。每一步落子（做出选择），都可能影响全局。而最关键的，是你要随时准备好“悔棋”（撤销选择），回到过去，去弥补一个错误的决策。这不仅需要智慧，更需要勇气！

---

### 今日关键词

- **N皇后问题 (N-Queens Problem):** 一个经典的组合数学问题，要求在N×N的棋盘上放置N个皇后，使得它们互不攻击。
- **组合搜索 (Combinatorial Search):** 在一个离散的、有限的解空间中，寻找满足特定条件的解或最优解的问题。
- **约束满足问题 (CSP - Constraint Satisfaction Problem):** （回顾）由一组变量和一组约束条件组成，目标是找到满足所有约束的变量赋值。
- **冲突检测 (Conflict Detection):** 在N皇后问题中，指检查在某个位置放置皇后，是否会与已放置的皇后产生攻击。这是“剪枝”的具体实现。
- **对角线标识:** 通过 `row - col` 的值来唯一标识一条主对角线，通过 `row + col` 的值来唯一标识一条副对角线，是处理棋盘斜线问题的常用技巧。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（经典模型练习）**  
1.  LC 51. N-Queens ⭐⭐⭐ —— N皇后问题的标准模板题，要求输出所有解决方案。是练习回溯、状态表示和剪枝的必做题。
2.  LC 52. N-Queens II ⭐⭐⭐ —— 上一题的简化版，只要求输出解决方案的总数，而不需要输出具体的棋盘。可以让你更专注于回溯算法的计数逻辑。

**进阶巩固（棋盘与搜索）**  
3.  LC 37. Sudoku Solver ⭐⭐⭐ —— 解数独。另一个经典的回溯应用。在`9x9`的格子上，对每个空格子，尝试填入`1-9`的数字，并通过检查行、列、九宫格的约束来进行剪枝。其回溯框架与N皇后非常相似。
4.  LC 79. Word Search ⭐⭐ —— 单词搜索。在二维字符网格中，寻找一个给定的单词。从每个格子出发，进行深度优先搜索，并用回溯来标记和取消访问状态，是二维平面回溯的入门好题。
5.  LC 22. Generate Parentheses ⭐⭐ —— （回顾）生成有效括号。这个问题也可以看作是在构建一个路径，每一步的选择是放‘(’还是‘)’，剪枝的条件是：1.左括号数量不能超过n；2.右括号数量不能超过左括号数量。
