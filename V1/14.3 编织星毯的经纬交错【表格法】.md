### **14.3 编织星毯的经纬交错【表格法】**

*"我从宇宙的奇点出发，沿着时间的经纬，一针一线，织出整片星空。当最后一颗星辰归位，宏伟的图景便已然呈现。"*

掌握了“记忆化搜索”这把利器后，安妮感觉自己已经能解决很多DP问题了。但她也记得黛芙学姐提过的，记忆化搜索（自顶向下）依然有递归的固有风险——栈溢出。

“那么，有没有一种方法，能完全摆脱递归，既能享受DP的效率，又能获得迭代的安全性呢？”安妮向学姐们请教。

“当然有，”黛芙肯定地回答，“这就是动态规划的第二种，也是更‘标准’的实现方式——‘**表格法**’（Tabulation），也叫‘自底向上’（Bottom-Up）的动态规划。”

伊莎贝尔指着她们露营时铺在地上的、一块织有星空图案的毯子，说：“如果说‘自顶向下’的记忆化，是天文学家为了看清‘仙女座星系’（大问题），而去研究它的组成星系（子问题），并随手记录。那么‘自底向上’的表格法，则更像一位织工。她不是从星系的全貌开始，而是从毯子的一角、第一根线（最小的子问题）开始，一针一线、一行一列地，按照设计图（状态转移方程），最终织出整片星空。”

#### **从“递推”到“迭代”**

“我们还是以‘爬楼梯’为例，”黛芙在白板上写下了它的状态转移方程：`dp[i] = dp[i-1] + dp[i-2]`。

“‘自顶向下’的思路是：想求`dp[n]`，我需要`dp[n-1]`和`dp[n-2]`，于是我去递归调用它们。”

“而‘自底向上’的思路则完全相反，”黛芙的语气充满了力量，“它说：我知道`dp[1]`和`dp[2]`（基例）。利用它们，我就可以算出`dp[3]`。有了`dp[3]`，我就可以算出`dp[4]`……以此类推，我像上楼梯一样，一步一步，扎扎实实地，直到计算出我最终想要的`dp[n]`。”

“这不就是一个简单的`for`循环吗！”希娅一针见血地指出。

“完全正确！”黛芙笑道，“自底向上的DP，其本质就是用循环，来代替递归的‘递推’过程。”

**表格法 (Bottom-Up DP) 实现爬楼梯:**
```python
def climb_stairs_tabulation(n: int) -> int:
    if n <= 2:
        return n
    
    # 1. 创建DP表 (dp_table)，大小为 n+1
    dp = [0] * (n + 1)
    
    # 2. 初始化基例 (Base Cases)
    dp[1] = 1
    dp[2] = 2
    
    # 3. 循环迭代，按照状态转移方程填表
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
        
    # 4. 返回最终答案
    return dp[n]
```

“看，这里没有任何递归调用。我们创建了一个‘DP表’（通常就是一个数组或矩阵），先填好初始值，然后用一个循环，按照固定的顺序，把表格的每一格都计算并填充完整。最后，我们需要的答案，就在表格的某一格里。”

#### **自顶向下 vs. 自底向上**

“这两种方法，到底哪个更好呢？”安妮问出了大家最关心的问题。

黛芙在白板上画出了清晰的对比图：

```ascii
动态规划两种实现方式对比

+------------------------+--------------------------------+--------------------------------+
|          特性          |    记忆化搜索 (Top-Down)     |        表格法 (Bottom-Up)        |
+========================+================================+================================+
|        思考方式        |   从大问题 -> 小问题 (递归)    |   从小问题 -> 大问题 (迭代)    |
+------------------------+--------------------------------+--------------------------------+
|        代码结构        |           递归函数 + 备忘录          |           循环 + DP表            |
+------------------------+--------------------------------+--------------------------------+
|        执行过程        |    按需计算，可能跳过某些状态    |    计算所有状态，填满整个DP表    |
+------------------------+--------------------------------+--------------------------------+
|        优点          |  直观，代码接近问题定义，易于思考  |   无递归开销，无栈溢出风险，效率高   |
+------------------------+--------------------------------+--------------------------------+
|        缺点          |   有递归开销和栈溢出风险     |  可能计算了不需要的状态，代码稍不直观  |
+------------------------+--------------------------------+--------------------------------+
```

“在爬楼梯这个问题里，因为`dp[n]`的计算依赖于所有小于`n`的子问题，所以两种方法计算的子问题数量是一样的。”黛芙解释道，“但在某些问题中，最终解可能只依赖于一部分子问题。这时，自顶向下的记忆化就可能因为‘按需计算’而更快。不过，在绝大多数情况下，自底向শনের表格法因为没有递归的额外开销，通常被认为是更优的、更‘专业’的实现。”

#### **空间优化：滚动的星辰**

“对于爬楼梯这个问题，表格法还有优化的空间吗？”伊莎贝尔微笑着提示。

安妮盯着状态转移方程`dp[i] = dp[i-1] + dp[i-2]`，突然灵光一闪：“我发现了！计算`dp[i]`，其实只需要用到它前面‘两个’状态`dp[i-1]`和`dp[i-2]`的值！更早的那些，比如`dp[i-3]`，就再也用不到了！”

“正是如此！”黛芙赞道，“所以，我们根本不需要一个大小为N的DP表来存储所有历史记录。我们只需要两个变量，来记录那‘滚滚向前’的最后两个状态就行了！”

```python
# 空间优化后的版本
def climb_stairs_optimized(n: int) -> int:
    if n <= 2:
        return n
    
    # 只用两个变量来记录前两个状态
    prev1, prev2 = 2, 1 # 分别代表 dp[i-1] 和 dp[i-2]
    
    for i in range(3, n + 1):
        current = prev1 + prev2 # 计算 dp[i]
        # 更新状态，向前滚动
        prev2 = prev1
        prev1 = current
        
    return prev1
```

“通过这种‘滚动数组’或状态压缩的技巧，我们把空间复杂度从O(N)优化到了O(1)！”

夜空中，星辰在既定的轨道上运行，过去的位置决定了现在，现在的位置预示着未来，周而复始，从不重复。安妮看着这番景象，感觉动态规划的自底向上思想，与这宇宙的运行法则，竟有着惊人的相似。它从最简单的初始状态出发，遵循着不变的转移规律，一步步地，构建出整个复杂而有序的世界。

---

🌸 **动态规划核心要点** 🌸

**1. 算法设计的根本思想**
- **迭代构建：** 自底向上DP的核心，是用迭代（循环）的方式，从最小的、已知的子问题（基例）出发，逐步构建出更大问题的解。
- **状态的有序性：** 表格法的实现，依赖于一个清晰的“计算顺序”。必须保证在计算一个状态`dp[i]`时，它所依赖的所有子问题状态（如`dp[i-1]`）都已经计算完毕。这个顺序，通常就是循环的顺序。
- **消除递归：** 自底向上方法，通过将递归的“递推”关系，直接转化为循环的“迭代”关系，从根本上消除了函数调用和栈溢出的问题。

**2. 核心设计哲学**
- **效率与工程化：** 在性能方面，表格法通常是DP问题的首选。它更接近机器的执行方式，没有额外开销，行为确定，易于分析和优化（如空间优化）。
- **完备性与冗余：** 表格法会计算并填充所有可能的状态，形成一个完备的解空间。这在某些情况下可能导致计算了最终答案并不需要的“冗余”状态，但在大多数问题中，这种完备性保证了逻辑的简单和健壮。
- **空间优化（状态压缩）：** “滚动数组”是一种重要的DP优化技巧。通过分析状态转移方程，如果发现当前状态只依赖于前有限个（如1个或2个）状态，就可以用有限的变量来代替整个DP数组，从而极大地降低空间复杂度。

**3. 算法思维的启发**
- **从“我需要谁”到“我能算谁”：** 记忆化搜索的思维是“为了算`dp[n]`，我需要谁？”。而表格法的思维是“根据已有的，我能算出谁？”。这种思维的转变，是从“需求驱动”到“能力驱动”的转变，有助于我们写出更高效的迭代式代码。
- **寻找依赖关系：** 在思考DP问题时，画出状态之间的“依赖图”，可以帮助我们清晰地看到计算的顺序，并发现空间优化的可能性。
- **DP的两种范式：** 掌握自顶向下和自底向上两种范式，并能根据问题的特点和个人偏好灵活切换，是DP能力成熟的标志。通常可以先用自顶向下的方式理清递归关系，再将其翻译成更高效的自底向上版本。

---

🎀 **安妮的小小日记本**

如果说昨天的“记忆化搜索”是给递归打上了聪明的补丁，那今天学的“表格法”，就是直接造了一台全新的、高效的机器！

我太喜欢这种“自底向上”的感觉了！它就像玩乐高，从最小的一块块积木（基例）开始，按照图纸（状态转移方程），一层一层地往上搭，心里特别踏实。因为我知道，我每搭好的一层，都是后面更高楼层的坚实基础。它不会像递归那样，先搭一个空中楼阁，再回头去补下面的柱子。

而且，“滚动数组”的优化技巧也太神了！就像织毛衣，织完一行之后，旧的那几排针就可以拆掉了，完全不用从头到尾都留着。只需要记住最后那一两行，就能继续往下织。用两个小变量，就代替了一整个大数组，简直是四两拨千斤！

感觉DP的世界，真的充满了智慧和美感！

---

### 今日关键词

- **表格法 (Tabulation):** 动态规划的一种实现方式，也称自底向上DP。它通过创建一个DP表（数组或矩阵），并按一定顺序迭代地填充该表，来求解问题。
- **自底向上DP (Bottom-Up DP):** 与表格法同义。指从最小的子问题开始，逐步解决，直到求出原问题的解。
- **DP表 (DP Table):** 用于存储所有子问题解的数组或矩阵。
- **状态压缩 / 滚动数组 (Space Optimization / Rolling Array):** 一种DP优化技巧。当计算当前状态只需要前几个状态时，可以用少量变量来代替整个DP表，从而降低空间复杂度。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（练习从Top-Down到Bottom-Up）**  
1.  **表格法改写** ⭐ —— 将上一节练习中的“爬楼梯”、“打家劫舍”等问题的记忆化搜索解法，用本节学习的表格法（自底向上）重新实现一遍。体会两种写法的异同。
2.  **空间优化练习** ⭐⭐ —— 对你改写的“爬楼梯”和“打家劫舍”的表格法，进行空间优化，将O(N)的空间复杂度降为O(1)。
3.  LC 62. Unique Paths ⭐⭐ —— 一个机器人从左上角走到右下角有多少种路径。经典的二维DP入门题。`dp[i][j]`的定义是“走到格子(i,j)的路径数”，状态转移方程为`dp[i][j] = dp[i-1][j] + dp[i][j-1]`。

**进阶巩固（二维DP与状态设计）**  
4.  LC 63. Unique Paths II ⭐⭐ —— 上一题的变种，加入了障碍物。只需要在状态转移时，判断当前格子是否为障碍物即可，是练习DP模型微调的好例子。
5.  LC 64. Minimum Path Sum ⭐⭐ —— 路径总和的变种，要求找到路径的最小数字和。状态转移方程变为`dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`，练习将“求和”变为“求最值”。
