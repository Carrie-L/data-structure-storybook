### **11.7 彩绘谷仓的分类魔法【计数/桶/基数】**

*"不经比较，何以排序？当数据的内在属性化为可度量的坐标，秩序便如魔法般自然显现。"*

学习了堆排序之后，安妮对主流的、基于“比较”的排序算法有了一个全面的认识。从O(N²)的朴素三杰，到O(N logN)的三大高手，它们都依赖于元素之间的两两比较来确定顺序。

“学姐，”安妮在一个阳光正好的下午，向黛芙提出了一个深刻的问题，“是不是所有的排序算法，都必须通过‘比较’来进行呢？有没有可能，不一个一个地比，也能把它们排好序？”

黛芙的眼中闪过一丝赞许：“问得非常好，安妮。你触及了排序算法理论的一个核心边界。基于比较的排序算法，其最优的时间复杂度已经被证明不可能超越O(N logN)。但是，如果我们打破‘比较’这个限制，利用数据本身的一些特殊属性，就可能实现更快的排序，甚至达到线性的O(N)时间复杂度。”

“O(N)？那不是和遍历一遍数组一样快吗？”希娅也凑了过来，表示惊讶。

“是的，”伊莎贝尔接过话头，指向窗外远处农学院的试验田，“想象一下，秋收时节，农夫们收获了一大堆谷物，有玉米、小麦、大豆。如果他们想把这些谷物分开，是把它们一颗一颗拿起来互相比较‘你是不是玉米’吗？”

“当然不是，”安妮笑道，“他们会直接准备好几个大谷仓，分别贴上‘玉米’、‘小麦’、‘大豆’的标签，然后把谷物一把一把地扔进对应的谷仓里。最后再按顺序把谷仓里的谷物倒出来就行了。”

“完全正确！”伊莎贝尔说，“这种‘按类入仓’的思想，就是我们今天要学习的线性时间排序魔法——‘桶排序’和‘计数排序’的精髓。”

#### **计数排序：按号入座的魔法**

“我们先从最简单、但限制也最严格的‘计数排序’开始，”黛芙说，“它适用于一个非常特殊的场景：待排序的数据是分布在有限范围内的整数。比如，我们全校同学的期末考试成绩，范围是0到100分。”

她设定了一个场景：`[ 95, 92, 95, 98, 91, 92 ]` 是一些同学的成绩。

“计数排序的步骤，就像发答题卡一样精确：”

1.  **创建计数桶 (Counting Buckets):** 找出成绩的范围（91-98）。然后创建一个“计数数组”`counts`，其大小为 `max - min + 1`。每个“桶”对应一个分数。
    `counts` 数组，索引从91到98，初始值都为0。

2.  **计数 (Counting):** 遍历原始成绩数组。每遇到一个分数，就在`counts`数组中对应分数的“桶”里，把计数值加一。
    - 遇到 95, `counts[95]` 变成 1。
    - 遇到 92, `counts[92]` 变成 1。
    - 又遇到 95, `counts[95]` 变成 2。
    - ...
    遍历结束后: `counts` -> `[91:1, 92:2, 95:2, 98:1]` (其余为0)

3.  **输出 (Output):** 遍历`counts`数组。根据每个桶里的计数值，把对应分数依次写回原数组。
    - `counts[91]`是1，写入一个 91。
    - `counts[92]`是2，写入两个 92。
    - ...
    最终结果: `[ 91, 92, 92, 95, 95, 98 ]`

“看，”黛芙总结道，“全程没有任何元素之间的比较。我们只是利用了整数的数值本身作为‘桶’的地址，通过计数和输出，就完成了排序。”

```python
def counting_sort(arr: list):
    if not arr:
        return []
    
    # 找到范围
    min_val, max_val = min(arr), max(arr)
    
    # 创建计数桶
    counts = [0] * (max_val - min_val + 1)
    
    # 计数
    for x in arr:
        counts[x - min_val] += 1
        
    # 输出
    sorted_arr = []
    for i, count in enumerate(counts):
        sorted_arr.extend([i + min_val] * count)
        
    return sorted_arr
```

#### **桶排序：分而治之的升级**

“计数排序很厉害，但它要求数据是整数，而且范围不能太大，否则‘桶’会多到放不下。”希娅指出了问题，“那如果数据范围很大，或者是小数呢？比如 `[ 0.8, 0.1, 0.45, 0.23, 0.9, 0.05 ]`？”

“这时候，就需要‘桶排序’登场了，”黛芙说，“桶排序是计数排序思想的升级版。它不再是‘一个萝卜一个坑’，而是‘一片区域一个桶’。”

1.  **创建桶 (Create Buckets):** 根据数据范围，创建一定数量的空桶。比如，我们可以创建10个桶，分别代表 `[0, 0.1)`, `[0.1, 0.2)`, ..., `[0.9, 1.0)`。

2.  **入桶 (Distribution):** 遍历原始数组，根据每个元素的值，把它放进对应的桶里。
    - 0.8 -> 桶8
    - 0.1 -> 桶1
    - 0.45 -> 桶4
    - 0.23 -> 桶2
    - 0.9 -> 桶9
    - 0.05 -> 桶0
    入桶后: `buckets` -> `[ [0.05], [0.1], [0.23], [], [0.45], ..., [0.8], [0.9] ]`

3.  **桶内排序 (Sort Buckets):** 对每个非空的桶，单独进行排序。因为桶内元素通常很少，所以可以使用一个简单高效的排序算法，比如**插入排序**。
    (在这个例子中，每个桶只有一个元素，所以无需排序)

4.  **合并 (Concatenate):** 按顺序将所有桶里的元素拼接起来，就得到了最终的有序序列。

“桶排序体现了‘分而治之’的思想，”黛芙总结，“它先把一个大范围的排序问题，分解成了若干个小范围的、更容易解决的桶内排序问题。”

#### **基数排序：多关键字的智慧**

“还有一种更神奇的，叫‘基数排序’，”伊莎贝尔引导道，“如果我们要给一大堆图书馆的图书卡排序，卡号是`[170, 045, 075, 090, 002, 024, 802, 660]`，怎么办？”

“这些数字范围很大，用计数排序不合适。用桶排序，分布又不均匀。”安妮分析道。

“基数排序提供了一个绝妙的思路：我们不一次性看整个数字，而是按‘位’来排。就像我们手工整理卡片一样，先按个位数排，再按十位数排，最后按百位数排。”

1.  **按个位数排序 (LSD - Least Significant Digit):**
    - `[170, 090, 660], [002, 802], [024], [045, 075]` (根据个位 0, 2, 4, 5 分组)
    - 收集: `[170, 090, 660, 002, 802, 024, 045, 075]`

2.  **按十位数排序:** (在上一步结果的基础上)
    - `[002, 802], [024], [045], [660], [170, 075], [090]` (根据十位 0, 2, 4, 6, 7, 9 分组)
    - 收集: `[002, 802, 024, 045, 660, 170, 075, 090]`

3.  **按百位数排序:** (在上一步结果的基础上)
    - `[002, 024, 045, 075, 090], [170], [660], [802]` (根据百位 0, 1, 6, 8 分组)
    - 收集: `[002, 024, 045, 075, 090, 170, 660, 802]`

“排序完成了！”安妮惊叹道，“太神奇了！为什么从最低位开始排，最后就能保证整体有序呢？”

“关键在于，我们每一轮按位排序时，使用的必须是‘稳定’的排序算法（比如用计数排序或桶排序来实现）。”黛芙解释道，“这样，在排高位时，才不会打乱由低位保证的相对顺序。例如，排完个位后，`075`在`045`后面。排十位时，虽然`7`比`4`大，但因为我们是稳定排序，所以`075`依然在`045`后面（在各自的桶里）。当排百位时，它们都在`0`桶里，相对顺序得以保留。”

#### **复杂度与适用场景**

```ascii
线性时间排序算法总结：

┌──────────┬──────────┬──────────┬────────────────┐
│   算法     │ 时间复杂度 │ 空间复杂度 │           适用场景           │
├──────────┼──────────┼──────────┼────────────────┤
│ 计数排序   │   O(N+K)   │   O(K)     │ N=数据量, K=数据范围。整数, K不大 │
│ 桶排序     │ O(N) 平均  │   O(N+M)   │ N=数据量, M=桶数量。数据均匀分布 │
│ 基数排序   │  O(D*(N+R))  │  O(N+R)    │ D=位数, R=基数。多关键字, 整数/字符串 │
└──────────┴──────────┴──────────┴────────────────┘
```

“这些非比较排序，就像是为特定数据量身定做的‘魔法’，”黛芙总结道，“它们通过牺牲通用性，换来了在特定场景下无与伦比的线性时间效率。这告诉我们，深入理解数据的内在属性，是通往更优算法的重要途径。”

---

🌸 **排序算法核心要点** 🌸

**1. 算法设计的根本思想**
- **非比较排序：** 这类算法的核心是完全绕开元素间的两两比较，从而突破O(N logN)的理论下界。它们利用了“键”本身的数值信息来作为排序的依据。
- **空间换时间：** 线性时间排序算法是“空间换时间”思想的极致体现。它们通常需要O(N)甚至更大的辅助空间（如计数数组、桶）来记录数据的分布信息。
- **数据驱动：** 算法的设计高度依赖于输入数据的特性，如范围、分布、结构等。这与通用比较排序（如快排、归并）的“普适性”形成鲜明对比。

**2. 核心设计哲学**
- **映射与分配：** 无论是计数排序的“数值->索引”映射，还是桶排序的“范围->桶”映射，其本质都是建立一种从“键”到“存储位置”的直接或间接映射关系，从而避免比较。
- **分治的变体：** 桶排序和基数排序都蕴含着分治思想。桶排序将“大范围排序”分解为“小范围排序”；基数排序将“高维度比较”分解为“多轮低维度比较”。
- **稳定性的基石：** 基数排序的正确性，完全依赖于其内部按位排序时所使用的算法必须是稳定的。这深刻地揭示了“稳定性”这一特性在构建复杂算法中的关键作用。

**3. 算法思维的启发**
- **跳出思维定势：** 当一个问题在现有框架下（如比较排序）遇到瓶颈时，尝试从问题的本质和数据的属性出发，可能会找到全新的、更高维度的解决方案。
- **预处理与信息挖掘：** 线性排序的“计数”和“入桶”阶段，本质上都是对数据进行预处理，挖掘其“分布”信息。这种先分析、再处理的模式在很多高效算法中都有应用。
- **算法的组合：** 桶排序内部需要调用其他排序算法，基数排序内部需要稳定的排序算法。这展示了将不同算法作为“模块”进行组合，以解决更复杂问题的思想。

---

🎀 **安妮的小小日记本**

今天我的认知被刷新了！我一直以为，要排序，就必须得比个高低。但今天学的三种“魔法排序”告诉我，原来还可以“按号入座”！

计数排序就像一个有着无数个小抽屉的柜子，每个抽屉都标着数字，来一个数字就往对应的抽屉里放一个豆子，最后看豆子数就知道怎么排了。桶排序则更像是把这些抽屉合并成几个大区，先分区域，再在区域里整理。而最神奇的是基数排序，像变魔术一样，先按个位排，再按十位排……最后整个顺序就对了！

虽然它们的使用条件很苛刻，但O(N)的效率实在是太惊人了！这让我明白，解决问题不能只有一种思路。有时候，换个角度，利用问题本身的特点，可能会发现一条意想不到的捷径。就像解谜游戏里，不一定要正面破解，也许机关的秘密就藏在谜题的描述里！

---

### 今日关键词

- **非比较排序 (Non-comparison Sort):** 不通过比较元素之间的大小来决定其顺序的排序算法。
- **线性时间排序 (Linear Time Sort):** 指时间复杂度为O(N)的排序算法，其中N是待排序元素的数量。
- **计数排序 (Counting Sort):** 一种非比较排序，通过计算每个不同元素出现的次数，来确定其在输出序列中的位置。
- **桶排序 (Bucket Sort):** 一种非比较排序，它将元素分布到有限数量的桶里，然后对每个桶独立排序。
- **基数排序 (Radix Sort):** 一种非比较排序，它将整数按位数切割成不同的数字，然后按每个位数分别比较排序。
- **最低有效位 (LSD - Least Significant Digit):** 指数字中权重最小的位，通常是个位。LSD基数排序从最低位开始排序。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 3 题）**  
1.  **手动实现计数排序** ⭐ —— 亲手实现计数排序，处理好“范围”与“偏移量”的关系，深刻理解其原理。
2.  LC 75 Sort Colors ⭐⭐ —— 荷兰国旗问题。这个问题是计数排序思想的绝佳体现。因为只有三种颜色（0, 1, 2），我们可以直接计数，然后重写数组，在O(N)时间O(1)空间内完成排序。
3.  LC 1122 Relative Sort Array ⭐ —— 这道题可以完美地用计数排序来解决。由于`arr1`和`arr2`中的元素范围是[0, 1000]，我们可以创建一个大小为1001的计数数组，先按`arr2`的顺序输出，再输出剩余的元素。

**进阶巩固（练习 3 题）**  
4.  **手动实现桶排序** ⭐⭐ —— 亲手实现桶排序，包括创建桶、分布式数据、对桶内数据进行排序（可调用插入排序）以及合并，完整地走一遍流程。
5.  LC 164 Maximum Gap ⭐⭐⭐ —— 这是一道巧妙运用桶排序思想的难题。通过将N个元素放入N-1个桶中，利用鸽巢原理，可以断定最大间距一定不小于某个值，并且最大间距不会出现在同一个桶内，从而将问题转化为计算相邻桶之间的间距。
6.  **手动实现基数排序** ⭐⭐ —— 亲手实现LSD基数排序，内部按位排序时可以调用计数排序。这是理解其稳定性和多轮排序如何协同工作的最好方法。
