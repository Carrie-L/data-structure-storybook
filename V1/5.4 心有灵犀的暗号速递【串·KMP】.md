### **5.4 心有灵犀的暗号速递【串·KMP】**

*"我于自身的重复中，读懂了宿命的轮回。于是，在每一次的失配处，我不再盲目地回头，而是借由那早已预知了的、名为‘next’的暗号，瞬间，跃迁至下一次可能的相遇。"*

在学习了BF算法那如“月下寻影”般、朴素而执着的匹配方式后，安妮对字符串匹配，有了最基本的认识。但她也同样感受到了它的“笨拙”。

“学姐，”在一个阳光正好的午后，安妮指着BF算法的演示图，“当我们在匹配`abcabd`和`abcabc`时，在第6个字符`d`和`c`这里失败了。BF算法会把模式串，整个向右移动一位，然后从头开始比较。但我们明明已经知道了，它前面的`abcab`都是匹配的，这些信息，就这么浪费了吗？”

“你发现了BF算法最大的弱点，也是所有高效字符串匹配算法，试图解决的核心问题——**如何利用好‘已匹配部分’的信息**。”黛芙赞许道，“今天，我们要学习的，就是这个领域里，最负盛名、也最考验逻辑思维的算法——**KMP算法**。”

“KMP，是以它的三位发明者（Knuth, Morris, Pratt）的名字命名的。”伊莎贝尔补充道，“它就像一位能‘心有灵犀’的密码专家。在匹配开始前，它会先对‘模式串’自身，进行一次深入的‘自我分析’，并生成一份神秘的‘**暗号表**’。在匹配时，一旦发生失配，它就能通过查询这份暗号表，得知自己应该‘跳’到哪个位置，从而避免了大量不必要的比较。”

#### **核心：`next`数组的奥秘**

“这份神秘的‘暗号表’，就是KMP算法的灵魂——`**next**`**数组**（也常被称为‘失效函数’或`fail`数组）。”黛芙开始讲解这个算法最核心、也最难理解的部分。

“`next`数组，是为‘**模式串**’量身定做的。`next[i]`的值，代表了在模式串`P`的子串`P[0...i]`中，‘**最长的、相等的、不包含自身的前缀和后缀**’的长度。”

这个定义，让安妮和希娅都感到了困惑。

“别急，我们来分解一下。”伊莎贝尔耐心地解释，“我们来看一个模式串`P = "ababa"`。”

-   **i = 0:** 子串是`"a"`。前缀和后缀都是空集。长度0。`next[0] = 0`。
-   **i = 1:** 子串是`"ab"`。前缀是`{"a"}`，后缀是`{"b"}`。没有相等的。长度0。`next[1] = 0`。
-   **i = 2:** 子串是`"aba"`。前缀`{"a", "ab"}`，后缀`{"a", "ba"}`。最长的相等的是`"a"`。长度1。`next[2] = 1`。
-   **i = 3:** 子串是`"abab"`。前缀`{"a", "ab", "aba"}`，后缀`{"b", "ab", "bab"}`。最长相等的是`"ab"`。长度2。`next[3] = 2`。
-   **i = 4:** 子串是`"ababa"`。前缀`{"a", "ab", "aba", "abab"}`，后缀`{"a", "ba", "aba", "baba"}`。最长相等的是`"aba"`。长度3。`next[4] = 3`。

“所以，对于`"ababa"`，它的`next`数组就是 `[0, 0, 1, 2, 3]`。”

#### **`next`数组的意义：失配后的“瞬移”**

“这个数组，到底有什么用？”希娅追问。

“它的用处，在‘失配’的瞬间，才会显现。”黛芙在白板上，画出了匹配的场景。

```ascii
文本串 T: ... a b a b a c ...
模式串 P:     a b a b a b
                 ↑
              失配点 (j=5)
```

“现在，我们在模式串的第`j=5`个位置（字符`'b'`）发生了失配。此时，我们已经知道，模式串的前`j=5`个字符`"ababa"`，是和文本串成功匹配的。”

“BF算法，会把模式串向右移动一位。但KMP不会！”

“KMP会去查询它的‘暗号表’：`next[j-1]`，也就是`next[4]`，我们刚刚算出来，它的值是`3`。”

“这个`3`，告诉了我们一个惊人的秘密：**在刚刚匹配成功的那段`"ababa"`中，它的前缀`"aba"`（长度为3），和它的后缀`"aba"`，是完全一样的！**”

```ascii
匹配成功的部分: a b a b a
                ---   ---
                前缀   后缀
```

“既然如此，”黛芙的眼中闪着光，“当`P`在`j`处失配时，我们根本不需要从头开始比较。我们只需要，将模式串向右‘滑动’，使得**前一个`"aba"`（前缀），移动到后一个`"aba"`（后缀）的位置**上，然后，从`j`这个位置，继续向后比较就行了！”

```ascii
原对齐:
T: ... a b a b a c ...
P:     a b a b a b

KMP滑动后:
T: ... a b a b a c ...
P:         a b a b a b
           ↑
        (j=3, 从这里继续比较)
```

“看，我们把模式串的指针`j`，从`5`，直接‘瞬移’到了`next[j-1]`的位置，也就是`3`。而文本串的指针，全程没有回退！这就是KMP算法高效的根源！”

#### **`next`数组的构建：自我匹配的递归**

“那这个神奇的`next`数组，本身又是如何高效地构建出来的呢？”安妮问到了最后一个，也是最难的问题。

“构建`next`数组的过程，是KMP算法最精妙的‘**自我匹配**’过程。”黛芙说，“它用模式串`P`，去匹配它自己！”

这个过程，本身就是一个动态规划或递归的思想。当我们要求`next[i]`时，我们会利用已经计算出来的`next[i-1]`的信息。如果`P[i]`与`P[next[i-1]]`相等，那么`next[i] = next[i-1] + 1`。如果不等，则继续向前回溯`next[next[i-1]-1]`……这个过程，与KMP的主匹配过程，如出一辙。

安妮被这精妙的、如同“衔尾蛇”般的逻辑结构，深深地迷住了。KMP算法，它首先深刻地理解了“自己”（构建next数组），然后，才利用这份“自知之明”，去高效地理解“世界”（匹配文本串）。这不仅是算法的智慧，更充满了东方的哲学思辨。

---

🌸 **KMP算法核心要点** 🌸

**1. 算法设计的根本思想**
- **利用已知信息：** KMP算法的核心，是最大化地利用每一次失配前，已经获得的“部分匹配”信息。它通过`next`数组，将这部分信息，转化为下一次匹配的“最佳起始点”。
- **消除指针回溯：** 传统的BF算法，在失配时，文本串的指针需要“回溯”。而KMP算法，通过模式串的“滑动”，保证了文本串的指针，永远只会勇往直前，从不后退。这是其线性时间复杂度的根本保证。
- **模式串的自我匹配：** `next`数组的构建，是模式串“自己匹配自己”的过程。这是一种深刻的内省，算法通过理解自身的“前缀-后缀”结构，来为未来的外部匹配，做好准备。

**2. 核心设计哲学**
- **预处理的价值：** （回顾）KMP是“预处理换取效率”的又一典范。它愿意花费O(M)（M为模式串长度）的时间，去精心构建`next`数组，从而将匹配阶段的时间复杂度，从BF的O(M*N)，一举降低到了O(N)。
- **有限状态自动机（DFA）的视角：** 从更理论化的角度看，KMP的`next`数组，可以被看作是构建一个“有限状态自动机”的过程。这个自动机，能“识别”模式串的所有前缀。匹配过程，就是用文本串，来驱动这个自动机进行状态转移。

**3. 算法思维的启发**
- **“失配”不是失败，是信息：** KMP算法告诉我们，一次“失配”，不是一次简单的失败，它蕴含着宝贵的信息。学会从失败中，提取有用的信息，来指导下一步的行动，是通往高效解法的关键。
- **寻找“对称性”与“周期性”：** `next`数组，本质上是在挖掘模式串内部的“周期性”或“对称性”结构。一个字符串的`next`数组，包含了其所有前缀的“border”信息，这是一个非常深刻的性质，有着广泛的应用。
- **“自我参照”的解法：** `next`数组的构建过程，本身就是一个“KMP”过程。这种“用算法自身来解决其子问题”的递归或递推思想，在算法设计中，时有出现。

---

🎀 **安妮的小小日记本**

KMP算法，绝对是我目前学过的，最“烧脑”的算法，没有之一！

那个`next`数组的定义，真的好绕啊！“最长的、相等的、不包含自身的前缀和后缀”……我感觉我的大脑，就像一个CPU，快要过热了！

但是，当我跟着黛芙学姐，一步步地，看到它如何在失配的瞬间，让模式串“瞬移”到一个不可思议、但又恰到好处的位置时，我真的被震撼了！

它就像一个绝顶的武林高手，在和对手过招时，即使一招被格挡，他也绝不后退半步。他会借着对方格挡的力量，顺势变招，从一个更刁钻、更有效的位置，发起下一次攻击！而文本串的指针，就像是被他牢牢保护在身后的“要害”，永远不会暴露在回溯的危险之中。

虽然我现在，对`next`数组的构建，还是一知半解。但我知道，这座高山，我一定要翻过去！因为山顶的风景，实在是太美了！

---

### 今日关键词

- **KMP算法:** 一种高效的字符串匹配算法，它通过预处理模式串，来避免匹配过程中的指针回溯，从而达到O(N+M)的线性时间复杂度。
- **`next`数组 / 失效函数 (Failure Function):** KMP算法的核心。`next[i]`存储了模式串`P[0...i]`的“最长公共前后缀”的长度。
- **前缀 (Prefix):** 字符串从开头开始的、不等于自身的任何子串。
- **后缀 (Suffix):** 字符串到结尾结束的、不等于自身的任何子串。
- **最长公共前后缀 (Longest Proper Prefix which is also Suffix):** `next`数组定义的本质，有时也被称为“border”。
- **指针不回溯:** KMP算法相比于BF算法，最核心的优势。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议：KMP的精髓在于`next`数组的理解和构建，请务必亲手实现。

**练习**  
1.  **手动构建next数组** ⭐⭐ —— 给定一个字符串，如`"ababcabcac"`，请不要看答案，亲手在纸上，一步步地，计算出它的`next`数组。
2.  LC 28. Implement strStr() (KMP版) ⭐⭐⭐ —— （回顾）用KMP算法，来重新实现`strStr()`。你需要完整地实现`build_next`和`kmp_search`两个函数。这是检验你是否掌握KMP的“毕业考试”。
3.  LC 459. Repeated Substring Pattern ⭐⭐ —— （回顾）判断一个字符串是否由其子串重复多次构成。这个问题，可以用`next`数组的性质，巧妙地在O(N)时间内解决。如果一个长度为N的字符串`s`，其`next[N-1]`的值为`L`，并且`N % (N - L) == 0`，那么它就是由重复子串构成的。
4.  LC 1392. Longest Happy Prefix ⭐⭐⭐ —— （回顾）寻找最长快乐前缀。这个问题，就是`next`数组定义的直接应用。答案就是`s`的`next[N-1]`所对应的前缀。
