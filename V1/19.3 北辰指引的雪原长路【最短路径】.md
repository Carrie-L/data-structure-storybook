### **19.3 北辰指引的雪原长路【最短路径】**

*"在茫茫的雪原上，北辰星的光芒恒久不变，指引着旅人穿越风雪。无论道路是平坦还是崎岖，是捷径还是远弯，最短的路径，终将被这束光所揭示。"*

在学习了构造图的“最小骨架”——最小生成树之后，女孩们将目光，重新投向了图论的另一个核心问题：最短路径。

“我们之前已经学过Dijkstra算法了，”安妮回忆道，“它像一个贪心的探险家，每次都选择离起点最近的点，来扩展我们的‘已知领域’。”

“是的，”黛芙点头，“但Dijkstra有一个致命的弱点——它无法处理带有‘**负权边**’的图。在现实世界中，负权边是有意义的。比如，在金融交易中，‘边权’可以代表收益，那么‘负权’就代表着‘成本’或‘亏损’。或者在某些游戏中，走过一条特定的路，不仅不消耗体力，反而能‘增加体力’。”

伊莎贝尔望着窗外被白雪覆盖的世界，说：“想象一下，在这片雪原上，大部分道路都会消耗我们的体力（正权），但某条神秘的小径上，我们能发现一个补给站，回复一些体力（负权）。Dijk.stra这位‘只看眼前’的探险家，就会在这样的地图上迷路，因为它无法理解‘绕远路去加个血，可能让后续的总消耗变得更少’这种复杂的策略。”

“为了解决带负权边的最短路径问题，我们需要两位新的、更‘深谋远虑’的引路人：**贝尔曼-福特（Bellman-Ford）算法**和**弗洛伊德（Floyd-Warshall）算法**。”

#### **Bellman-Ford：反复松弛的智慧**

“贝尔曼-福特算法，是解决‘**单源最短路径**’问题的、一个更通用的方法。”黛芙开始讲解，“它的思想，更接近动态规划，充满了‘反复迭代、逐步逼近’的智慧。”

**核心思想：**
对图中的**所有边**，进行**V-1**（V是顶点数）轮“**松弛**”（Relaxation）操作。一轮松弛，就是遍历所有的边`(u, v)`，并尝试更新`v`的距离：`if dist[u] + weight(u,v) < dist[v]: dist[v] = ...`。

**为什么是 V-1 轮？**
“因为在一个不包含负权环的图中，任何一条最短路径，最多只会包含`V-1`条边。”黛芙解释道，“所以，经过第一轮松弛，我们保证能找到所有‘最多经过1条边’的最短路径；经过第二轮，我们能找到所有‘最多经过2条边’的最短路径……以此类推，经过`V-1`轮松弛，我们就能保证找到所有可能的最短路径。”

**负权环的检测：**
“Bellman-Ford还有一个‘杀手锏’，”希娅补充道，“如果在完成了`V-1`轮松弛之后，我们再进行第`V`轮松弛，发现`dist`数组的值‘仍然可以被更新’，这意味着什么？”

“意味着……图里存在一个‘**负权环**’！”安妮想明白了，“因为只有在一个可以无限‘刷分’（减小距离）的负权环里，距离才可能在V-1轮之后，还能被继续缩短！”

#### **Floyd-Warshall：全局视野的洞察**

“Bellman-Ford解决了单源问题，但如果，我们想知道‘任意’两个顶点之间的最短路径呢？难道要对每个点都跑一遍Bellman-Ford吗？”黛芙提出了一个新问题。

“那样效率太低了。”

“对于这个问题，弗洛伊德算法提供了一个极其优雅、极其对称的解决方案。它能一次性地，计算出‘**所有顶点对（All-Pairs）**’之间的最短路径。”

**核心思想：**
Floyd算法的思想，是动态规划的完美体现。它引入了“中转点”的概念。

**状态定义 (State):**
`dp[k][i][j]` 代表：在只允许使用编号从`1`到`k`的顶点作为‘中转点’的情况下，从顶点`i`到顶点`j`的最短路径长度。

**状态转移方程:**
“当我们计算`dp[k][i][j]`时，我们思考：从`i`到`j`，允不允许经过`k`这个新的中转点？”

-   **不允许经过`k`:** 那么，最短路径就和只允许经过`1`到`k-1`号中转点时一样，即 `dp[k-1][i][j]`。
-   **允许经过`k`:** 那么，路径可能是 `i -> ... -> k -> ... -> j`。这条路径的长度，就是 `dp[k-1][i][k] + dp[k-1][k][j]`。

**`dp[k][i][j] = min( dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j] )`**

“在实现时，我们可以用一个二维数组，通过一个三层循环，来优化掉`k`这个维度。”

```python
# Floyd-Warshall 伪代码
for k from 1 to N:      // 尝试将k作为新的中转点
    for i from 1 to N:  // 遍历所有起点i
        for j from 1 to N: // 遍历所有终点j
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

“三层循环，简单、暴力，但却蕴含着深刻的DP思想。”黛芙总结道，“它用O(V³)的复杂度，解决了所有点对之间的最短路径问题。”

#### **最短路径算法的选择**

黛芙在白板上，为这些“引路人”们，也做了一次清晰的总结。

```ascii
+----------------+----------------+----------------+----------------+--------------------+
|      算法      |     时间复杂度     |   能否处理负权边   |   能否检测负权环   |       问题类型       |
+================+================+================+================+====================+
|    Dijkstra    | O(E logV) [优] |        否        |        否        |     单源最短路径     |
+----------------+----------------+----------------+----------------+--------------------+
|  Bellman-Ford  |     O(V * E)     |        是        |        是        |     单源最短路径     |
+----------------+----------------+----------------+----------------+--------------------+
| Floyd-Warshall |      O(V³)       |        是        |    是 (检查对角线)   |    所有点对最短路径    |
+----------------+----------------+----------------+----------------+--------------------+
```

冬夜的星空，像一张巨大的、无形的图。安妮明白了，Dijkstra是那束在没有“黑洞”（负权环）的坦途上，指引我们走捷径的明亮手电；Bellman-Ford则更像一位谨慎的向导，他会反复勘探，确保我们不会陷入“越走能量越多”的奇异时空；而Floyd，则是那位站在上帝视角的制图师，他不在乎起点和终点，他要绘制出整个宇宙任意两点间的所有时空航线。

---

🌸 **最短路径算法核心要点** 🌸

**1. 算法设计的根本思想**
- **松弛（Relaxation）是核心：** 无论是Dijkstra, Bellman-Ford还是Floyd，它们的核心操作都是“松弛”。即，通过一条新的路径 `u -> v`，去尝试更新顶点`v`的已知最短距离。不同的算法，只是松弛的“顺序”和“策略”不同。
- **迭代与收敛：** Bellman-Ford和Floyd都体现了“迭代逼近”的思想。它们通过一轮轮的计算，不断地优化距离矩阵，直到最终收敛到全局最优解。
- **负权环的破坏性：** 负权环的存在，使得“最短路径”的定义本身失去了意义（因为可以无限循环刷低成本）。能够检测出负权环，是衡量一个通用最短路径算法鲁棒性的重要标准。

**2. 核心设计哲学**
- **贪心 vs. 动态规划：** Dijkstra（贪心）与Bellman-Ford（DP）的对比，是这两种思想在图论上的直接碰撞。贪心追求每一步的局部最优，速度快但有前提；DP则通过完备的迭代，保证了结果的正确性，但速度较慢。
- **升维思考：** Floyd算法通过增加“中转点`k`”这个维度，来解决所有点对的最短路径问题，是DP“升维”思想的典范。其`dp[k][i][j]`的状态定义，是算法的精髓。
- **适用场景的权衡：** 没有“最好”的算法，只有“最合适”的。在无负权的稀疏图上求单源最短路，Dijkstra是王者；在有负权但无负权环时，Bellman-Ford是可靠的选择；而要求所有点对最短路，且顶点数不大时，Floyd简洁的实现是其最大优势。

**3. 算法思维的启发**
- **从“边”到“点”的视角：** Bellman-Ford的松弛操作，是以“边”为中心的（遍历所有边）。而Floyd的递推，则是以“点”为中心的（将点作为中转）。这种视角的切换，带来了完全不同的算法结构。
- **DP状态的演进：** Floyd算法`dp[k][i][j]`的定义，完美地展示了DP状态是如何通过增加约束（只允许用前k个点中转），来从子问题构建出原问题解的。
- **算法的“签名”：** 一个算法的复杂度，就是它的“签名”。O(E logV), O(V*E), O(V³)，看到这些复杂度，就应该能立刻联想到它们分别对应哪种算法和哪类问题。

---

🎀 **安妮的小小日记本**

今天，我的最短路径工具箱，终于完整了！

Dijkstra像一个乐观的阳光少年，他相信世界是美好的，所有路都是越走越累的（没有负权），所以他总是勇敢地走那条看起来最近的路。

Bellman-Ford则像一位经验丰富、沉稳持重的老者。他知道路上可能有“陷阱”（负权边），所以他从不轻信，而是不厌其烦地，把所有已知的路，都反复考察`V-1`遍，直到确认再也没有“近路”可走了，他才安心。他甚至还能发现那些能让人“长生不老”的“负权环”！

而Floyd，他根本不是一个走路的人，他是一位神明！他飘在空中，俯瞰着整个地图。他的脑子里，只有一张巨大的表格，记录着任意两个人之间的最短距离。他通过一个又一个的“中转点”，不断地更新着这张终极地图，直到宇宙间再无秘密可言。

感觉好酷！不同的问题，不同的世界观，就需要派出不同性格的“英雄”去解决！

---

### 今日关键词

- **单源最短路径 (SSSP):** （回顾）从一个源点出发，到图中所有其他顶点的最短路径。
- **所有顶点对最短路径 (All-Pairs Shortest Path, APSP):** 计算图中每一对顶点之间的最短路径。
- **负权边 (Negative Weight Edge):** 权重为负数的边。
- **负权环 (Negative Weight Cycle):** 环路中所有边的权重之和为负数。最短路径在存在负权环的图中没有定义。
- **Bellman-Ford算法:** 一种能处理负权边、并能检测负权环的单源最短路径算法。
- **Floyd-Warshall算法:** 一种用于求解所有顶点对最短路径的动态规划算法。
- **松弛操作 (Relaxation):** （回顾）更新最短路径估计值的核心操作。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（模板与理解）**  
1.  **手动实现Bellman-Ford和Floyd** ⭐⭐ —— 亲手实现这两种算法，是理解其循环和松弛过程的最好方式。特别是Floyd，其三层循环的简洁代码背后，是深刻的DP思想。
2.  LC 787. Cheapest Flights Within K Stops ⭐⭐⭐ —— K站中转内最便宜的航班。这是Bellman-Ford算法的绝佳应用。题目要求“最多中转K次”，这与Bellman-Ford“最多经过K条边”的思想完全对应。只需要进行K+1轮松弛即可。

**进阶巩固（模型应用与变种）**  
3.  **检测负权环** ⭐⭐ —— 在你实现的Bellman-Ford算法基础上，增加第V轮松弛，并实现检测和报告负权环的功能。
4.  **Floyd传递闭包** ⭐⭐ —— Floyd算法不仅能求最短路，还能用来求解图的“传递闭包”，即判断任意两点`i, j`之间是否连通。只需将`dist[i][k] + dist[k][j]`的操作，换成逻辑运算`dist[i][k] and dist[k][j]`即可。
5.  LC 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance ⭐⭐ —— 找到一个城市，使得与它距离在阈值内的城市数量最少。这是一个标准的“所有点对最短路径”问题，可以直接用Floyd-Warshall算法求解出距离矩阵，然后再进行统计。
