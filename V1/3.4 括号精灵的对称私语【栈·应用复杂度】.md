### **3.4 括号精灵的对称私语【栈·应用复杂度】**

*"左括号，是许下的一份承诺；右括号，是兑现承诺的印记。栈，便是那忠实的见证者，记录着每一份承诺，并校验着每一次的兑现。于这方寸之间，复杂度亦有其奥秘。"*

在亲手用数组和链表，打造了“栈”这件“兵器”之后，安妮对这个“后进先出”的结构，已经了如指掌。现在，是时候，将这件兵器，带到真正的“战场”上，去感受它的威力了。

“我们之前，已经用一个非常生动的比喻，解决了‘**有效的括号**’（LC 20）这个问题。”黛芙在图书馆的书桌前，重新开启了这个话题，“今天，我们不仅要知其然，更要知其所以然。我们要从‘**复杂度**’的角度，去精确地分析，为什么栈，是解决这个问题的‘最优’工具。”

#### **问题回顾：有效的括号**

-   **问题:** 给定一个只包含`()[]{}`的字符串，判断其是否有效。
-   **有效条件:** 1. 左括号必须被同类型右括号闭合。 2. 左括号必须以正确的顺序闭合。

#### **栈解法的再审视**

伊莎贝尔用她那富有诗意的语言，再次描述了那个“承诺与兑现”的算法流程。

“我们的栈，是‘**承诺记录簿**’。我们从左到右，阅读这串由括号精灵留下的密语。”

1.  “遇到左括号，是‘许下承诺’，我们将它**压入**栈顶，作为最新的、亟待兑现的承诺。”
2.  “遇到右括号，是‘兑现时刻’。我们**弹出**栈顶的那个、最近的承诺，检查是否匹配。”
3.  “旅程结束，记录簿必须‘**空空如也**’，才算所有承诺都已完美履行。”

```python
# 回顾代码实现
def is_valid_parentheses(s: str) -> bool:
    stack = []
    mapping = {")": "(", "]": "[", "}": "{"}

    for char in s:
        if char in mapping: # 右括号
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else: # 左括号
            stack.push(char)

    return not stack
```

#### **复杂度分析：线性时间的优雅**

“现在，我们来为这个算法，做一次精准的‘时光占卜’。”黛芙拿起笔，开始进行复杂度分析。

```ascii
“有效的括号”栈解法 复杂度分析 (N = 字符串长度)

┌──────────────────┬──────────────────────────────────┐
│   **时间复杂度**   │             **分析过程**             │
├──────────────────┼──────────────────────────────────┤
│      **O(N)**      │ 算法的核心，是一个`for`循环，它会 │
│                  │ 完整地、不重不漏地，遍历输入字符   │
│                  │ 串`s`中的每一个字符，恰好一次。    │
│                  │                                  │
│                  │ 在循环的每一步中，我们所做的操作： │
│                  │ - 判断`char`是左括号还是右括号。   │
│                  │ - `push()` 操作：O(1)。            │
│                  │ - `pop()` 操作：O(1)。             │
│                  │ - 哈希表`mapping`的查询：O(1)。    │
│                  │                                  │
│                  │ 由于循环执行N次，且每次循环内部的  │
│                  │ 操作都是常数时间，所以总的时间复杂 │
│                  │ 度，与字符串的长度N成正比。        │
└──────────────────┴──────────────────────────────────┘

┌──────────────────┬──────────────────────────────────┐
│   **空间复杂度**   │             **分析过程**             │
├──────────────────┼──────────────────────────────────┤
│      **O(N)**      │ 算法的额外空间消耗，主要来自于那个 │
│                  │ `stack`。                          │
│                  │                                  │
│                  │ 在最坏的情况下，例如输入是        │
│                  │ `"((((("` 或 `"([{"` 这样的字符串， │
│                  │ 我们会将所有的左括号，都压入栈中。 │
│                  │                                  │
│                  │ 此时，栈的大小，与输入字符串的长   │
│                  │ 度N成正比。因此，空间复杂度是O(N)。│
└──────────────────┴──────────────────────────────────┘
```

“O(N)的时间，O(N)的空间。”黛芙总结道，“这是一个非常高效的解法。我们只对字符串进行了一次线性扫描，就解决了这个看似需要反复嵌套检查的问题。这，就是栈这种数据结构，‘四两拨千斤’的威力所在。”

#### **应用扩展：表达式求值**

“栈的这种‘暂存’和‘处理最近相关性’的能力，还有一个更强大的应用——**中缀表达式求值**。”希娅在屏幕上，打出了一行算式：`3 + 5 * ( 2 - 8 / 4 )`。

“我们人类，能很自然地，根据‘先乘除，后加减，有括号先算括号’的规则，来计算它。但计算机要如何理解这个‘优先级’呢？”

“答案是，用‘**两个栈**’！”黛芙说，“一个‘**数字栈**’（`operand_stack`），一个‘**操作符栈**’（`operator_stack`）。”

**算法思路（双栈法）：**
1.  遍历表达式。遇到**数字**，直接压入数字栈。
2.  遇到**操作符**（如`+`, `*`），与操作符栈的栈顶操作符，进行“**优先级**”比较。
    -   如果当前操作符，优先级**高于**栈顶操作符，则将其压入操作符栈。（比如，`*`比`+`优先级高）
    -   如果**低于或等于**，则从数字栈弹出两个数，从操作符栈弹出一个操作符，进行计算，并将结果，再压回数字栈。然后，再将当前操作符与新的栈顶比较。
3.  遇到**左括号`(`**，直接压入操作符栈。
4.  遇到**右括号`)`**，则不断地进行计算，直到遇到对应的左括号`(`为止。
5.  表达式遍历完后，再依次清空操作符栈，进行最后的计算。

“这个过程，完美地模拟了我们人脑的计算顺序。”伊莎贝尔总结道，“操作符栈，就像一个‘**待办任务列表**’。高优先级的任务（`*`, `/`）可以‘插队’到前面。而括号，则创造了一个‘必须优先完成’的、独立的‘子任务’。栈的LIFO特性，保证了这些复杂的优先级和嵌套关系，能被正确地、有序地处理。”

安妮看着这套复杂的、但又充满了内在逻辑的规则，感觉自己仿佛窥见了“编译器”工作的冰山一角。原来，我们写下的每一行代码，每一个数学公式，在计算机的眼中，都会被分解为这样一次次底层的、基于栈的、严谨的压入与弹出。栈，这位沉默的、不起眼的“图书管理员”，竟是整个程序世界得以有序运行的、最忠实的守护者。

---

🌸 **栈应用与复杂度核心要点** 🌸

**1. 算法设计的根本思想**
- **匹配与消除：** （回顾）括号匹配问题，其核心是一种“匹配与消除”的模型。一个右括号的出现，会“消除”掉一个最近的、匹配的左括号。栈是实现这种模型的完美工具。
- **优先级管理：** 在表达式求值等问题中，栈被用来管理不同操作符的“优先级”。通过比较当前操作符与栈顶操作符的优先级，来决定是“入栈等待”还是“出栈计算”。
- **上下文的保存：** 在处理具有嵌套结构的问题时（如括号、表达式），栈起到了“保存外层上下文”的作用。当处理完内层逻辑后，可以通过弹栈，来“恢复”到外层，并继续执行。

**2. 核心设计哲学**
- **线性扫描的威力：** 栈的应用，常常能将一些看似需要嵌套、回溯才能解决的问题，转化为一次“线性扫描”的O(N)解法。它用一个辅助的空间（栈），换取了时间效率的巨大提升。
- **模型的抽象：** 无论是“括号匹配”，还是“表达式求值”，其背后，都可以抽象为“在序列处理中，根据规则，进行状态的暂存与回溯”这一通用模型。栈，是解决该模型的“标准件”。

**3. 算法思维的启发**
- **“栈”的适用场景：** 当你遇到任何与“最近”、“上一个”、“嵌套”、“对称”、“撤销/Undo”、“回溯”等关键词相关的问题时，都应该将“栈”作为你的首要思考工具。
- **双栈的应用：** “双栈”是解决一些更复杂问题时的常用技巧。一个栈负责存储数据，另一个栈负责存储状态或操作符，两者协同工作。

---

🎀 **安妮的小小日记本**

今天，我终于为“括号匹配”这个老朋友，做了一次详尽的“体检报告”！

O(N)的时间，O(N)的空间。这个结论，让我对它的“优秀”，有了更具体的、量化的认识。它只看一遍字符串，就能做出最精准的判断，真的好厉害！

而“表达式求值”那个双栈法，则让我大开眼界！一个数字栈，一个符号栈，就像两个配合默契的“会计”和“出纳”。数字们排队等着被计算，而符号们，则在另一个队伍里，根据自己的“优先级”，决定谁先“盖章”。整个过程，井然有序，一丝不苟！

我发现，栈，真的像一个“后悔药”！或者说，是一个“草稿箱”。它可以帮你记住你上一步做了什么，让你可以在需要的时候，随时“撤销”，回到过去。正是因为有了这种“后悔”的能力，我们才能勇敢地，去处理那些复杂的、层层嵌套的问题！

---

### 今日关键词

- **括号匹配 (Parentheses Matching):** （回顾）一个经典的、用栈解决的计算机科学问题。
- **中缀表达式 (Infix Expression):** 操作符位于操作数之间的、符合人类阅读习惯的数学表达式，如`3 + 4`。
- **后缀表达式 / 逆波兰表示法 (Postfix Expression / RPN):** 一种将操作符写在操作数之后的表达式，如`3 4 +`。它无需括号，且能被栈非常高效地求值。
- **双栈算法 (Two-Stack Algorithm):** 使用两个栈来协同解决一个问题的方法，常用于表达式求值等场景。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议：通过这些题目，深入理解栈在处理“优先级”和“嵌套”问题上的强大能力。

**练习**  
1.  LC 150. Evaluate Reverse Polish Notation ⭐⭐ —— 计算逆波兰表达式（后缀表达式）的值。这个问题比中缀表达式求值更简单，是其基础。你只需要一个数字栈。遍历表达式，遇到数字就压栈；遇到操作符，就弹出两个数字进行计算，再将结果压栈。
2.  LC 224. Basic Calculator ⭐⭐⭐ —— 基本计算器。实现一个支持`+`, `-`和`()`的中缀表达式求值。这是双栈法或“逆波兰转换法”的经典应用，非常考验对栈的理解和代码的细节处理能力。
3.  LC 227. Basic Calculator II ⭐⭐⭐ —— 基本计算器II。在上一题的基础上，增加了`*`和`/`，需要你正确地处理操作符的“优先级”。
