### **20.4 音符流转的哈希共鸣【Rabin-Karp】**

*"我为每一段旋律，都赋予一个独一无二的数字灵魂。当命运的乐章奏响，若两个灵魂彼此共鸣，那便是你我重逢的瞬间。"*

在学习了灵活的滑动窗口技巧后，女孩们对于处理“连续子串”问题，有了新的武器。但黛芙指出，对于最经典的“字符串匹配”问题（在一个长文本中，寻找一个模式串），还有一种非常独特的、基于数学思想的解法。

“我们之前学过BF（暴力匹配），KMP（利用前缀信息），Z算法（利用自身匹配信息）。”黛芙说，“今天，我们要学习一种全新的思路，它不去比较字符，而是去比较‘指纹’。这个算法，就是‘**Rabin-Karp算法**’。”

“指纹？”安妮对这个词很感兴趣。

“是的，”伊莎贝尔拿起她的尤克里里，弹奏了一小段旋律，“我们可以把这段旋律，通过某种‘魔法’，转化成一个‘独一无二’的数字，这个数字，就是这段旋律的‘指纹’，也叫‘**哈希值**’（Hash Value）。”

“现在，如果我想在一首很长的乐曲中，找到这段旋律。我不需要一个音符一个音符地去比对。我只需要计算出乐曲中，每一个‘等长’片段的‘哈希值’，然后去和我手里这段旋律的哈希值做比较。如果哈希值相等，就说明这两段旋律‘极有可能’是相同的！”

#### **字符串的哈希灵魂：滚动哈希**

“这个想法太棒了！”希娅立刻发现了问题，“但是，如果文本串很长，我们每次都重新计算一个子串的哈希值，那效率不是很低吗？比如，计算`'abc'`的哈希，再计算`'bcd'`的哈希，等于把所有工作都重做了一遍。”

“问得好！这正是Rabin-Karp算法最精妙的地方——‘**滚动哈希**’（Rolling Hash）。”黛芙开始讲解这个核心技巧。

“我们如何给一个字符串，比如`'abc'`，计算一个哈希值呢？我们可以把它看作一个‘**P进制**’的数。”

-   `hash('abc') = (a * P² + b * P¹ + c * P⁰) % M`

“这里的`P`是一个质数（比如31），`M`是另一个巨大的质数（为了防止结果溢出）。每个字符`a,b,c`都可以映射成一个数字（比如1,2,3）。”

“现在，我们来看‘滚动’的魔法。假设我们已经算出了`hash('abc')`，现在想在O(1)时间内，算出`hash('bcd')`。”

-   `hash('abc') = (a*P² + b*P¹ + c*P⁰)`
-   `hash('bcd') = (b*P² + c*P¹ + d*P⁰)`

“我们发现，`hash('bcd')`可以通过`hash('abc')`推导出来：”

1.  **减去最高位:** `hash_temp = hash('abc') - a*P²`  (减去`a`的影响)
2.  **整体左移:** `hash_temp = hash_temp * P` (相当于所有位都升了一次幂)
3.  **加上最低位:** `hash_temp = hash_temp + d` (加上新字符`d`)

“通过这三步，我们就在O(1)的时间内，用上一个窗口的哈希值，‘滚动’计算出了当前窗口的哈希值！”

#### **哈希冲突：灵魂的双胞胎**

“可是，”安妮提出了一个关键的疑问，“有没有可能，两段完全不同的旋律，经过‘魔法’转化后，得到了同一个‘指纹’（哈希值）呢？就像世界上可能有两个长得一模一样的人。”

“完全可能！这个问题，我们称之为‘**哈希冲突**’（Hash Collision）。”黛芙肯定了安妮的思考，“这是所有哈希算法都无法完全避免的问题。但是，通过选择足够大的质数`P`和模数`M`，我们可以让这种冲突的概率，变得极其微小，小到在一次算法竞赛中几乎不可能发生。”

“为了保证算法100%的正确性，Rabin-Karp的标准做法是：**当且仅当两个子串的哈希值相等时，我们再对这两个子串，进行一次逐字符的暴力比较，以确认它们是否真的相同。**”

“在大多数情况下，哈希值都不同，我们O(1)就跳过了。只有在极少数哈希值相同的情况下，我们才需要多花一点时间去确认。这使得算法的平均效率非常高。”

#### **算法流程**

1.  计算模式串`P`的哈希值 `hash_p`。
2.  计算文本串`T`中第一个窗口（与`P`等长）的哈希值 `hash_t`。
3.  比较`hash_p`和`hash_t`。如果相等，再逐字符比较一次。
4.  开始“滚动”：用O(1)的时间，根据上一个窗口的`hash_t`，计算出下一个窗口的新`hash_t`。
5.  重复步骤3和4，直到窗口滑过整个文本串。

冬夜寂静，只有代码的逻辑在女孩们的脑中流淌。Rabin-Karp算法，就像一位优雅的数学家，它不屑于像KMP那样去分析字符串的“结构”，而是另辟蹊径，将所有复杂的字符串，都抽象、映射为一个个简洁的数字。它用概率论和数论的智慧，在“确定性”与“效率”之间，找到了一条美妙的平衡之道。

---

🌸 **Rabin-Karp算法核心要点** 🌸

**1. 算法设计的根本思想**
- **哈希降维：** 算法的核心，是将“字符串”这个高维度的、难以直接比较的对象，通过哈希函数，“降维”成一个易于比较的整数“指纹”。它将“字符串是否相等”的比较，转化为了“整数是否相等”的比较。
- **滚动计算：** 滚动哈希是该算法能够达到线性时间复杂度的关键。它利用了相邻子串之间的高度重叠性，通过O(1)的数学运算，来代替O(L)的重新计算，是“增量计算”思想的完美体现。
- **概率与确定性：** Rabin-Karp是一个“概率性”算法。它给出的“匹配”，有极小的可能是由哈希冲突引起的“误报”。为了达到100%的确定性，必须增加一个额外的验证步骤。在实践中，如果哈希函数设计得足够好，这个验证步骤很少会被触发。

**2. 核心设计哲学**
- **数学之美：** 算法的基石是数论（多项式哈希、模运算、质数选择）。它展现了如何用纯粹的数学工具，来巧妙地解决计算机科学中的问题。
- **预计算的力量：** 为了实现O(1)的滚动，我们需要预先计算出`P`的各次幂（`P^L`），以便在“减去最高位”时使用。这也是一种“预处理换取后续效率”的思想。
- **冲突的处理：** 算法坦然地承认并面对了“哈希冲突”的可能性，并通过一个“二次确认”的机制来弥补。这种“快速筛选+精确验证”的两阶段策略，在很多系统中都有应用（如数据库索引查询）。

**3. 算法思维的启发**
- **“指纹”思想：** 为一个复杂的数据对象（如字符串、图片、文件）计算一个简短的、能大概率代表其内容的“指纹”（哈希值），是一种非常重要的思想。它被广泛应用于数据去重、文件校验（MD5）、密码存储等领域。
- **寻找“可滚动”的特性：** 在处理滑动窗口类问题时，思考窗口内所计算的“状态”，是否具有“可滚动”的特性。即，能否通过O(1)的操作，从上一个窗口的状态，推导出当前窗口的状态。
- **双哈希（Double Hashing）：** 为了进一步降低哈希冲突的概率，可以使用两个不同的质数`P`和模数`M`，计算出两个独立的哈希值。只有当两个哈希值同时相等时，才认为可能匹配。这能让冲突概率降低到几乎可以忽略不计。

---

🎀 **安妮的小小日记本**

今天学的Rabin-Karp算法，感觉好神奇！它就像一个给字符串算命的大师。

它不关心字符串长什么样，而是给每个字符串，都算出一个“哈希值”，就像是它们的“生辰八字”或者“灵魂ID”。要判断两个字符串是不是一样，不用一个一个字符地去比，只要看看它俩的“灵魂ID”是不是一样就行了！

最酷的是那个“滚动哈希”！就像一个滑动的“灵魂探测器”，它在文本串上移动时，不需要每次都重新施法，只需要做一点点简单的数学题，就能算出新窗口里那段字符串的“灵魂ID”。这让整个匹配过程快得飞起！

虽然学姐说，偶尔会有两个完全不同的人，算出了一样的“生辰八字”（哈希冲突），但只要我们的算法足够好，这种概率就比我出门捡到钱还低！而且，只要在发现ID相同时，再仔细看一眼“脸”（字符串本身），就能保证万无一失了。

用数学来解决字符串问题，这种感觉，就像是在用一种宇宙通用的语言来编程，太优雅了！

---

### 今日关键词

- **Rabin-Karp算法:** 一种使用哈希函数来快速筛选不匹配项的字符串匹配算法。
- **滚动哈希 (Rolling Hash):** 一种高效计算滑动窗口内子串哈希值的技术。它能在O(1)时间内，利用前一个窗口的哈希值，计算出当前窗口的哈希值。
- **字符串哈希 (String Hashing):** 将一个任意长度的字符串，映射成一个固定长度的数值（哈希值）的过程。
- **哈希冲突 (Hash Collision):** 两个不同的输入，经过哈希函数计算后，得到了相同的哈希值。
- **P进制哈希:** 将字符串看作一个P进制的数，来计算其哈希值的一种常用方法。
- **模运算 (Modulo Operation):** 在哈希计算中，为了防止数值过大而溢出，通常会对一个大的质数进行取模操作。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（模板与理解）**  
1.  **手动实现Rabin-Karp** ⭐⭐ —— 亲手实现Rabin-Karp算法，解决`strStr()`问题。重点在于正确实现滚动哈希的逻辑，包括处理取模运算中的负数问题。
2.  LC 1044. Longest Duplicate Substring ⭐⭐⭐ —— 最长重复子串。这是一个Rabin-Karp的绝佳应用舞台。我们可以对“重复子串的长度L”进行“二分答案”，然后用Rabin-Karp，在O(N)时间内，判断是否存在长度为L的重复子串。

**进阶巩固（模型应用）**  
3.  LC 187. Repeated DNA Sequences ⭐⭐ —— 重复的DNA序列。在一个DNA字符串中，找到所有出现超过一次的、长度为10的子串。可以用一个固定长度为10的滑动窗口，计算每个子串的哈希值，并用一个哈希表来计数。
4.  LC 1392. Longest Happy Prefix ⭐⭐⭐ —— 最长快乐前缀。一个字符串的“快乐前缀”是指它的一个非空前缀，同时也是它的后缀。这个问题等价于寻找“最长的、与后缀相等的前缀”。可以用字符串哈希，在O(N logN)（二分+哈希）或O(N)（正反哈希）时间内解决。
