### **4.5 祭典上的排队游戏【队列·LeetCode】**

*"当FIFO的法则，与千变万化的谜题相遇，每一次的入队与出队，都化为解开谜题的、那把看似朴素，却至关重要的钥匙。"*

在系统地学习了队列及其“VIP变体”——双端队列和优先队列之后，春日祭典的喧嚣，也渐渐接近尾声。作为本次“队列”章节的终章，希娅为大家准备了最后几道有趣的“排队游戏”。

“我们已经知道，队列是BFS的灵魂，优先队列是Dijkstra和堆相关问题的核心。”希娅说，“但有时，队列本身，也能作为主角，解决一些非常巧妙的问题。”

#### **第一道谜题：用队列实现栈 (Implement Stack using Queues)**

希娅展示了第一题：**LC 225. 用队列实现栈**。

“题目要求我们，只能使用队列的基本操作（`enqueue`, `dequeue`, `peek`, `is_empty`），来实现一个栈。也就是说，我们要用‘先进先出’的工具，来模拟‘后进先出’的行为。”

“这……这怎么可能？”安妮觉得这完全是矛盾的，“队列是‘队头出’，栈是‘队尾出’（如果我们用数组末尾作栈顶的话）。”

“这需要一点‘乾坤大挪移’的技巧。”伊莎贝尔提示道，“想一想，我们如何才能让一个‘新入队’的元素，跑到队伍的‘最前面’去呢？”

安妮思索着，在纸上画着队列的变化。“有了！比如，队列里现在是`[A, B]`。当新元素`C`入队后，队列变成`[A, B, C]`。为了让`C`成为下一个被‘pop’的元素，我需要让它排到队头！我可以把`A`和`B`，依次地，从队头‘出队’，然后再立刻‘入队’到队尾！”

**`push(C)` 的操作流程:**
1.  `C`正常入队。队列变为 `[A, B, C]`。
2.  执行`size() - 1`次（即2次）“队头出，队尾进”的操作。
    -   `A`出队，再入队。队列变为 `[B, C, A]`。
    -   `B`出队，再入队。队列变为 `[C, A, B]`。

“看！”安妮兴奋地说，“现在，最后进来的`C`，就跑到了队头！下一次`pop`（也就是`dequeue`），出来的就是`C`了！我们成功地用队列，模拟了栈的LIFO！”

“非常聪明的解法！”黛芙点头，“这个解法，让`push`操作的复杂度变成了O(N)，而`pop`是O(1)。我们也可以反过来，让`push`是O(1)，而在`pop`时，将前`n-1`个元素，转移到另一个辅助队列中，来实现O(N)的`pop`。”

#### **第二道谜题：循环的滑动窗口 (Moving Average from Data Stream)**

“下一题，是一个关于‘数据流’和‘窗口’的问题。”希娅点开了 **LC 346. 数据流中的移动平均值**。

“要求我们设计一个结构，能计算一个大小为`k`的、不断滑动的窗口中，所有数字的平均值。”

“滑动窗口！”安妮立刻想到了这个熟悉的模型，“我们需要维护一个大小固定为`k`的窗口。当新元素进来时，最老的元素就要出去。”

“用什么数据结构，能方便地实现‘一头进，一头出’呢？”伊莎贝尔问。

“队列！”安妮脱口而出，“这正是队列的FIFO特性！新来的数，从队尾`enqueue`；当队列的长度超过`k`时，就从队头`dequeue`一个最老的数。我们只需要再维护一个变量`current_sum`，记录窗口内所有数的和。每次入队就加上新数，出队就减去旧数。这样，计算平均值就是O(1)了！”

```python
from collections import deque

class MovingAverage:
    def __init__(self, size: int):
        self.queue = deque()
        self.capacity = size
        self.current_sum = 0.0

    def next(self, val: int) -> float:
        self.current_sum += val
        self.queue.append(val)
        
        if len(self.queue) > self.capacity:
            # 如果窗口满了，移除最老的元素
            removed_val = self.queue.popleft()
            self.current_sum -= removed_val
            
        return self.current_sum / len(self.queue)
```

“Python的`collections.deque`，就是一个高效的双端队列，用它来实现这个固定大小的滑动窗口，再合适不过了。”黛芙总结道。

祭典的灯火，在夜色中，汇成了一条条流光溢彩的长河，缓缓流动，永不停歇。安妮看着眼前的景象，感觉自己对“队列”的理解，也如这灯火的长河般，从一个孤立的点，汇入了一条更广阔、更流动的思想之河。她明白了，无论是栈还是队列，它们最深刻的价值，都不在于其自身的结构，而在于它们所代表的那种独特的、处理“时间”与“顺序”的哲学。

---

🌸 **队列应用核心要点** 🌸

**1. 算法设计的根本思想**
- **模拟与转换：** “用队列实现栈”这类问题，其核心是“行为模拟”。通过对基础操作的巧妙组合，用一种数据结构，去模拟出另一种数据结构的特性。这个过程，能极大地加深对两者本质区别的理解。
- **维护固定窗口：** 对于“滑动窗口”类问题，队列（特别是双端队列）是维护这个“先进先出”的窗口的天然工具。它能以O(1)的效率，完成窗口的滑动（即，队尾进，队头出）。
- **数据流处理：** 队列的FIFO特性，使其非常适合处理“数据流”或“事件流”。它能保证数据的处理顺序，与它们的到达顺序一致，并能作为一个“缓冲区”，来平滑“生产者”和“消费者”之间的速度差异。

**2. 核心设计哲学**
- **抽象的力量：** “用队列实现栈”告诉我们，只要能实现目标接口（`push`, `pop`等）所定义的“行为”，其底层的具体实现是可以被替换的。这是“面向接口编程”思想的体现。
- **组合的威力：** （回顾）通过将“队列”和“一个额外的`sum`变量”组合，我们轻松地解决了“滑动窗口平均值”问题。用多种简单结构，组合成一个能解决特定问题的“复合结构”，是数据结构设计的常用方法。

**3. 算法思维的启发**
- **反向思考：** “用A实现B”这类问题，是锻炼思维灵活性的好方法。它强迫你跳出A的常规用法，去思考如何“扭曲”或“组合”它的操作，以达到一个全新的目的。
- **识别“窗口”模型：** 当你遇到任何需要在“一个连续的、大小固定或可变的区间”上，进行计算或统计的问题时，都应该立刻联想到“滑动窗口”，并进而思考，是否可以用队列或双端队列，来高效地维护这个窗口。
- **算法与现实的连接：** 从排队买东西，到CPU的任务调度，再到网络数据包的传输，队列是现实世界和计算机世界中，应用最广泛、最基础的结构之一。理解它，就是理解我们所处数字世界的基本秩序。

---

🎀 **安妮的小小日记本**

今天的解谜游戏，像一场有趣的“变形记”！

我们竟然，用“先进先出”的队列，成功地“伪装”成了一个“后进先出”的栈！那个“把前面的所有人都请到队尾去”的操作，真的太有想象力了！虽然感觉有点“折腾”，但这个过程，让我彻底明白了，栈和队列的根本区别，就在于“新来的人，是排在队头，还是队尾”。

而“滑动窗口平均值”那道题，则让我感觉，队列就像一个有固定长度的“记忆管道”。新的记忆从一头进来，最老的记忆就从另一头被挤出去。这个模型，用来处理“最近N天”或者“最近K个数据”这类问题，简直是绝配！

我发现，我越来越喜欢这种，为一个具体的问题，去寻找、甚至“改造”一个最适合它的数据结构的过程了。这感觉，就像一个工匠，在为一把独一无二的钥匙，去配一把独一无二的锁。充满了创造的乐趣！

---

### 今日关键词

- **行为模拟 (Behavior Simulation):** 用一种数据结构的操作，来模拟出另一种数据结构的特性。
- **滑动窗口平均值 (Moving Average):** 在一个大小固定的、不断滑动的窗口内，所有元素的平均值。是信号处理和时间序列分析中的常用指标。
- **数据流 (Data Stream):** 指数据以序列的形式，连续不断地、一次一个地到达，且通常无法被完整存储。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium
> （本章的练习题已在4.1和4.3节中详细列出，此处不再重复。请参考之前的推荐列表，并额外挑战以下几道经典题目，以深化对队列应用的理解。）

**额外挑战**
1.  LC 641. Design Circular Deque ⭐⭐ —— 设计循环双端队列。这是对循环数组和双端队列两种思想的终极考验。你需要用一个固定大小的数组，和`front`, `rear`两个指针，来实现一个能在两端进行O(1)增删的循环双端队列。
2.  LC 622. Design Circular Queue ⭐⭐ —— 设计循环队列。上一题的简化版，是检验你是否真正掌握“循环数组”技巧的模板题。
3.  LC 1700. Number of Students Unable to Eat Lunch ⭐ —— 无法吃午餐的学生数量。一个非常形象的队列模拟题。学生排成一个队列，三明治堆成一个栈。队头的学生，看栈顶的三明治是否是自己喜欢的。如果是，则两者都“出局”；如果不是，则该学生重新回到“队尾”。你需要判断，最终会有多少学生，因为永远等不到自己喜欢的三明治，而“饿肚子”。
