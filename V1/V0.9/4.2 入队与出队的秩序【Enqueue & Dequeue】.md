### **4.2 入队与出队的秩序【Enqueue & Dequeue】**

*"我在人潮的末端，悄然加入，这是入队。你在队伍的最前，从容离去，这是出队。这一进一出，便维系了整个世界的流动与秩序。"*

“和栈一样，队列最核心的操作，也是两个：`enqueue`和`dequeue`。”在祭典的一个小吃摊旁，黛芙一边排着队，一边为安妮具象化地讲解这两个操作。

“我们现在，站在这条队伍的最后面。当我们决定要排队时，我们做的，就是‘**入队**’（Enqueue）操作。”

“而摊主，每次只为队伍最前面的那个人服务。当他服务完一个人，那个人离开队伍，就完成了一次‘**出队**’（Dequeue）操作。”

#### **用链表实现队列：头出尾进**

“我们之前提到，用链表实现队列，需要同时维护`head`和`tail`两个指针，以保证两端的操作都是O(1)的。”黛芙在随身的电子画板上，画出了详细的实现结构。

**数据结构:**
```cpp
class LinkedQueue {
private:
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    int current_size = 0;
};
```

**1. 入队 (Enqueue):**
“入队，就是在链表的‘尾部’添加一个新节点。”

-   **步骤：**
    1.  创建一个新节点`newNode`。
    2.  如果队列为空（`head`是`null`），则让`head`和`tail`都指向这个新节点。
    3.  如果队列不为空，则让旧的`tail`节点的`next`指针，指向`newNode`。然后，将`tail`指针，更新为`newNode`。
-   **复杂度:** **O(1)**

```cpp
void enqueue(int value) {
    ListNode* newNode = new ListNode(value);
    if (is_empty()) {
        head = tail = newNode;
    } else {
        tail->next = newNode;
        tail = newNode;
    }
    current_size++;
}
```

**2. 出队 (Dequeue):**
“出队，就是从链表的‘头部’移除一个节点。”

-   **步骤：**
    1.  检查队列是否为空。如果为空，则无法出队。
    2.  用一个临时变量，保存头节点的数据。
    3.  让`head`指针，向后移动一位，指向`head.next`。
    4.  如果出队后，队列变为空了（新的`head`是`null`），则需要额外地，将`tail`指针也设为`null`。
-   **复杂度:** **O(1)**

```cpp
int dequeue() {
    if (is_empty()) {
        throw std::runtime_error("Dequeue from an empty queue.");
    }
    int value = head->data;
    ListNode* temp = head;
    head = head->next;
    delete temp; // 释放旧头节点的内存
    if (head == nullptr) {
        tail = nullptr; // 如果队列空了，别忘了更新tail
    }
    current_size--;
    return value;
}
```

#### **操作的“实况录像”**

黛芙在画板上，演示了对这个链式队列进行一系列操作时，`head`和`tail`指针的变化。

**初始状态:** `q = LinkedQueue()` -> `head=null, tail=null`

1.  **`q.enqueue(A)`**
    -   队列为空，`head`和`tail`都指向新节点`A`。
    -   `head -> [A] <- tail`

2.  **`q.enqueue(B)`**
    -   `tail.next`指向新节点`B`，然后`tail`移动到`B`。
    -   `head -> [A] -> [B] <- tail`

3.  **`q.enqueue(C)`**
    -   `tail.next`指向新节点`C`，然后`tail`移动到`C`。
    -   `head -> [A] -> [B] -> [C] <- tail`

4.  **`value = q.dequeue()`**
    -   `value`得到`A`的值。
    -   `head`指针移动到`B`。
    -   `head -> [B] -> [C] <- tail`

“看，”黛芙总结道，“通过`head`和`tail`两个指针的默契配合，我们让数据，像一条平稳流动的河，从一端流入，从另一端流出，所有的操作，都只涉及局部的指针修改，效率非常高。”

安妮看着眼前真实的人流，又看看画板上清晰的指针流动，她深刻地理解了，队列这个数据结构，是如何用简单的“头出尾进”规则，为现实世界中无数“排队”的场景，提供了最优雅、最公平的数字模型。

---

### 今日关键词

- **Enqueue:** （回顾）在队尾添加一个新元素的操作。
- **Dequeue:** （回顾）从队头移除并返回第一个元素的操作。
- **队头指针 (Front/Head Pointer):** 指向队列第一个元素的指针。
- **队尾指针 (Rear/Tail Pointer):** 指向队列最后一个元素的指针。
- **链式队列 (Linked Queue):** 使用链表作为底层实现的队列。
