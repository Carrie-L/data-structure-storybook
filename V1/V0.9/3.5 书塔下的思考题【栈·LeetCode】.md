### **3.5 书塔下的思考题【栈·LeetCode】**

*"当LIFO的法则，与万千变化的谜题相遇，每一次的压入与弹出，都化为解开谜题的、唯一的钥匙。"*

在系统地学习了栈的LIFO原理、核心操作、经典应用（括号匹配）以及它与递归的深刻联系后，女孩们对这个看似简单的数据结构，有了全新的、全方位的认识。

图书馆的闭馆音乐，已经隐约响起。在结束今天的学习之前，希娅为大家准备了最后一场“头脑风暴”——一场关于栈的、经典的LeetCode解谜游戏。

“我们已经知道，栈是解决‘括号匹配’和‘模拟递归’的神器。”希娅说，“但它的威力，远不止于此。它最闪耀的舞台之一，是解决一类被称为‘下一个更大/更小元素’的问题。而解决这类问题的利器，就是我们之前在解题流程中，由安妮‘重新发明’的那个结构——‘**单调栈**’。”

#### **第一道谜题：下一个更大元素 (Next Greater Element)**

希娅点开了第一题：**LC 496. 下一个更大元素 I**。

“题目给出两个数组`nums1`和`nums2`，`nums1`是`nums2`的子集。要求我们，对`nums1`中的每个元素，找出它在`nums2`中对应的位置，以及在这个位置‘右侧’的、第一个比它大的数。如果不存在，则为-1。”

“最暴力的方法，”安妮立刻说，“就是对`nums1`里的每个数，都去`nums2`里找到它，然后再向后遍历，找到第一个更大的数。但这样，如果`nums2`很大，效率就很低。”

“没错。”黛芙点头，“问题的瓶颈在于，我们对`nums2`进行了大量的重复扫描。我们应该先对`nums2`进行一次‘预处理’，计算出`nums2`中‘每个元素’的下一个更大元素，并用一个哈希表存起来。然后，再遍历`nums1`，直接查表就行了。”

“关键就在于，如何高效地，为`nums2`中的每个元素，都找到它右侧的第一个更大值。”

**单调栈的智慧：**

“这正是‘单调栈’的用武之地。”伊莎贝尔解释道，“我们可以维护一个‘单调递减’的栈。这个栈里，存放的是我们‘暂时还未找到答案’的那些元素的‘下标’。”

**算法流程：**
1.  初始化一个空栈`stack`，和一个结果哈希表`result_map`。
2.  **从左到右**遍历`nums2`中的每一个数`num`：
    -   **核心逻辑：** 当栈不为空，且`num`大于栈顶下标对应的那个数`nums[stack.top()]`时，说明我们为栈顶的那个元素，找到了它苦苦等待的“下一个更大元素”！
    -   于是，我们不断地`pop`出栈顶，并将`result_map[popped_element] = num`。
    -   这个`while`循环，会一直持续到栈为空，或者`num`不再大于栈顶元素为止。
    -   **压入当前：** 最后，将当前元素的**下标**`i`，压入栈中，等待它自己的“下一个更大元素”出现。
3.  遍历结束后，栈中剩下的，就是那些没有找到下一个更大元素的，它们的结果是-1。

“这个过程，就像一群人在排队等一个‘更高’的人出现。”伊莎贝尔比喻道，“矮个子的人（小数）在前面等。突然，来了一个高个子（大数）。所有排在他前面的、比他矮的人，都瞬间找到了自己的答案，然后开心地离队。而这个高个子，则排进了队伍，等待一个比他还高的人出现。”

#### **第二道谜题：最小栈 (Min Stack)**

“下一题，是一道非常考验‘数据结构设计’能力的经典题目。”希娅展示了 **LC 155. 最小栈**。

“要求我们设计一个栈，除了支持常规的`push`, `pop`, `top`操作外，还必须支持一个`getMin`操作，它能以**O(1)的时间复杂度**，返回当前栈中的最小值。”

“O(1)地获取最小值……”安妮思索着，“我们不能在调用`getMin`时，才去遍历整个栈，那样是O(N)。这意味着，我们必须在`push`和`pop`的时候，就动态地、实时地，维护好‘当前最小值’是多少。”

“那我们可以用一个变量`min_val`来记录？”希娅提出一个想法，“但如果当前的最小值被`pop`出去了，我们怎么知道‘第二小’的值是多少呢？我们还是得遍历。”

“说得对。”黛芙说，“只用一个变量，丢失了历史信息。我们需要一个结构，能记录下‘每个阶段’的最小值。”

**解法：辅助栈**

“一个非常经典的解法，是使用一个‘**辅助栈**’（`min_stack`）。”

-   我们有两个栈：一个`data_stack`，用于正常的`push`和`pop`。另一个`min_stack`，用来同步地、存储每个阶段的最小值。
-   **`push(x)`:**
    -   `data_stack`正常`push(x)`。
    -   对于`min_stack`，我们查看它当前的栈顶元素`min_top`。如果`x`比`min_top`更小或等于，我们就把`x`也压入`min_stack`。否则，我们就把`min_top`再压入一次。（保证`min_stack`和`data_stack`高度同步）
-   **`pop()`:**
    -   `data_stack`和`min_stack`，**同时**`pop`。
-   **`getMin()`:**
    -   直接返回`min_stack`的栈顶元素即可。

“通过用O(N)的额外空间（辅助栈），我们成功地，将`getMin`操作的时间复杂度，降到了O(1)。”

图书馆的闭馆音乐，已经变成了《友谊地久天长》。女孩们收拾好东西，并肩走出图书馆。月光下，她们的影子被拉得很长。安妮知道，她们在“栈”这座书塔下的探索，已经告一段落。但她也明白，栈的智慧，将像这些经典的题目一样，化为她脑海中，永不磨灭的印记。

---

🌸 **栈应用核心要点** 🌸

**1. 算法设计的根本思想**
- **单调栈模型：** “下一个更大/更小元素”问题，是“单调栈”的典型应用场景。其核心，是维护一个具有单调性的栈，通过与新元素的比较，来处理栈顶元素的“出路”问题。它是一种用O(N)时间，解决一类特定序列问题的强大模型。
- **数据结构的组合与增强：** “最小栈”问题，展现了如何通过“组合”两个基础数据结构（两个栈），来实现一个“增强”的、具有新功能的数据结构。这种“辅助数据结构”的思想，在设计复杂系统时非常常见。
- **空间换时间：** （回顾）无论是哈希表判环，还是辅助栈存最小值，都是“空间换时间”这一永恒主题的体现。我们愿意用可控的额外空间，来换取关键操作的时间效率。

**2. 核心设计哲学**
- **延迟处理（Deferred Processing）：** 单调栈的思想，可以看作是一种“延迟处理”。当一个元素`x`入栈时，我们并不立刻确定它的答案，而是将它“暂存”起来。直到一个比它大的元素`y`出现时，`x`的“命运”（它的下一个更大元素是`y`）才被确定。栈，为这种“延迟决定”提供了完美的机制。
- **状态的同步维护：** 在最小栈的设计中，`data_stack`和`min_stack`的`push`和`pop`操作，必须是严格同步的，以保证在任何时刻，`min_stack`的栈顶，都对应着`data_stack`当前状态下的最小值。这种“状态同步”，是组合数据结构设计的关键。

**3. 算法思维的启发**
- **寻找“单调性”：** 在处理序列问题时，可以思考，问题是否与“单调性”有关？是否可以通过维护一个单调的结构（栈、队列），来优化查找或决策的过程？
- **“冗余”信息的价值：** 最小栈的辅助栈，存储了很多“冗余”的最小值信息。但正是这些“冗余”，使得我们能在主最小值被弹出后，立刻知道“次小值”是多少，从而保证了O(1)的查询。
- **设计你自己的数据结构：** 当标准的数据结构无法满足你复杂的需求时（如O(1)的`getMin`），不要害怕，尝试去“设计”和“组合”你自己的数据结构。这是从“算法使用者”到“算法设计者”的进阶之路。

---

🎀 **安妮的小小日记本**

今晚的解谜游戏，让我对“栈”这位“一根筋”的朋友，有了全新的敬意！

我以前觉得它只会“后进先出”，有点死板。但今天我才发现，正是这份“死板”，才让它在处理“最近相关”的问题时，那么地强大！

“单调栈”就像一个“比武招亲”的擂台。只有强者，才能留在台上。任何新来的挑战者，都会把台上比自己弱的，都打下去。留在台上的，永远是一个从高到低（或从低到高）的“高手序列”！这个想法太酷了！

而“最小栈”，则像一个贴心的“双胞胎”！一个栈负责正常工作，另一个栈，则永远在旁边，小声地、实时地，为它的兄弟，记录着“嘿，到目前为止，我们俩见过的最小值是xxx哦！”。这种默契的配合，真的好有爱！

我发现，每一种数据结构，都有它自己最闪耀的舞台。而我的任务，就是去发现这些舞台，然后，为它们鼓掌！

---

### 今日关键词

- **单调栈 (Monotonic Stack):** （回顾）一种内部元素（从栈底到栈顶）始终保持单调递增或单调递减的栈结构。常用于解决“下一个更大/更小元素”等问题。
- **辅助栈 (Auxiliary Stack):** 在设计新的数据结构时，用于辅助主数据结构，完成特定功能（如记录最小值）的额外栈。
- **数据结构设计 (Data Structure Design):** 指根据特定需求，组合或创造新的数据结构，以实现高效操作的过程。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> （本章的练习题已在3.1和3.3节中详细列出，此处不再重复。请参考之前的推荐列表，并额外挑战以下几道经典题目，以深化对栈应用的理解。）

**额外挑战**
1.  LC 84. Largest Rectangle in Histogram ⭐⭐⭐ —— 柱状图中最大的矩形。单调栈最经典、也最困难的应用之一。通过维护一个单调递增的栈，可以在O(N)时间内，为每个柱子，找到它左边和右边第一个比它矮的柱子，从而确定以它为高的最大矩形面积。
2.  LC 42. Trapping Rain Water ⭐⭐⭐ —— （回顾）接雨水。这道题除了用双指针和DP，也可以用单调栈来解决。维护一个单调递减的栈，当遇到一个比栈顶高的柱子时，就形成了“凹”槽，可以计算接到的雨水。
3.  LC 316. Remove Duplicate Letters ⭐⭐⭐ —— 去除重复字母。要求在去除重复字母后，使得结果的字典序最小。需要用一个栈，来维护一个单调递增的、且符合条件的字符序列，是一个贪心+栈的综合难题。
