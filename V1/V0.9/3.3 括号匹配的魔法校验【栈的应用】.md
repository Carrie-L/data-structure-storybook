### **3.3 括号匹配的魔法校验【栈的应用】**

*"左括号，是许下的一份承诺；右括号，是兑现承诺的印记。栈，便是那忠实的见证者，记录着每一份承诺，并校验着每一次的兑现。"*

在亲手实现了栈的基本操作后，安妮对这个“后进先出”的结构，有了更深的理解。但她还是有些疑惑：“这样一个操作受限的‘瓶子’，到底能在什么地方，派上大用场呢？”

“它的用处，可比你想象的要大得多。”希娅笑道，她在代码编辑器里，打出了一行字符串：`"( { [ ] } ( ) )"`。

“这是一个经典的面试题：**有效的括号**（Valid Parentheses, LC 20）。要求我们判断一个只包含`()[]{}`这六种括号的字符串，是否是‘有效’的。”

“什么是‘有效’呢？”

“很简单，”黛芙解释道，“第一，左括号必须用相同类型的右括号闭合。第二，左括号必须以正确的顺序闭合。比如`'(]'`（类型不匹配）和`'([)]'`（顺序不匹配）都是无效的。”

“这个问题，如果只用循环和一堆判断标记，会非常非常麻烦，很容易把自己绕进去。”黛芙说，“但如果，我们请‘栈’来帮忙，问题就会变得异常简单和优雅。”

#### **栈的解法：承诺与兑现的法则**

伊莎贝尔用一个浪漫的比喻，点明了算法的核心。

“你可以把‘左括号’——`(`, `[`, `{`——看作是许下的一个个‘**承诺**’。”
“而‘右括号’——`)`, `]`, `}`——则是来‘**兑现**’这些承诺的‘**印记**’。”

“我们的‘栈’，就是一本‘**承诺记录簿**’。它严格地、一丝不苟地，记录着我们许下的每一个承诺。”

**算法流程：**

黛芙在白板上，一步步地，清晰地展示了这场“承诺与兑现”的校验过程。

1.  **准备工作:** 创建一个空栈。为了方便，我们可以创建一个哈希表，用于快速查找匹配的括号对。
    `mapping = {")": "(", "]": "[", "}": "{"}`

2.  **开始旅程:** 从左到右，遍历字符串中的每一个字符。

3.  **情景一：遇到左括号 (许下承诺):**
    -   如果当前字符是一个左括号（`(` 或 `[` 或 `{`），我们就将它“**压入**”栈中。
    -   **动作解读:** “我在此刻，许下了一个xx型的承诺，我把它记在我的‘记录簿’的最顶上，等待兑现。”

4.  **情景二：遇到右括号 (兑现承诺):**
    -   如果当前字符是一个右括号（`)` 或 `]` 或 `}`），我们就需要去检查“承诺记录簿”（栈）了。
    -   **检查A (是否有待兑现的承诺？):** 如果此时，栈是空的，说明根本没有人许下过承诺，却有人来“兑现”。这显然是无效的。立刻判定失败，返回`False`。
    -   **检查B (承诺是否匹配？):** 如果栈不为空，我们就从栈顶，“**弹出**”最近的一个承诺（左括号）。然后，将这个弹出的左括号，与我们当前遇到的右括号，进行比对。
        -   如果它们恰好是一对（比如，弹出的是`(`，遇到的是`)`），太好了，承诺完美兑现！我们继续检查下一个字符。
        -   如果它们不匹配（比如，弹出的是`[`，遇到的却是`)`），说明承诺和兑现的印记对不上号。校验失败，立刻返回`False`。

5.  **旅程结束：最终的清算**
    -   当整个字符串都遍历结束后，我们还需要做最后一步检查。
    -   我们查看一下“承诺记录簿”（栈）。如果此时，栈是**空的**，说明所有许下的承诺，都已经被一一完美地兑现了。整个字符串是有效的，返回`True`。
    -   但如果栈**不为空**，则说明有些承诺，直到最后，都还没人来兑现（比如`"((()"`）。这些是未被履行的诺言。字符串是无效的，返回`False`。

#### **代码实现与“实况录像”**

```python
def is_valid_parentheses(s: str) -> bool:
    stack = []
    # 哈希表存储匹配关系，key是右括号，value是左括号
    mapping = {")": "(", "]": "[", "}": "{"}

    for char in s:
        if char in mapping: # 这是一个右括号
            # 弹出栈顶元素，如果栈为空则用一个特殊字符代替，确保不匹配
            top_element = stack.pop() if stack else '#'
            
            # 检查弹出的左括号，是否是当前右括号的匹配项
            if mapping[char] != top_element:
                return False
        else: # 这是一个左括号
            stack.push(char)

    # 最终，当且仅当栈为空时，字符串才是有效的
    return not stack
```

黛芙在白板上，用一个例子 `s = "([{}])"`，进行了“实况录像”。

| 当前字符 | 操作         | 栈的状态 (从底到顶) | 说明                                   |
|------------|--------------|-----------------------|----------------------------------------|
| `(`        | `push('(')`   | `['(']`                | 许下第一个承诺                         |
| `[`        | `push('[')`   | `['(', '[']`            | 许下第二个承诺                         |
| `{`        | `push('{')`   | `['(', '[', '{']`        | 许下第三个承诺                         |
| `}`        | `pop()` -> `{` | `['(', '[']`            | 兑现最近的承诺`{}`，匹配成功        |
| `]`        | `pop()` -> `[` | `['(']`                | 兑现最近的承诺`[]`，匹配成功        |
| `)`        | `pop()` -> `(` | `[]`                  | 兑现最后的承诺`()`，匹配成功        |

**遍历结束，栈为空，最终结果：`True`。**

“太巧妙了！”安妮惊叹道，“栈的‘后进先出’特性，和括号‘最里面的要先闭合’的规则，简直是天作之合！最后遇到的左括号，理应被最先遇到的右括号所闭合！”

“是的，”黛芙总结道，“栈，这种看似简单的结构，正是解决一切具有‘**对称性**’、‘**嵌套性**’、‘**最近相关性**’问题的神器。无论是括号匹配、XML/HTML标签的合法性校验、还是我们马上要回顾的函数调用，其背后，都有栈的身影。”

安妮看着图书馆里，那一摞摞被管理员叠放整齐的书盘。她明白了，那不仅仅是一摞书，那是一个个等待被处理的“承诺”，一个记录着“来时之路”的记忆之塔。而栈的弹出，就是一次次精准的、回到过去的“回溯”。

---

🌸 **栈应用核心要点** 🌸

**1. 算法设计的根本思想**
- **LIFO与嵌套结构：** 具有嵌套或递归性质的问题，通常都有“后处理的需要先解决”的特点。例如，内层括号必须先闭合，内层函数必须先返回。这种特性与栈的LIFO原则，是天然同构的。
- **状态的暂存：** 栈在此类问题中，扮演了一个“暂存状态”或“暂存任务”的角色。每当遇到一个需要“延后处理”的事件（如一个左括号），就将其压入栈中，以便在未来某个时刻，能以正确的顺序，重新取出并处理它。
- **匹配与抵消：** 括号匹配的过程，可以看作是一个“抵消”的过程。一个右括号的出现，会“抵消”掉一个最近的、匹配的左括号。当所有元素都被完美抵消时，问题就解决了。

**2. 核心设计哲学**
- **用简单结构解决复杂规则：** 括号匹配的规则，如果用纯粹的条件判断来描述，会非常复杂。而栈，用一种极其简单的、统一的数据结构操作（`push`/`pop`），就优雅地解决了这个看似复杂的问题。这是数据结构“四两拨千斤”的魅力。
- **哈希表的辅助：** 在这个解法中，使用一个`mapping`哈希表，来存储括号的配对关系，使得“判断是否匹配”这个操作，也变成了O(1)。这是数据结构之间协同工作的又一范例。
- **代码的清晰性：** 使用栈的解法，其代码逻辑，与我们“先承诺、后兑现”的直观思考过程，是完全一致的，具有很高的可读性和可维护性。

**3. 算法思维的启发**
- **识别“对称”和“配对”问题：** 当你遇到任何需要“配对”或检查“对称性”的问题时（如XML标签、代码块的大括号），都应该立刻想到栈。
- **“消除”的思想：** 很多问题，都可以转化为“通过某种操作，不断消除元素，看最后是否能消除干净”的模型。栈，是实现这种“消除”操作的常用工具。
- **历史记录的价值：** 栈为我们提供了一种只记录“待办事项”的、高效的历史记录方式。它不关心那些已经完成并匹配的括号，只关心那些“悬而未决”的左括号。

---

🎀 **安妮的小小日记本**

我宣布，栈，是我目前学过的，最“讲信用”的数据结构！

伊莎贝尔学姐那个“承诺与兑现”的比喻，简直是神来之笔！每一个左括号，都是一个郑重的承诺，被小心翼翼地放进“承诺记录簿”（栈）里。每一个右括号，都是来兑现承诺的信物。它会找到最近许下的那个承诺，看看是不是自己的那一对。如果是，就一起幸福地“抵消”掉；如果不是，或者根本找不到承诺，那就是“欺骗”！

整个过程，就像一个严谨的契约校验系统，逻辑清晰，一丝不苟。最后，只有当记录簿上干干净净，所有的承诺都被兑现了，才算是一个圆满的结局。

我发现，用合适的比喻，去理解一个算法，真的能让它从冰冷的代码，变成一个有温度、有性格的故事。我好像，也慢慢学会了如何去讲这样的“算法故事”了。

---

### 今日关键词

- **括号匹配 (Parentheses Matching):** （回顾）一个经典的计算机科学问题，用于判断一个包含不同类型括号的序列，其括号是否“成对”且“正确嵌套”。
- **对称性 / 嵌套性 (Symmetry / Nesting):** （回顾）指结构或问题中，具有“内层需要先于外层被处理”或“左右对称”等特性。这类问题，通常是栈的用武之地。
- **最近相关性 (Nearest Correlation):** （回顾）指当前的操作，只与“最近”的一个未完成状态相关。在括号匹配中，一个右括号，只与离它最近的那个未闭合的左括号相关。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium
> 建议顺序：通过这些题目，反复练习和巩固栈在“匹配”和“消除”类问题上的应用。

**基础入门（经典应用）**  
1.  LC 20. Valid Parentheses ⭐ —— （回顾）本章的范例，是每个学习栈的人都必须亲手实现的第一道题。
2.  LC 1047. Remove All Adjacent Duplicates In String ⭐ —— （回顾）删除字符串中的所有相邻重复项。其“与栈顶元素比较，相同则弹出，不同则压入”的逻辑，是栈应用的又一核心模式。
3.  LC 1544. Make The String Great ⭐ —— （回顾）与上一题思想完全相同，只是匹配规则更复杂一些。

**进阶巩固（栈的综合应用）**
4.  LC 496. Next Greater Element I ⭐ —— 下一个更大元素 I。使用“单调栈”的入门题。从后往前遍历数组，用一个栈来维护一个“单调递减”的序列，从而能O(1)地找到每个元素右侧的第一个更大元素。
5.  LC 739. Daily Temperatures ⭐⭐ —— （回顾）每日温度。与上一题思想完全相同，只是要求的是“距离”而不是元素本身。是单调栈的经典应用。