### **3.2 压入与弹出【Push & Pop】**

*"每一次的压入，都是一次记忆的封存；每一次的弹出，都是一次过往的重现。于这一进一出之间，栈，便拥有了掌控时间的能力。"*

“我们已经知道了，栈有两个最核心的操作：`push`和`pop`，以及一个辅助的`peek`操作。”在图书馆的一个安静角落，黛芙继续着她们的课程，“理论很简单，但只有亲手实现它，才能体会到其中的细节。今天，我们就来用最常见的‘动态数组’，来构建我们自己的栈。”

“为什么选动态数组呢？”安妮问。

“因为它最方便。”希娅解释道，“像C++的`std::vector`或Python的`list`，它们都封装好了在数组末尾添加和删除元素的操作，这和栈‘只在栈顶操作’的特性，不谋而合。我们几乎可以直接使用。”

#### **用数组实现栈：代码的艺术**

希娅在她的笔记本上，快速地写下了一个极简但完整的Python实现，并加上了详细的注释。

```python
class MyStack:
    """一个基于Python列表实现的简单栈"""

    def __init__(self):
        """构造函数，初始化一个空的内部列表来存储数据。"""
        self.items = []

    def is_empty(self) -> bool:
        """判断栈是否为空。返回True如果栈为空，否则False。"""
        return not self.items

    def push(self, item):
        """压入一个元素到栈顶。"""
        # list的append()方法正好是在列表的末尾（我们定义为栈顶）添加元素。
        # 这个操作在大多数情况下是O(1)的。
        self.items.append(item)

    def pop(self):
        """从栈顶弹出一个元素，并返回它。"""
        if not self.is_empty():
            # list的pop()方法默认就是移除并返回最后一个元素。
            # 这个操作是O(1)的。
            return self.items.pop()
        else:
            # 在栈为空时尝试弹出，是一种错误情况。
            # 我们可以选择返回None，或更严谨地，抛出一个异常。
            raise IndexError("pop from an empty stack")

    def peek(self) -> any:
        """查看栈顶元素，但不移除它。"""
        if not self.is_empty():
            # 直接返回列表的最后一个元素。
            return self.items[-1]
        else:
            return None

    def size(self) -> int:
        """返回栈中元素的数量。"""
        return len(self.items)
```

“看，”希娅解释道，“Python的`list`，它的`append`和`pop`方法，天然地就完美契合了栈的‘后进先出’特性。`append`在列表末尾（我们将其视为‘栈顶’）添加，`pop()`也从列表末尾移除。所以，用它来实现栈，非常简单。”

#### **操作的“实况录像”**

黛芙在白板上，用可视化的方式，一步步地展示了对这个栈进行一系列操作时，其内部`items`数组的变化，以及`top`（栈顶）的移动。

**初始状态:** `s = MyStack()` -> `items = []`

**1. `s.push('A')`**
   - `items` 数组执行 `append('A')`。
   - `items` 变为 `['A']`。
   - 栈顶是 `'A'`。

**2. `s.push('B')`**
   - `items` 数组执行 `append('B')`。
   - `items` 变为 `['A', 'B']`。
   - 栈顶是 `'B'`。

**3. `s.push('C')`**
   - `items` 数组执行 `append('C')`。
   - `items` 变为 `['A', 'B', 'C']`。
   - 栈顶是 `'C'`。

```ascii
// push('C') 之后的状态

items: [ 'A', 'B', 'C' ]
                 ↑
                Top
```

**4. `value = s.pop()`**
   - `items` 数组执行 `pop()`，返回最后一个元素`'C'`。
   - `value` 变量得到 `'C'`。
   - `items` 变回 `['A', 'B']`。
   - 栈顶现在是 `'B'`。

**5. `top_val = s.peek()`**
   - `items` 数组返回最后一个元素`'B'`，但不删除它。
   - `top_val` 变量得到 `'B'`。
   - `items` 保持不变，仍是 `['A', 'B']`。

“非常清晰。”黛芙点头，“`push`和`pop`，永远都只作用于这个线性表的‘同一端’。这就是栈与其他线性表的根本区别。”

“我明白了，”安妮说，“栈就像一个‘死胡同’。车子（数据）开进去，最先开进去的，被堵在最里面，只能等后来的车子，一辆辆地倒出去，它才能出来。”

“非常形象的比喻！”伊莎贝尔笑道，“正是因为这种‘受限’的特性，才赋予了栈在解决特定问题时，独一无二的强大能力。我们马上就会看到，这个简单的‘死胡同’，是如何理清一团乱麻的。”

女孩们围在一起，看着这段简洁的代码和清晰的演示。她们明白了，`push`和`pop`，这两个看似简单的操作，就像是为数据世界，设定了一条不可逾越的、关于“时间”与“顺序”的法则。所有进入这个“死胡同”的数据，都必须遵循“后来者居上，居上者先走”的命运。而这种命运，恰恰是许多复杂算法得以实现的基础。

---

🌸 **栈操作核心要点** 🌸

**1. 算法设计的根本思想**
- **接口的封装：** 通过一个`class`，我们将底层的数组操作（如`append`, `pop`），封装成了具有明确“栈”语义的接口（`push`, `pop`）。这使得代码的意图更清晰，也更安全。
- **动态数组的摊还分析：** 虽然Python的`list`或C++的`vector`在空间不足时，需要进行O(N)的“扩容”操作（分配更大的内存，并迁移数据）。但由于扩容不是每次`push`都发生，通过“摊还分析”，我们可以证明，`push`操作的平均时间复杂度依然是O(1)。
- **错误处理：** 在`pop`或`peek`一个空栈时，必须进行处理。返回`None`或抛出异常，都是合理的选择。在严谨的程序设计中，抛出异常是更推荐的方式，因为它能更明确地暴露程序中的逻辑错误。

**2. 核心设计哲学**
- **LIFO的物理实现：** 无论是用数组末尾，还是用链表头部，我们都是在用一种具体的物理结构，去模拟“栈顶”这个唯一的、抽象的操作点。
- **简单性的力量：** 栈的实现极其简单，这使得它在任何编程语言中，都能被快速、可靠地构建出来。这种简单性，是它被广泛应用的基础。

**3. 算法思维的启发**
- **将数据结构视为“行为”的集合：** 不要只把栈看作是“存东西的容器”，而要把它看作是“定义了一组特定行为（LIFO）的工具”。在思考问题时，问自己：“我需要的是‘后进先出’的行为吗？”如果是，那么栈就是你的选择。
- **理解底层：** 了解`vector`或`list`的`append`和`pop`操作在底层是如何工作的（特别是扩容机制），能让你对栈操作的真实成本，有更深刻的认识。

---

🎀 **安妮的小小日记本**

今天我们亲手“造”了一个栈！

虽然只是用了Python的`list`把它“包装”了一下，但这个过程，让我感觉很不一样。我不再只是一个“使用者”，我成了一个“创造者”！

我为我的“栈”类，定义了`push`，`pop`，`peek`这些专属的操作。就像是给一个普通的瓶子，贴上了“薯片桶”的标签，并规定了“只能从上面拿”的规则。这种“封装”和“定义规则”的感觉，好有成就感！

希娅学姐说，在C++里，`stack`就是一个“容器适配器”，这个词太酷了！它就像一个万能的转接头，能把`vector`或者`deque`这些普通的容器，瞬间变成一个有“栈”脾气的、专业的工具。

我发现，编程的乐趣，不仅在于解决问题，也在于创造这些能解决问题的、优雅的“工具”本身！

---

### 今日关键词

- **Push:** （回顾）向栈顶添加一个新元素的操作。
- **Pop:** （回顾）从栈顶移除并返回最上层元素的操作。
- **Peek / Top:** （回顾）查看栈顶元素，但不移除它的操作。
- **容器适配器 (Container Adapter):** 在C++等语言中，`stack`通常不是一个独立的容器，而是一个“适配器”。它将一个已有的容器（如`vector`, `deque`, `list`）的接口，进行“包装”和“限制”，使其只暴露`push`, `pop`等符合栈特性的接口。
- **摊还分析 (Amortized Analysis):** （回顾）一种评估一系列操作平均成本的分析方法，常用于分析动态数组的扩容等场景。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy
> 建议：通过这些题目，反复练习栈的`push`和`pop`操作，并感受其LIFO特性。

**基础入门（熟悉栈操作）**  
1.  **用链表实现栈** ⭐ —— （回顾）用你之前实现的单向链表，来实现一个栈。思考一下，用链表的“头部”还是“尾部”作为栈顶，效率更高？为什么？
2.  LC 1047. Remove All Adjacent Duplicates In String ⭐ —— 删除字符串中的所有相邻重复项。可以用一个栈来解决。遍历字符串，如果当前字符与栈顶元素相同，就弹出栈顶；如果不同，就压入当前字符。最终栈中剩下的字符，就是结果。
3.  LC 1544. Make The String Great ⭐ —— 整理字符串。与上一题非常相似，只是判断条件变成了“两个相邻的大小写字母”。同样是栈的经典应用。
4.  LC 682. Baseball Game ⭐ —— 棒球比赛。根据一系列操作（数字、`+`、`D`、`C`）计算总分。`C`（撤销）和`D`（双倍）操作，都只与“前一轮”的得分有关，这强烈地暗示了栈的LIFO特性。