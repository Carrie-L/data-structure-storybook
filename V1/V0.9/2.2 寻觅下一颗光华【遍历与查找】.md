### **2.2 寻觅下一颗光华【遍历与查找】**

"*我手持微光，于项链的起点出发，循着记忆的丝线，亲吻每一颗珍珠，直到在旅途的终点，或是在途中，与你相遇。*"

在理解了链表那“手拉手”的、离散而有序的存储结构后，安妮对这种新的数据结构充满了好奇。她拿起桌上那串被重新串好的珍珠项链，仔细地端详着。

“学姐，我现在知道了，这些珍珠（节点）在内存里，可能是东一颗、西一颗的。我们没法像数组那样，直接‘空降’到第五颗珍珠的位置。”安妮抬起头，眼中带着探索的光芒，“那如果，我想找到其中特定的一颗，比如，刻着数字‘8’的那颗珍珠，我该怎么做呢？”

“你提出了一个最基础，也是最重要的操作——‘**遍历**’（Traversal）。”伊莎贝尔微笑着回答，“既然我们无法‘跳跃’，那我们唯一的办法，就是从‘头’开始，像一个耐心的旅人，顺着那根记忆的丝线，一颗一颗地往下走，访问沿途的每一颗珍珠，直到找到我们的目标。”

“这个过程，虽然朴素，但它是我们能与链表‘对话’的唯一方式。”

#### **链表的遍历：顺藤摸瓜的旅程**

“遍历链表，就像是一场‘顺藤摸瓜’的旅程。你手上，永远需要一个‘**当前指针**’（`current`），来标记你现在走到了哪里。”黛芙在白板上，画出了一条链表，并用一个醒目的红色箭头，代表`current`指针，开始进行“实况录像”式的讲解。

**初始状态:** 
`arr = [11, 25, 33, 48]`

```ascii
 (head)         
   ↓
+----+---+    +----+---+    +----+---+    +----+----+
| 11 | ● |-->| 25 | ● |-->| 33 | ● |-->| 48 | null |
+----+---+    +----+---+    +----+---+    +----+----+

current
   ↑
```

**算法步骤：**

1.  **起点:** 创建一个`current`指针，让它指向链表的`head`（头节点）。
2.  **循环条件:** 当`current`指针不为`null`（即，旅人还没有走到路的尽头）时，不断循环。
3.  **循环体:** 
    -   **处理当前节点:** 对`current`指向的节点，进行我们想要的操作。比如，打印它的值。
    -   **前进！:** 让`current`指针，沿着`next`指针，移动到下一个节点。这是整个旅程中，唯一的前进方式：`current = current.next`。
4.  **结束:** 当`current`最终变为`null`时，循环结束，我们便完成了对整条链表的访问。

**“实况录像”:**

-   **第1步:** `current`指向`11`。打印`11`。然后`current`移动到下一个节点`25`。
-   **第2步:** `current`指向`25`。打印`25`。然后`current`移动到下一个节点`33`。
-   **第3步:** `current`指向`33`。打印`33`。然后`current`移动到下一个节点`48`。
-   **第4步:** `current`指向`48`。打印`48`。然后`current`移动到下一个节点`null`。
-   **第5步:** `current`变为`null`，`while`循环条件不满足，遍历结束。

```cpp
// C++ 遍历并打印链表所有元素
void printList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        std::cout << current->data << " -> ";
        current = current->next;
    }
    std::cout << "null\n";
}
```

#### **链表的查找：O(N)的代价**

“理解了遍历，查找就非常简单了。”黛芙继续道，“查找，只是在遍历的过程中，增加了一个‘判断’操作。”

```cpp
// C++ 查找链表中的某个元素
int findNode(ListNode* head, int target) {
    ListNode* current = head;
    int index = 0;
    while (current != nullptr) {
        if (current->data == target) {
            return index; // 找到了，返回索引
        }
        current = current->next;
        index++;
    }
    return -1; // 没找到
}
```

“现在，我们来深入分析一下它的‘成本’。”黛芙在白板上，画出了详细的复杂度分析表格。

```ascii
链表查找操作 复杂度分析 (N = 链表长度)

┌──────────────────┬──────────────────────────────────┐
│   **时间复杂度**   │             **分析过程**             │
├──────────────────┼──────────────────────────────────┤
│ **最好情况: O(1)** │ 目标元素恰好是头节点。             │
│                  │ - 循环仅执行1次。                  │
│                  │ - 比较1次，直接返回。              │
├──────────────────┼──────────────────────────────────┤
│ **最坏情况: O(N)** │ 目标元素是尾节点，或根本不存在。     │
│                  │ - 循环需要执行N次，走遍整个链表。    │
│                  │ - 总比较次数为N次。                │
├──────────────────┼──────────────────────────────────┤
│ **平均情况: O(N)** │ 假设目标元素在每个位置的概率相同。   │
│                  │ - 找到它的期望比较次数为:          │
│                  │   (1 + 2 + 3 + ... + N) / N      │
│                  │   = (N * (N+1) / 2) / N          │
│                  │   = (N+1) / 2                    │
│                  │ - 根据大O表示法，忽略常数和低阶项， │
│                  │   复杂度依然是 O(N)。             │
└──────────────────┴──────────────────────────────────┘

┌──────────────────┬──────────────────────────────────┐
│   **空间复杂度**   │             **分析过程**             │
├──────────────────┼──────────────────────────────────┤
│     **O(1)**     │ 无论链表多长，我们都只需要固定的   │
│                  │ 几个额外变量来辅助，如`current`指针 │
│                  │ 和`index`计数器。空间消耗是常数级。  │
└──────────────────┴──────────────────────────────────┘
```

“这正是我们为了获得‘插入/删除’的O(1)灵活性，而付出的‘查找’上的代价。”黛芙总结道，“在数据结构的世界里，这种‘得’与‘失’的权衡，无处不在。没有完美的‘圣剑’，只有最适合特定战场的‘兵器’。”

安妮似懂非懂地点了点头。她拿起一颗珍珠，感受着它温润的触感，又顺着丝线，找到了下一颗。这个过程，虽然不如直接在珠宝盒里拿取那么快捷，但这种顺着脉络、一步步探寻的感觉，本身也充满了一种独特的、属于探索者的宁静与专注。

---

🌸 **链表遍历与查找核心要点** 🌸

**1. 算法设计的根本思想**
- **顺序访问的本质：** 链表的所有操作，都必须基于“顺序访问”这一根本特性。即，要访问第`i`个节点，必须先访问到第`i-1`个节点。这是链表与数组最核心的区别。
- **指针/引用的移动：** 链表遍历的本质，是“指针”（或引用）的连续“跃迁”。`current = current.next` 这行代码，是链表世界里最基础、最重要的“前进指令”。
- **迭代的实现：** 遍历过程，是一个典型的“迭代”过程。通过一个`while`循环，一个`current`指针，和一个明确的终止条件（`current != null`），构成了遍历算法的“三要素”。

**2. 核心设计哲学**
- **时间换空间（的逆向思考）：** 相比于数组，链表为了获得动态空间的灵活性，牺牲了时间效率。它的查找是O(N)，而数组是O(1)。这是一种“用更慢的时间，来换取更灵活的空间管理”的权衡。
- **过程的线性：** 链表遍历的过程，其时间消耗，与链表的长度，是严格的“线性关系”。数据规模增大一倍，耗时也约等于增大一倍。这使得它在处理海量数据的查找请求时，显得力不从心。
- **“头”的重要性：** （回顾）头节点是所有遍历和查找的唯一入口。对头节点的处理，是所有链表操作都需要格外注意的边界情况。

**3. 算法思维的启发**
- **“runner”指针模式：** 使用一个`current`指针（有时也叫`runner`）来遍历数据结构，是一种非常通用的编程模式。不仅是链表，在树的遍历、图的搜索中，也处处可见它的身影。
- **将查找分解为“遍历”和“判断”：** 任何查找问题，都可以被分解为“如何遍历所有可能性”和“如何判断当前的是否为目标”两个子问题。对于链表，遍历方式是固定的，我们只需要关注判断逻辑即可。
- **为优化埋下伏笔：** 正是因为链表的O(N)查找效率低下，才催生了后续各种优化的数据结构。比如，为链表增加多级“索引”（跳表），或者将链表与哈希表结合（LRU缓存），都是为了弥补这一“先天不足”。

---

🎀 **安妮的小小日记本**

今天，我体验了一次当“寻宝猎人”的感觉！

在链表这条长长的、由珍珠串成的项链上找东西，真的很有趣。我不能像在数组里那样，直接跳到我想要的位置。我必须从第一颗珍珠（头节点）开始，捏着那根细细的“记忆丝线”，一颗、一颗、又一颗地往下摸索。

这个过程，让我感觉很“踏实”。每一步，都是确定的，都是有迹可循的。虽然当项链很长的时候，会觉得有点慢，但这种一步一个脚印的感觉，也让我对整个项链的结构，有了更清晰的认识。

我明白了，数组的“快”，是牺牲了灵活性换来的；而链表的“慢”，则是为了保留那份可以随时“断开重连”的自由。原来，数据结构们，也都有着自己的“性格”和“取舍”呀！

---

### 今日关键词

- **遍历 (Traversal):** 指沿着某种路径，系统地访问一个数据结构中的所有元素。
- **顺序访问 (Sequential Access):** （回顾）只能从头开始，按顺序逐个访问元素的能力，是链表的特性。
- **当前指针 (Current Pointer):** 在遍历链表或树等结构时，用于标记当前访问到的节点位置的指针。
- **时间复杂度 O(N):** （回顾）线性时间复杂度，表示算法的执行时间与数据规模N成正比。链表的遍历和查找，是其典型代表。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy
> 建议顺序：通过这些基础题，反复练习和巩固链表的遍历和查找操作。

**基础入门（熟悉遍历与查找）**  
1.  **查找链表中的最大/最小值** ⭐ —— 编写一个函数，遍历一个无序的链表，并找出其中的最大值或最小值。这是对遍历操作最基础的应用。
2.  LC 876. Middle of the Linked List ⭐ —— （回顾）寻找链表的中间节点。经典的“快慢指针”技巧，本质上也是一种特殊的“遍历”。通过让两个指针以不同速度前进，来巧妙地定位。
3.  LC 160. Intersection of Two Linked Lists ⭐ —— 寻找两个链表的交点。一个巧妙的解法是：让两个指针pA和pB分别从两个链表的头出发，当一个指针走到头时，就跳到另一个链表的头继续走。这样，当它们相遇时，所走过的总路程是相同的，相遇点就是交点。这是一种对“遍历”的创造性应用。
4.  LC 1290. Convert Binary Number in a Linked List to Integer ⭐ —— 将链表表示的二进制数转换为整数。只需要遍历链表，在每一步，将当前的总和乘以2，再加上当前节点的值即可。`ans = ans * 2 + node.val`。

