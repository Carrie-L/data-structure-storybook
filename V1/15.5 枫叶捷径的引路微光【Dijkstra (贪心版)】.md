### **15.5 枫叶捷径的引路微光【Dijkstra (贪心版)】**

*"不必知晓全局的地图，只需追随脚下那束最亮的微光。每一步都踏向最近的彼岸，终将抵达最遥远的远方。"*

在探讨了部分背包问题中那纯粹的贪心选择后，安妮对贪心算法“优先选择当前最优”的策略有了更深的体会。她们的露营即将结束，正沿着一条铺满金色枫叶的小径下山。

“说起来，”安妮突然想起，“我们之前在图论里学的戴克斯特拉（Dijkstra）算法，用来找单源最短路径。它的过程，好像也很有‘贪心’的味道。”

“哦？”黛芙很惊喜安妮能有这样的联想，“说说看，你觉得它哪里‘贪心’了？”

“我记得，Dijkstra算法有一个‘距离数组`dist`’和一个‘已确定最短路径的节点集合`S`’。”安妮努力回忆着，“它的核心步骤是，每一次，都从‘尚未确定’的节点中，选择那个`dist`值最小的节点，加入到集合`S`中。然后，再用这个新加入的节点，去更新它的邻居们的`dist`值。”

“这个‘每次都选择当前距离起点最近的节点’的操作，”安妮的眼睛亮了起来，“不就是一种贪心选择吗？它相信，当前离起点最近的那个节点，它的最短路径，已经不可能再被其他任何路径更新了，所以就‘贪心’地把它确定下来。”

“完全正确！”黛芙的赞赏溢于言表，“安妮，你已经洞察了Dijkstra算法的本质。它就是一个非常成功、非常经典的贪心算法！”

#### **Dijkstra的贪心内核**

“我们来回顾一下Dijkstra的执行过程，并从‘贪心’的角度来解读它。”黛芙在白板上画了一个简单的带权图。

```ascii
  A --4-- B --2-- C
  | \     |     / |
  2  1    3   1   5
  |   \   |   /   |
  D --5-- E --2-- F

起点: A
```

**初始化:**
-   `dist = {A:0, B:inf, C:inf, D:inf, E:inf, F:inf}`
-   `S = {}` (已确定最短路径的集合)
-   优先队列 `pq = [(0, A)]`

**贪心过程:**

1.  **第一次贪心选择:**
    -   从`pq`中取出距离最小的 `(0, A)`。
    -   将`A`加入`S`。`S = {A}`。
    -   **局部最优:** `A`离起点最近（距离为0），贪心地认为`A`的最短路径就是0。
    -   **更新邻居:** 更新B, D, E的距离。`dist`变为`{A:0, B:4, D:2, E:1, ...}`。`pq`中加入`(4,B), (2,D), (1,E)`。

2.  **第二次贪心选择:**
    -   从`pq`中取出距离最小的 `(1, E)`。
    -   将`E`加入`S`。`S = {A, E}`。
    -   **局部最优:** 在所有未确定的节点中，`E`离起点最近（距离为1），贪心地认为`E`的最短路径就是1。
    -   **更新邻居:** 用`E`去更新B, D, F的距离。
        -   到B: `dist[E]+3 = 1+3=4`。`dist[B]`已经是4，不更新。
        -   到D: `dist[E]+5 = 1+5=6`。`dist[D]`是2，不更新。
        -   到F: `dist[E]+2 = 1+2=3`。`dist[F]`是inf，更新为3。

3.  **第三次贪心选择:**
    -   从`pq`中取出距离最小的 `(2, D)`。
    -   将`D`加入`S`。`S = {A, E, D}`。
    -   **局部最优:** 在B, C, F等节点中，`D`离起点最近（距离为2），贪心地认为`D`的最短路径就是2。
    -   ...

“Dijkstra算法的每一步，都在做一个看似‘短视’但实际上无比正确的决策：**在所有从起点可达但路径尚未确定的顶点中，下一个被确定的，一定是其中路径最短的那个。**”

#### **贪心，为何在此正确？**

“可是，为什么这个贪心选择是对的呢？”安妮提出了那个熟悉的关键问题，“有没有可能，我们先绕一条更远的路，结果反而能找到一条通往某个节点的、更短的总路径呢？”

“问得好。Dijkstra的贪心之所以正确，有一个至关重要的前提条件：**图中所有的边的权重，都必须是非负的（大于等于0）。**”

黛芙开始进行反证法的说明：“假设这个贪心选择是错的。比如，在上面的第二步，我们贪心地选择了`E`（路径A->E，长度1），并认为这是`A`到`E`的最短路径。但假设存在一条更短的路径，它没有直接走A->E，而是绕道某个我们还没访问过的节点`X`，即 `A -> ... -> X -> ... -> E`，并且这条路径总长度小于1。”

“因为边的权重都是非负的，所以从`A`到`X`的路径长度，必然小于整条`A...E`的路径长度，也就必然小于1。如果是这样，那么在我们的第二次贪心选择中，我们应该选中的就是`X`，而不是`E`，因为`X`离起点更近。这与我们‘选择了E’这个事实相矛盾。”

“所以，结论是：**一旦一个节点被Dijkstra算法选中，就意味着我们已经找到了从起点到它的、无可辩驳的最短路径。**”

“我明白了！”安妮恍然大悟，“正是因为‘边权非负’这个金科玉律，保证了我们的小步快跑不会‘抄后路’。我们每迈出的一小步，都是坚实、不可动摇的一步。绕远路，只会让总距离变得更长，绝不可能缩短。”

#### **贪心与DP的再对比**

“Dijkstra算法，也完美地体现了贪心和DP的联系与区别。”伊莎贝尔总结道。

-   **最优子结构:** 它显然满足。`A`到`F`的最短路径，如果经过`E`，那么`A`到`E`的部分也必然是最短的。
-   **贪心选择 vs. DP:**
    -   一个求解单源最短路径的、更通用的算法叫做Bellman-Ford（我们将在图论进阶中学习），它能处理负权边。它的思想更接近DP，会对所有的边进行反复的“松弛”操作，不断更新距离，直到没有更新发生。它考虑了所有可能的路径组合。
    -   而Dijkstra则不等，它在每一步都“贪心”地做出“这个点的最短路径已经确定了”的断言，然后就把它作为“基石”，去更新其他的点。它没有去探索所有的可能性，而是相信自己的每一步局部最优选择。

下山的枫叶小径，在夕阳的照射下，仿佛一条通往远方的、闪着金光的捷径。安妮明白了，Dijkstra算法，就是在这错综复杂的路径网络中，为我们点亮前路的那一束最亮的、指引我们做出最佳选择的“引路微光”。

---

🌸 **贪心算法核心要点** 🌸

**1. 算法设计的根本思想**
- **扩展的边界：** Dijkstra算法可以看作是一个“扩展边界”的过程。从起点开始，最短路径的“确定”区域像一个不断膨胀的气泡，每次膨胀，都是将离起点最近的那个边界点，纳入到气泡内部。
- **优先级的应用：** 算法的核心，是“如何快速找到下一个距离最近的节点”。优先队列（最小堆）是实现这一点的最佳数据结构，它将“寻找最小值”的线性扫描操作，优化到了O(logN)，是算法高效的关键。
- **正确性的基石：** “边权非负”是Dijkstra贪心策略能够成立的绝对基石。一旦图中出现负权边，整个贪心选择的逻辑就会崩溃，必须使用更复杂的、基于动态规划思想的算法（如Bellman-Ford或SPFA）来求解。

**2. 核心设计哲学**
- **从特殊到一般：** Dijkstra可以看作是图论最短路径问题的一个“特例”解。它针对“无负权边”这一特殊情况，给出了一个比通用解（如Bellman-Ford）高效得多的贪心方案。
- **贪心与DP的统一：** 最短路径问题，本身具有最优子结构，是可以用DP求解的。Dijkstra算法的贪心策略，可以被看作是在无负权边这个特殊条件下，对通用DP解法的一种高效优化。这说明了贪心和DP在底层思想上的相通性。
- **算法的证明：** Dijkstra正确性的反证法，是算法分析中的一个经典范例。它教会我们，在证明一个贪心策略时，核心是论证“做出这个贪心选择后，我们不会失去得到全局最优解的可能性”。

**3. 算法思维的启发**
- **寻找问题中的“不变式”：** Dijkstra算法中，“集合S中所有顶点的最短路径都已经确定”是一个循环不变式。在算法的每一步，我们都在维护和扩展这个不变式。
- **模型的泛化：** Dijkstra的思想，不仅可以用来求“距离”，还可以用来求任何满足类似“松弛”操作的“最优路径”问题，例如网络路由中寻找延迟最低的路径，或者状态空间中寻找成本最低的转换路径等。
- **再次审视前提：** 学习Dijkstra让我们深刻地认识到，在使用任何一个算法之前，都必须严格检查其“前提条件”。忽略了“边权非负”，就会导致算法给出完全错误的结果。

---

🎀 **安妮的小小日记本**

今天真是神奇的一天，我和一位“老朋友”——Dijkstra算法——重新认识了一下！

以前学图论的时候，我只是把它当作一个固定的菜谱，一步步照着做。但今天，从“贪心”的角度再去看它，感觉完全不一样了！它不再是冷冰冰的步骤，而是一个充满智慧的探险家。

这个探险家，永远只选择脚下那条看起来最短、最安全的路。虽然看起来有点“短视”，但因为地图上（图中）没有“陷阱”（负权边），所以他这种最稳妥的走法，最终竟然真的就是最快的！

这让我明白，原来很多算法的内核是相通的。Dijkstra算法既是图论的，也是贪心的。就像伊莎贝尔学姐，她既是计算机系的高材生，也是一位温柔的文学少女。从不同的角度去看，就能发现她们身上不同的闪光点。算法，也是如此！

---

### 今日关键词

- **Dijkstra算法:** 一种用于计算带权图中单源最短路径的经典算法，其核心思想是贪心。
- **单源最短路径 (Single-Source Shortest Path, SSSP):** 在图中，计算从一个指定的源点，到所有其他顶点的最短路径的问题。
- **边权非负 (Non-negative Edge Weights):** Dijkstra算法能够保证其正确性的一个关键前提条件。
- **松弛操作 (Relaxation):** 在最短路径算法中，通过一个新发现的路径，来更新一个顶点当前已知最短距离的过程。例如 `if dist[u] + weight(u,v) < dist[v]: dist[v] = ...`。
- **Bellman-Ford算法:** 一种更通用的单源最短路径算法，可以处理带负权边的情况，其思想更接近动态规划。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（经典模型练习）**  
1.  **手动实现Dijkstra** ⭐⭐ —— 使用优先队列，亲手实现Dijkstra算法。这是理解其贪心选择和松弛过程的最好方法。
2.  LC 743. Network Delay Time ⭐⭐ —— （回顾）网络延迟时间。这是Dijkstra算法最直接、最标准的应用模板题。

**进阶巩固（模型变种与应用）**  
3.  LC 1514. Path with Maximum Probability ⭐⭐ —— 概率最大路径。将边权定义为“通过概率”，我们需要寻找一条从起点到终点“概率乘积最大”的路径。可以通过取对数，将“乘积最大”转化为“和最大”，再稍作变形，就可以套用Dijkstra算法。这是对模型进行巧妙变换的好例子。
4.  LC 1631. Path With Minimum Effort ⭐⭐ —— 最小体力消耗路径。要求找到一条从左上角到右下角的路径，使其“路径上相邻格子之间高度差的最大值”最小。这个问题可以看作一个最短路径问题，其中边的权重是“高度差”，然后用Dijkstra来求解。
5.  **带负权边的Dijkstra** ⭐⭐ —— 思考题。构造一个包含负权边的图，并手动执行Dijkstra算法，观察它在哪个环节会出错，从而深刻理解“边权非负”这个前提的重要性。
