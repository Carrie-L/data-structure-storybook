### **14.5 弦音共鸣的最长序列【LCS / LIS】**

*"两段独立的旋律，于交错的时空中，寻找那段最长的、心有灵犀的共鸣。这，是序列的宿命，亦是DP的诗篇。"*

在体验了0-1背包问题中那精妙的“取舍”智慧后，女孩们对二维DP的威力有了更深的认识。夜色更深，篝火的噼啪声和林间的虫鸣交织成一首宁静的交响乐。

“DP真是太强大了，”安妮感叹道，“它能解决最优决策问题，比如背包。那它还能解决其他类型的问题吗？”

“当然，”黛芙回答，“动态规划的应用领域非常广泛。除了我们刚才接触的‘最优选择’模型（如背包），另一大类经典问题，是‘序列比对’模型。比如，在生物学上比对两段DNA序列的相似度，或者在代码版本控制中，比对两份代码的差异。”

伊莎贝尔拿出她的尤克里里，轻轻拨动了两段不同的旋律。“听，这是两段独立的旋律。如果我们想知道，它们之间最核心的、共同的乐句是什么，我们该怎么做？这个问题，就引出了序列DP中最经典的一个问题——‘**最长公共子序列**’（Longest Common Subsequence, LCS）。”

#### **最长公共子序列 (LCS)**

“首先，我们要分清‘子序列’和‘子串’。”黛芙强调，“‘子串’必须是连续的，而‘子序列’可以不连续，但要保持原始的相对顺序。例如，对于`ace`，它是`abcde`的子序列，但不是子串。”

**问题：** 给定两个字符串 `text1` 和 `text2`，返回它们的最长公共子序列的长度。
例如: `text1 = "abcde"`, `text2 = "ace"` -> LCS是`"ace"`，长度为3。

“这个问题，同样具有DP的两个核心特性。”

1.  **最优子结构:** 两个完整字符串的LCS，包含了它们“前缀”的LCS。
2.  **重叠子问题:** 在递归求解中，会大量重复计算两个字符串不同前缀的LCS。

**状态定义 (State):**
`dp[i][j]` 代表：`text1`的前`i`个字符（`text1[0...i-1]`）与`text2`的前`j`个字符（`text2[0...j-1]`）的最长公共子序列的长度。

**状态转移方程:**
“当我们站在`dp[i][j]`时，我们关注的是`text1[i-1]`和`text2[j-1]`这两个‘末尾’字符。”

-   **情况1：如果 `text1[i-1] == text2[j-1]`**
    -   “太棒了！我们找到了一个公共字符。那么，当前的LCS长度，就等于‘它们各自去掉这个末尾字符后’的LCS长度，再加1。”
    -   **`dp[i][j] = dp[i-1][j-1] + 1`**

-   **情况2：如果 `text1[i-1] != text2[j-1]`**
    -   “这两个末尾字符不匹配。那么，`text1[0...i-1]`和`text2[0...j-1]`的LCS，就无法同时包含`text1[i-1]`和`text2[j-1]`。它只能是以下两种情况中，那个更长的结果：”
        -   `text1`去掉末尾字符后，与`text2`的LCS，即 `dp[i-1][j]`
        -   `text2`去掉末尾字符后，与`text1`的LCS，即 `dp[i][j-1]`
    -   **`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`**

通过自底向上地填充这张二维DP表，`dp[len(text1)][len(text2)]`就是最终的答案。

#### **最长递增子序列 (LIS)**

“序列DP的另一个经典问题，是‘**最长递增子序列**’（Longest Increasing Subsequence, LIS）。”希娅在屏幕上展示了题目。

**问题：** 给定一个整数数组 `nums`，找到其中最长严格递增子序列的长度。
例如: `nums = [10, 9, 2, 5, 3, 7, 101, 18]` -> LIS是`[2, 3, 7, 101]`或`[2, 5, 7, 101]`等，长度为4。

“这个问题，我们也可以用DP来解决。”黛芙说。

**状态定义 (State):**
`dp[i]` 代表：以 `nums[i]` 这个元素**结尾**的最长递增子序列的长度。

“这个状态定义非常关键，”黛芙强调，“它和我们之前遇到的`dp[i]`代表‘前i个元素’的解不同。这里的`dp[i]`绑定了`nums[i]`必须被选中。”

**状态转移方程:**
“当我们计算`dp[i]`时，我们正在思考，以`nums[i]`结尾的LIS，能有多长？”

-   “首先，它自己本身就构成了长度为1的LIS。” -> `dp[i] = 1`
-   “然后，我们向前看，遍历所有在`i`之前的元素`nums[j]` (其中 `j < i`)。”
-   “如果 `nums[i] > nums[j]`，这意味着`nums[i]`可以接在以`nums[j]`结尾的那个LIS的后面，形成一个更长的LIS。这个新形成的LIS长度是 `dp[j] + 1`。”
-   “我们需要遍历所有可能的`j`，并找出那个能让`dp[j] + 1`最大的值。”

**`dp[i] = max(dp[j] + 1)`**  (对于所有 `0 <= j < i` 且 `nums[i] > nums[j]`)

**最终答案:**
“因为`dp[i]`只代表以`nums[i]`结尾的LIS长度，而整个数组的LIS，可能在任何一个位置结尾。所以，最终的答案，是所有`dp[i]`中的最大值。”
**`result = max(dp)`**

```python
def length_of_lis(nums: list[int]) -> int:
    if not nums:
        return 0
    
    n = len(nums)
    dp = [1] * n # 每个元素自身至少构成长度为1的LIS
    
    for i in range(n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
                
    return max(dp)
```

“这个解法的时间复杂度是O(N²)，”黛芙补充道，“对于LIS问题，还有一个非常巧妙的、利用‘耐心排序’思想和二分查找的O(N logN)解法，但我们今天先专注于理解这个更经典的DP思路。”

篝火的光芒将女孩们的影子投在身后的帐篷上，摇曳不定。安妮感觉，序列DP就像是在一维的时间线上，进行着二维的思考。`dp[i]`的解，不仅与`i`有关，更与所有`i`之前的历史状态`dp[j]`息息相关。这是一种更复杂、更精妙的“时空交织”的智慧。

---

🌸 **动态规划核心要点** 🌸

**1. 算法设计的根本思想**
- **二维关联：** LCS问题通过一个二维`dp`表，建立了两个序列之间的关联。`dp[i][j]`这个状态，同时包含了来自两个序列的信息，其转移过程，体现了两个序列的“对齐”与“错位”。
- **历史依赖：** LIS问题的`dp[i]`，依赖于所有`j<i`的`dp[j]`状态。这与之前爬楼梯问题只依赖于前一两个状态不同，它体现了当前决策可能与所有“历史”最优决策相关联的复杂性。
- **状态定义的艺术：** LIS的状态定义`dp[i]`为“以`nums[i]`结尾的LIS”，而不是“前`i`个元素的LIS”，是解决该问题的神来之笔。一个恰当的状态定义，是解出状态转移方程的关键。

**2. 核心设计哲学**
- **从子序列到最优解：** 序列DP问题，通常是在一个或多个序列中，寻找满足某种性质的“最优子序列”。DP通过系统性地构建所有可能子问题的最优解，来确保最终能找到全局最优解。
- **时间复杂度的权衡：** LIS的O(N²)解法，直观且容易理解。而O(N logN)的解法，虽然更高效，但思想更抽象，代码也更难实现。这体现了在“可理解性”和“极致性能”之间的权衡。
- **问题的泛化：** LCS的思想，是许多更复杂问题的基础，如“编辑距离”（Edit Distance），即从一个字符串转换到另一个字符串所需的最少操作次数。它们都使用二维DP来比对两个序列。

**3. 算法思维的启发**
- **寻找“最后一步”的不同：** 在思考LCS的状态转移时，我们分析了`text1[i-1]`和`text2[j-1]`“相等”与“不相等”这两种情况。这种对“最后一步”进行分类讨论，是推导状态转移方程的常用技巧。
- **重新定义问题：** LIS的巧妙之处在于，它没有直接去求“全局的LIS”，而是去求“以每个元素结尾的LIS”，最后再从这些“局部最优”中，找出“全局最优”。这种“迂回”的思考方式，在DP中非常重要。
- **DP与其他算法的结合：** LIS的O(N logN)解法，将DP思想与二分查找结合起来，创造了更高的效率。这预示着，在解决复杂问题时，我们往往需要融合多种算法思想。

---

🎀 **安妮的小小日记本**

今晚的篝火夜话，我们聊到了“序列”。

LCS（最长公共子序列）问题，让我想起了和朋友对歌词。我们可能唱的不是同一首歌，但总有那么几句歌词是重合的，LCS就是在寻找那段最长的、我们都会唱的“共鸣”。那个二维`dp`表，就像一张对账单，记录着两首歌在每个节点上的匹配程度。

LIS（最长递增子序列）问题，则更像是在玩跳一跳游戏。我站在一个格子上，就要回头看看，我能从前面哪个比我低的格子上跳过来，才能让我这一步跳得最远。`dp`数组记录了到达每个格子的最远步数，而我，就是要从所有记录里，找到那个最厉害的！

感觉序列DP，比之前的DP要更抽象一些，特别是状态的定义，需要更多的“灵感”。但一旦定义对了，后面的状态转移，就变得水到渠成了。这大概就是DP的魅力吧，最难的，也是最关键的，永远是第一步的“思考与定义”。

---

### 今日关键词

- **序列DP (Sequence DP):** 一类动态规划问题，其状态通常与一个或多个序列的子结构（如前缀、子序列）相关。
- **最长公共子序列 (LCS - Longest Common Subsequence):** 在两个或多个序列中，找到一个最长的、在所有序列中都以相同相对顺序出现的子序列。
- **子序列 (Subsequence):** 一个序列中，通过删除零个或多个元素，而不改变其余元素相对顺序，得到的新序列。
- **最长递增子序列 (LIS - Longest Increasing Subsequence):** 在一个序列中，找到一个最长的、元素严格递增的子序列。
- **编辑距离 (Edit Distance):** 也称Levenshtein距离，指两个字符串之间，由一个转换成另一个所需的最少编辑操作（插入、删除、替换）次数。是LCS问题的经典扩展。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（经典模型练习）**  
1.  LC 1143. Longest Common Subsequence ⭐⭐ —— LCS问题的标准模板题，是练习二维序列DP的必做题。
2.  LC 300. Longest Increasing Subsequence ⭐⭐ —— LIS问题的标准模板题。先用O(N²)的DP方法实现，再挑战O(N logN)的解法，可以加深理解。
3.  LC 53. Maximum Subarray ⭐⭐ —— （回顾）这道题的O(N)解法，本身就是一种简单的序列DP。`dp[i]`定义为“以`nums[i]`结尾的最大子数组和”，状态转移方程为`dp[i] = max(nums[i], nums[i] + dp[i-1])`。

**进阶巩固（模型变种与应用）**  
4.  LC 72. Edit Distance ⭐⭐⭐ —— 编辑距离问题，LCS的终极升级版。`dp[i][j]`定义为`word1`的前`i`个字符和`word2`的前`j`个字符之间的最小编辑距离。状态转移需要同时考虑“插入”、“删除”、“替换”三种操作，是二维DP的集大成者。
5.  LC 5. Longest Palindromic Substring ⭐⭐ —— 最长回文子串。`dp[i][j]`可以定义为“字符串从`i`到`j`的子串是否是回文串”。状态转移方程为`dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]`。
6.  LC 10. Regular Expression Matching ⭐⭐⭐ —— 正则表达式匹配。DP状态`dp[i][j]`定义为“`text`的前`i`个字符是否能被`pattern`的前`j`个字符匹配”，状态转移需要仔细处理 `.` 和 `*` 两种特殊字符，是DP问题中逻辑极其复杂的代表。
