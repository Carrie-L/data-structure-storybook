### **15.4 撒金币游戏【部分背包】**

*"不必执着于宝箱的完整，只需将金沙洒满行囊。当宝物可以分割，贪心便拥有了它最闪耀的舞台。"*

在学习了精巧的霍夫曼编码后，安妮对贪心算法“优先处理最优部分”的思想有了更深的理解。篝火旁，希娅突然想起了之前讨论过的背包问题。

“学姐们，我们之前用动态规划，解决了那个复杂的0-1背包问题。”希娅说，“每件物品要么拿，要么不拿。那如果……这些物品可以被分割呢？”

她拿起一袋金平糖，倒在手里。“比如，我们不是在装水壶、书本这些不可分割的东西，而是在装金沙、银沙、铜沙。背包的容量有限，我们该怎么装，才能让总价值最高？”

伊莎贝尔微笑着说：“你提出了一个非常好的问题，这就是背包问题的另一种形式——‘**部分背包问题**’（Fractional Knapsack Problem）。在这个问题里，贪心算法将展现出它惊人的力量。”

#### **贪心，为何在此正确？**

“在0-1背包里，我们之所以不能用贪心，是因为一个物品的‘价值’和‘重量’是捆绑的。”黛芙开始分析，“你可能为了拿一个价值很高但很重的物品，而不得不放弃几个价值稍低但总重更轻、总价值却更高的组合。DP之所以能解决，是因为它会去计算和比较这些复杂的组合。”

“但是，一旦物品可以被分割，情况就完全不同了。”黛芙的眼中闪着光，“我们评价一个物品‘值不值得’装进背包，就不再是看它的总价值，而是应该看它的‘**性价比**’——也就是‘**单位重量的价值**’（价值/重量）。”

**贪心策略：**
优先装入单位重量价值最高的物品。如果该物品能全部装下，就全部装下；如果只能装下一部分，就装满背包为止。

“这个策略，为什么是正确的？”黛芙提问。

“因为……”安妮顺着思路想了下去，“既然物品可以分割，那就意味着我总能用‘性价比最高’的物质，去填满我背包里的每一寸空间。我先用金沙（性价比最高）去装，装不下了，再用银沙（性价比次之）去填满剩余的缝隙……这样，我保证了我的背包里，每一克重量所带来的价值，都是当前所能达到的最大值。最终的总价值，也必然是最大的！”

“完美的解释！”黛芙赞许道，“这就是一个严格的、可以被证明的贪心选择。在部分背包问题中，局部最优（选择当前性价比最高的物品）确实能够导向全局最优。”

#### **算法实现**

“所以，算法的实现就变得非常简单了。”希娅在电脑上快速地演示起来。

**物品列表:**
-   A: 重量10, 价值60 (性价比: 6)
-   B: 重量20, 价值100 (性价比: 5)
-   C: 重量30, 价值120 (性价比: 4)

**背包容量:** 50

1.  **计算性价比并排序:**
    -   计算每个物品的单位重量价值。
    -   按照性价比，从高到低对物品进行排序。 `[A, B, C]`

2.  **贪心选择:**
    -   **选择A:** 背包容量`50 >= 10`，完全装下。 `背包内: [A(10kg)], 剩余容量: 40, 总价值: 60`
    -   **选择B:** 背包容量`40 >= 20`，完全装下。 `背包内: [A(10kg), B(20kg)], 剩余容量: 20, 总价值: 60+100=160`
    -   **选择C:** 背包容量`20 < 30`，无法完全装下。只能装入`20kg`的C。
        -   装入的价值 = `20 * (120/30) = 20 * 4 = 80`。
        -   `背包内: [A(10kg), B(20kg), C(20kg)], 剩余容量: 0, 总价值: 160+80=240`

3.  **结束。** 最大价值为240。

```python
def fractional_knapsack(weights, values, W):
    # 将物品打包成 (重量, 价值, 性价比) 的元组
    items = []
    for i in range(len(weights)):
        items.append((weights[i], values[i], values[i] / weights[i]))
    
    # 按性价比降序排序
    items.sort(key=lambda x: x[2], reverse=True)
    
    max_value = 0.0
    current_weight = 0
    
    for weight, value, ratio in items:
        if current_weight + weight <= W:
            # 可以完全装下
            current_weight += weight
            max_value += value
        else:
            # 只能装一部分
            remaining_space = W - current_weight
            max_value += remaining_space * ratio
            break # 背包已满
            
    return max_value
```

#### **0-1背包 vs. 部分背包**

黛芙在白板上，清晰地列出了这两个问题的核心区别。

```ascii
+----------------+--------------------------------+--------------------------------+
|      特性      |          0-1 背包            |           部分背包           |
+================+================================+================================+
|    物品属性    |           不可分割           |            可以分割            |
+----------------+--------------------------------+--------------------------------+
|    核心思想    |          动态规划 (DP)         |           贪心算法 (Greedy)        |
+----------------+--------------------------------+--------------------------------+
|      决策       |  在“放”与“不放”的组合中找最优  |   永远优先选择“性价比最高”的   |
+----------------+--------------------------------+--------------------------------+
|    时间复杂度    |          O(N * W)            |          O(N logN) (主要在排序)          |
+----------------+--------------------------------+--------------------------------+
```

“这两个问题，是体会DP和贪心思想差异的最佳范例。”黛芙总结道，“一个微小的条件变化（物品是否可分割），导致了解决问题的方法论发生了根本性的改变。DP用复杂的计算来应对‘不可分割’带来的组合爆炸，而贪心则用简单的策略，享受‘可分割’带来的便利。”

篝火渐渐熄灭，只留下红色的余烬。安妮明白了，算法的选择，并非一成不变的教条，而是需要根据问题的具体约束，灵活地切换思维。面对“两难”的抉择，需要DP的深思熟虑；而当问题允许我们“取其精华”时，贪心的果断与高效，便会绽放出最耀眼的光芒。

---

🌸 **贪心算法核心要点** 🌸

**1. 算法设计的根本思想**
- **识别问题约束：** 部分背包问题的核心，在于“物品可分割”这一关键约束。正是这个约束，使得基于“性价比”的贪心策略得以成立。识别问题的核心约束，是选择正确算法的第一步。
- **定义贪心标准：** 对于背包问题，“性价比”（单位重量的价值）是最直观、也最正确的贪心标准。它将两个看似矛盾的属性（价值和重量）统一到了一个可比较的维度上。
- **排序与选择：** 与活动选择问题类似，部分背包问题的贪心算法，也遵循“先排序，再选择”的经典模式。排序是为了让贪心选择的每一步，都建立在全局的“性价比”视野之上。

**2. 核心设计哲学**
- **DP的“退化”：** 可以认为，当物品可分割时，0-1背包的DP模型，“退化”成了一个简单的贪心问题。因为我们总可以用最优性价比的物品去“填满”任何决策空间，而无需考虑复杂的组合。
- **连续与离散：** 部分背包问题本质上是一个“连续”的优化问题（可以取物品的一部分），而0-1背包是一个“离散”的组合优化问题。连续问题往往比离散问题更容易找到简单的最优解。
- **策略的简单性：** 贪心算法的魅力在于，它将一个可能需要复杂计算的问题，提炼成一个极其简单的、可重复执行的决策规则，大大降低了求解的难度。

**3. 算法思维的启发**
- **寻找“不变的尺度”：** “性价比”就是解决背包问题时，我们找到的那个不随物品大小、价值变化而变化的、统一的衡量尺度。在解决其他问题时，也应尝试寻找类似的、能“度量”所有选项的通用尺度。
- **检查约束条件的改变：** 0-1背包和部分背包的对比，深刻地提醒我们，要对问题的约束条件保持高度敏感。一个微小的条件变化，可能导致整个算法范式的改变。
- **从贪心开始思考：** 面对一个优化问题，先尝试用贪心策略去解决，并思考其是否正确，是一个很好的起点。如果贪心可行，你可能就找到了最高效的解法；如果贪心不可行，去分析它“为什么不可行”，往往能帮助你找到正确的DP状态定义。

---

🎀 **安妮的小小日记本**

今天我们又回到了背包问题，但感觉完全不一样！

上次的0-1背包，让我感觉像是在玩一个非常烧脑的俄罗斯方块，每个方块（物品）形状固定，我得用DP去计算怎么摆才能得分最高。而今天的部分背包，则更像是在往一个瓶子里装沙子！

我可以先把最闪亮的金沙（性价比最高）装进去，装满了，再用银沙去填，最后用铜沙补满所有缝隙。我不需要去考虑复杂的组合，我的策略永远是：用当前最好的东西，填满我能用的所有空间！

这个小小的“可分割”的设定，就让一个复杂的DP问题，变成了一个简单的贪心问题。这太神奇了！算法的世界，真的充满了这种“失之毫厘，谬以千里”的精妙。以后分析问题，我一定要先把所有的“游戏规则”（约束条件）都看清楚！

---

### 今日关键词

- **部分背包问题 (Fractional Knapsack Problem):** 背包问题的变种，其中每种物品可以被分割成任意小的部分取走。
- **性价比 / 价值密度 (Value Density):** 指物品的“价值 / 重量”比。是解决部分背包问题的核心贪心标准。
- **组合优化 (Combinatorial Optimization):** 在一个离散的、有限的可能性集合中，寻找最优解的问题。0-1背包是其典型代表。
- **连续优化 (Continuous Optimization):** 在一个连续的变量空间中，寻找最优解的问题。部分背包可以看作其简化形式。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（经典模型练习）**  
1.  **手动实现部分背包** ⭐ —— 亲手实现部分背包问题的贪心解法，包括计算性价比、排序和贪心拾取三个步骤。
2.  **对比0-1背包与部分背包** ⭐⭐ —— 用同一组物品和背包容量，分别用0-1背包的DP解法和部分背包的贪心解法计算结果，并比较两者的答案。这能让你直观地感受到两种问题的区别。

**进阶巩固（贪心思想应用）**  
3.  LC 135. Candy ⭐⭐⭐ —— 分发糖果。一个非常经典的贪心难题。每个孩子有一个评分，你需要给他们分糖果，满足两个条件：1.每个孩子至少一个；2.评分高的孩子比相邻孩子糖果多。正确的贪心策略是：进行两次遍历，一次从左到右，保证每个孩子比左边评分高的邻居糖果多；一次从右到左，保证比右边评分高的邻居糖果多。最后取两次结果的最大值。
4.  LC 881. Boats to Save People ⭐⭐ —— 救生艇。每艘船最多坐两人，且有载重限制。贪心策略是：先对所有人按体重排序，然后用双指针，一个指向最轻的人，一个指向最重的人。每次都让最重的人上船，然后看还能不能再带上一个最轻的人。
5.  LC 649. Dota2 Senate ⭐⭐ —— Dota2参议院。一个有趣的循环博弈贪心。贪心策略是：每个参议员在行使权利时，都应该去禁止掉他后面第一个出现的、敌对阵营的参议员，因为这样能最快地让对方减员，并让自己的队友获得行动机会。
