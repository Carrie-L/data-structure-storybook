### **7.3 倾斜风帆的优雅回旋【AVL·旋转】**

"*真正的平衡，并非静止不动，而是在持续的摇摆与倾斜中，做出最优雅的回旋。*"

海风渐起，吹皱了蔚蓝的海面，也鼓起了远处点点帆船的白帆。女孩们坐在咖啡馆的藤椅上，享受着午后的惬意。安妮的目光，被一艘灵巧的帆船所吸引。一阵强风袭来，船身猛地一斜，眼看就要失去平衡，只见帆船上的水手迅速而流畅地调整了一下船帆的角度，倾斜的船身竟奇迹般地回正，继续乘风破浪，姿态优雅。

“看那艘帆船，”黛芙敏锐地抓住了这个教学时机，她的声音里带着一丝兴奋，“刚才一阵强风（一次数据的插入或删除），让它严重倾斜了。但水手立刻调整了船帆（执行了旋转操作），船就恢复了平衡。我们的二叉搜索树，也会遇到同样的问题。”

她在白板上快速地画着：“想象一下，如果我们向一棵空的BST里，按顺序插入`10, 20, 30, 40, 50`这几个数字，会发生什么？”

```ascii
( 10 )
  \
  ( 20 )
    \
    ( 30 )
      \
      ( 40 )
        \
        ( 50 )
```

“看，”黛芙指着这个退化成链表的“树”，“这棵‘树’已经倾斜得不成样子了，它的高度变成了n，查找效率退化到了O(n)，BST的对数时间优势荡然无存。这艘‘数据之船’，已经快要倾覆了！”

#### **平衡的契约：AVL树与平衡因子**

“为了不让我们的‘帆船’倾覆，我们需要一位时刻保持警惕的‘平衡大师’。”伊莎贝尔柔声说道，“**AVL树**就是这样一位大师。它是有史以来第一种自平衡的二叉搜索树。”

“AVL树本质上仍是一棵BST，但它额外遵守一个更严格的‘平衡契约’：”

> **对于树中的任意一个节点，其左子树和右子树的‘高度差’绝对值不能超过 1。**

“这个‘高度差’，我们称之为**平衡因子（Balance Factor）**。”黛芙在白板上写下公式。

`平衡因子 = 左子树高度 - 右子树高度`

“所以，在一个合格的AVL树中，所有节点的平衡因子，只可能是 **-1、0、或 1**。一旦某个节点的平衡因子变成了 **+2** 或 **-2**，就意味着平衡被打破，‘平衡大师’必须立刻出手！”

#### **失衡的警报与旋转的艺术**

“当一次插入或删除操作，导致某个节点的平衡因子变成了+2或-2时，就拉响了‘失衡’的警报。”黛芙的语气变得像一位船长，“此时，AVL树会通过一种名为**旋转（Rotation）**的、精巧的局部调整操作，像水手调整船帆一样，让树结构恢复平衡。”

“旋转操作，是理解所有自平衡树的关键。根据导致失衡的节点插入位置不同，主要分为四种情况。”

**1. 左-左（LL）失衡 与 右旋**

“第一种情况，是在某个节点（A）的**左**子树的**左**孩子（B的左子树）上插入了一个新节点，导致A的平衡因子变成了+2。”

“这就像一阵强风从‘左边的左边’吹来，把船的左舷压得太低了。”伊莎贝尔比喻道，“我们需要把主桅杆（A）向**右**拉，把它‘扶正’。”

黛芙在白板上画出了这个过程，这个操作叫做**右旋（Right Rotation）**。

```ascii
      (A) [+2]             (B) [0]
      /   \               /   \
    (B) [+1]   C   -->   (T)     (A) [0]
    /   \
  (T)     D             ...     D     C
  / \
 ... ...

操作：以A为轴，进行一次右旋。
效果：B取代了A的位置，A成为了B的右孩子，B原来的右孩子D，则被过继给了A作为新的左孩子。
```

**2. 右-右（RR）失衡 与 左旋**

“第二种情况，与LL对称。在节点（A）的**右**子树的**右**孩子（B的右子树）上插入新节点，导致A的平衡因子变成-2。”

“这次是右边的风太大了，”伊莎贝尔说，“我们需要把主桅杆（A）向**左**拉。” 这个操作叫做**左旋（Left Rotation）**。

```ascii
  (A) [-2]                 (B) [0]
  /   \                   /   \
 C     (B) [-1]   -->   (A) [0]   (T)
       /   \
      D     (T)         /   \
            / \
           ... ...       C     D

操作：以A为轴，进行一次左旋。
效果：B取代A，A成为B的左孩子，B原来的左孩子D，过继给A做右孩子。
```

**3. 左-右（LR）失衡 与 左-右双旋**

“最巧妙的是接下来的两种情况。”黛芙的眼神愈发专注，“如果在节点（A）的**左**子树的**右**孩子（B的右子树）上插入新节点，导致A的平衡因子变成+2，这就是LR失衡。”

“这股风很刁钻，”伊莎贝尔解释道，“它从左边来，但吹的是左帆的‘内侧’，让帆呈现一个‘之’字形。我们不能直接大动主帆。”

“正确的做法是：**先小调一下左帆（对B左旋），让它变成一个纯粹的左倾（LL）状态，然后再大调主帆（对A右旋）**。”

```ascii
      (A) [+2]             (A) [+2]             (C) [0]
      /   \               /   \               /   \
    (B) [-1]   D   -->     (C) [+1]   D   -->   (B) [0]   (A) [0]
    /   \
  E     (C) [0]         (B) [-1]   T2        /   \     /   \
        /   \           /   \       E     T1  T2    D
      (T1)  (T2)        E     T1

第一步：对B进行一次左旋，变为LL型。
第二步：对A进行一次右旋，恢复平衡。
```

**4. 右-左（RL）失衡 与 右-左双旋**

“最后一种，与LR对称。在节点（A）的**右**子树的**左**孩子（B的左子树）上插入新节点，导致A的平衡因子变成-2。”

“这是从右边吹来的‘内侧’风。同样，**先对B进行一次右旋，让它变成纯粹的右倾（RR）状态，再对A进行一次左旋**。”

```ascii
  (A) [-2]                 (A) [-2]                 (C) [0]
  /   \                   /   \                   /   \
D     (B) [+1]   -->   D     (C) [-1]   -->   (A) [0]   (B) [0]
      /   \                   /   \           /   \     /   \
    (C) [0]   E               T1    (B) [+1]      D     T1  T2    E
    /   \
  (T1)  (T2)

第一步：对B进行一次右旋，变为RR型。
第二步：对A进行一次左旋，恢复平衡。
```

安妮看着白板上那四幅如舞蹈动作分解图般精准的示意图，彻底被震撼了。原来，看似复杂的平衡维护，竟是由这四种基础而优美的“回旋”动作组合而成。它们就像是“平衡大师”的四招核心剑法，无论树的形态如何因增删而变得“倾斜”，总能被其中一招或两招的组合，优雅地拉回平衡。

远方的海面上，那艘帆船还在灵巧地调整着姿态，与风浪嬉戏。在安妮眼中，它不再仅仅是一艘船，而是一棵活生生的、在动态变化中不断自我调整的AVL树，时刻维护着自己航行的效率与稳定，演绎着数据结构世界中，关于平衡的、最动人的诗篇。

--- 

🌸 **AVL树核心要点** 🌸

**1. 算法设计的根本思想**
- **严格的平衡约束：** AVL树的设计哲学是“防微杜渐”。它不容忍任何节点的左右子树高度差超过1，这种严格的约束保证了树的高度始终维持在`O(log n)`级别，从而确保了最坏情况下的查找性能。
- **局部调整恢复全局平衡：** 旋转操作是一种精巧的“局部手术”。它只涉及两到三个节点及其子树的指针修改，却能奇迹般地修正从失衡点到根节点路径上所有祖先的平衡因子，恢复整棵树的平衡。这体现了“用最小的代价解决问题”的工程思想。
- **高度作为核心监控指标：** AVL树的一切行为都围绕“高度”这一核心指标展开。平衡因子的计算、失衡的判断、旋转后高度的更新，都离不开对节点高度的精确维护。

**2. 核心设计哲学**
- **“绝对平衡”的追求者：** 如果说BST追求的是“有序”，那么AVL树在“有序”的基础上，更追求一种近乎苛刻的“平衡”。这种对平衡的极致追求，使它成为性能最稳定、最可预测的二叉搜索树之一。
- **对称与对偶之美：** AVL树的四种失衡情况（LL/RR, LR/RL）和对应的旋转操作（右旋/左旋, 左右双旋/右左双旋）呈现出高度的对称性和对偶性。理解了其中一种，另一种便能触类旁通，这在算法设计中充满了数学之美。
- **写操作的复杂性换取读操作的极致性能：** AVL树为了维护平衡，在插入和删除时可能需要进行一次或多次旋转，这使得其“写”操作比普通BST更复杂。但这种代价换来的是“读”操作（查找）在任何情况下的高效能，是一种典型的“优化读性能”的策略。

**3. 算法思维的启发**
- **不变量的强制维护：** “平衡因子在{-1, 0, 1}之间”是AVL树的“不变量”。所有的旋转操作，其最终目的都是为了在数据变化后，强行恢复这个不变量。
- **模式识别与分类讨论：** 解决失衡问题的过程，是一个典型的“模式识别”过程。我们需要准确判断出当前属于LL、RR、LR、RL中的哪一种模式，然后执行对应的、固定的解决方案。这种“分类讨论”是解决复杂问题的基础能力。
- **原子操作的组合：** 复杂的LR和RL旋转，实际上是由两次更基本的单旋转（左旋和右旋）组合而成的。这启发我们将复杂操作分解为一系列不可再分的“原子操作”，然后通过组合这些原子操作来解决更宏观的问题。

--- 

🎀 **安妮的小小日记本**

今天我好像看懂了海上的帆船之舞！

原来，一棵二叉搜索树如果“长歪了”，就会变得和链表一样慢，这太可怕了！AVL树就像一个聪明的“平衡大师”，它给树立下了一个规矩：任何一个节点，它的左子树和右子树“身高差”不能超过。就像一个严格的舞蹈老师！

一旦有新数据加入，导致某个地方不平衡了（平衡因子变成了+2或-2），“旋转”这个神奇的操作就登场了！黛芙学姐画的四种旋转（LL, RR, LR, RL），就像是四套优美的舞蹈动作。左边太重了就“右旋”一下，右边太重了就“左旋”一下，如果是“之”字形的倾斜，那就先“小转”一下再“大转”一下。虽然看起来有点复杂，但每一步都像是在解一个精密的机械谜题，最后“咔嗒”一声，平衡就恢复了！

感觉AVL树好有安全感，它用一点点“旋转”的代价，换来了永远不会“翻船”的承诺！

--- 

> **AVL树** 是以其两位发明者G. M. Adelson-Velsky和E. M. Landis的名字命名的，是计算机科学中最早被发明的自平衡二叉搜索树。在AVL树中，任何节点的两个子树的高度最大差别为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。增加和删除节点可能需要通过一次或多次“树旋转”来重新平衡这个树。

### 今日关键词

- **自平衡二叉搜索树 (Self-Balancing BST):** 一类能够在插入和删除操作后，通过特定操作（如旋转）自动维持树高平衡的二叉搜索树。
- **AVL树:** 最早被发明的自平衡二叉搜索树，严格维持左右子树高度差不超过1。
- **平衡因子 (Balance Factor):** 某节点的左子树高度与右子树高度之差。
- **失衡 (Imbalance):** 某节点的平衡因子变为+2或-2，破坏了AVL树的性质。
- **旋转 (Rotation):** 调整树结构、恢复平衡的基本操作，分为左旋和右旋。
- **左旋 (Left Rotation):** 用于修正右侧子树过重（RR或RL）情况的旋转操作。
- **右旋 (Right Rotation):** 用于修正左侧子树过重（LL或LR）情况的旋转操作。
- **LL/RR/LR/RL:** 导致失衡的四种基本情况，分别对应新节点插入的位置。

### 名词小传

**AVL树**诞生于1962年，由两位苏联数学家**格奥尔吉·阿杰尔松-韦利斯基（Georgy Adelson-Velsky）**和**叶夫根尼·兰迪斯（Evgenii Landis）**共同发明，并以他们名字的首字母缩写命名。当时，他们正在致力于解决如何高效地组织和检索信息的问题。他们发现，普通的二叉搜索树在最坏情况下性能不佳，于是提出了通过“旋转”操作来维持树的高度平衡，从而保证在任何情况下都能获得对数时间的查找效率。AVL树的提出，是数据结构领域的一个里程碑，它开创了“自平衡”这一重要的研究方向，为后来更多高效的平衡树（如红黑树、B树）的诞生奠定了坚实的理论基础。

### AVL树定义

AVL树是一种自平衡的二叉搜索树。它除了满足二叉搜索树的所有性质外，还必须满足一个额外的平衡条件：对于树中的任意节点，其左子树与右子树的高度差（即平衡因子）的绝对值不能超过1。当插入或删除节点导致这个平衡条件被破坏时，AVL树会通过一系列的旋转操作来重新调整树的结构，以恢复平衡。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard
> 建议顺序：基础 ➜ 进阶 ➜ 面试 ➜ 考研  
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 4 题）**  
1.  LC 108 Convert Sorted Array to Binary Search Tree ⭐⭐ —— **核心思想**。这道题要求你从一个有序数组构建一棵“高度平衡”的BST。其递归选取中点的构建过程，正是AVL树等平衡树想要达到的理想状态。
2.  LC 110 Balanced Binary Tree ⭐⭐ —— **必做**。直接考察你对“平衡”的理解。你需要写一个函数来判断一棵二叉树是否是高度平衡的（即满足AVL树的平衡因子条件），是理解AVL树性质的基础。
3.  **手绘练习（无代码）**：给定一个空树，依次插入`10, 20, 30, 40, 50`。请手动画出每一步插入后，AVL树如何进行旋转以保持平衡。—— 这是理解四种旋转情况最直观、最有效的方法。
4.  **手绘练习（无代码）**：给定一个空树，依次插入`50, 40, 60, 30, 45`。请手动画出LR双旋的过程。—— 专门练习最复杂的LR/RL情况。

**进阶巩固（练习 2 题）**  
5.  **实现AVL树的插入操作（较难，建议伪代码或思路）**：尝试自己实现AVL树的插入逻辑。这需要你：(1) 按BST规则插入节点；(2) 从插入点向上回溯，更新祖先节点的平衡因子；(3) 找到第一个失衡的节点；(4) 判断失衡类型（LL/RR/LR/RL）；(5) 执行对应的旋转。—— 这是对本节知识的终极考验。
6.  LC 1382 Balance a Binary Search Tree ⭐⭐ —— 这道题是AVL思想的绝佳应用。它给你一棵普通的BST，要求你把它变成一棵平衡的BST。标准做法是：(1) 先对现有BST进行**中序遍历**，得到一个有序数组；(2) 然后利用第1题（LC 108）的方法，从有序数组构建一棵新的、平衡的BST。
