### **19.4 星辰迷宫的探索【拓扑排序】**

*"在浩瀚的星辰迷宫中，不存在回头之路。每一次的启程，都必须等待所有前置的星门开启。拓扑排序，便是绘制这趟单向旅途唯一航线图的秘法。"*

在深入探讨了各种最短路径算法后，女孩们对图论的应用有了更深的理解。但黛芙指出，图论的世界里，还有一类非常特殊且重要的问题，它不关心“距离”，只关心“顺序”。

“想象一下，”黛芙说，“安妮你正在规划你的大学课程。选《算法设计》之前，必须先修完《数据结构》；而修《数据结构》之前，又必须先修完《程序设计入门》。这个‘课程依赖关系’，就是一个‘**有向无环图**’（Directed Acyclic Graph, DAG）。”

-   **有向 (Directed):** 依赖关系是单向的，`A -> B`代表必须先完成A才能开始B。
-   **无环 (Acyclic):** 依赖关系中不能存在循环。比如，你不能要求“修完A才能修B，修完B又才能修A”，那将永远无法开始。

“现在的问题是，”她提问，“我们能否给所有的课程，排出一个‘可行’的学习顺序？这个排列，就是这个DAG的‘**拓扑排序**’（Topological Sort）。”

伊莎贝尔补充道：“拓扑排序的结果，不是唯一的。比如，‘数学分析’和‘线性代数’可能没有直接的依赖关系，那么它们谁先谁后都可以。拓扑排序给出的是‘一种或多种’满足所有前置约束的线性序列。”

#### **Kahn算法：基于入度的“削减”**

“解决拓扑排序，最经典的一种方法，是基于‘**入度**’（In-degree）的Kahn算法。”黛芙开始讲解，“一个顶点的‘入度’，就是指向它的边的数量。在课程依赖图中，就代表一门课有多少‘前置课程’。”

“那么，哪些课可以作为我们学习的起点呢？”

“那些‘入度为0’的课！”安妮立刻回答，“它们没有任何前置课程，可以直接开始学！”

“完全正确！”黛芙赞道，“Kahn算法的核心思想，就像是‘削掉’图中所有入度为0的节点，然后看看会发生什么。”

**算法步骤：**

1.  **统计入度:** 遍历整个图，计算所有顶点的入度，存入一个`in_degree`数组。
2.  **初始化队列:** 找到所有入度为0的顶点，将它们加入一个队列`q`。这些是我们的“起点”。
3.  **循环处理:** 当队列`q`不为空时：
    -   从队列中取出一个顶点`u`（比如`q.popleft()`），将它加入到我们的拓扑排序结果列表`result`中。
    -   **“削减”影响:** 遍历`u`的所有邻接点`v`（即那些以`u`为前置课程的课）：
        -   将`v`的入度减一（`in_degree[v] -= 1`），因为它的一个前置依赖已经被满足了。
        -   如果`v`的入度在减一后，变成了0，说明它的所有前置课程都已修完，它现在成为了新的“起点”。于是，将`v`加入队列`q`。
4.  **结束与判断:**
    -   循环结束后，如果`result`列表中的顶点数量，等于图中总的顶点数量，说明我们成功地找到了一个拓扑排序。
    -   如果数量不相等，说明什么？

“说明图中存在‘环’！”希娅一针见血，“因为环里的所有节点，它们的入度永远不可能变成0，所以永远进不了队列，导致`result`的长度不够！”

#### **DFS算法：基于深度的“逆反”**

“除了Kahn算法，我们还可以用我们熟悉的老朋友——深度优先搜索（DFS）来解决。”伊莎贝尔介绍了另一种方法。

“DFS的思路，更像是在探索一条‘最深’的学习路径。想象一下，为了修《算法竞赛进阶》，你发现需要先学《图论》，为了学《图论》，又需要《数据结构》……”

**核心思想：**
从任意一个未访问过的节点开始进行DFS。当一个节点`u`的所有“后续节点”（即从`u`出发能到达的所有节点）都已经被访问完毕并处理后，我们才将`u`本身，加入到一个结果栈中。

**算法步骤：**

1.  **初始化:** 创建一个`visited`集合，和一个用于存放结果的栈`stack`。
2.  **DFS遍历:** 遍历所有顶点。如果一个顶点`u`未被访问过，就对它调用`dfs(u)`。
3.  **`dfs(u)`函数:**
    -   将`u`标记为“正在访问”。
    -   遍历`u`的所有邻接点`v`：
        -   如果`v`“正在访问”，说明我们通过`u->v`这条边，找到了一个“环”。图中存在环，无法进行拓扑排序。
        -   如果`v`未被访问过，则递归调用`dfs(v)`。
    -   当`u`的所有邻居都已被成功访问后，将`u`标记为“已完全访问”，并**将`u`压入结果栈`stack`中**。
4.  **最终结果:** 循环结束后，将结果栈`stack`中的元素依次弹出，得到的序列，就是拓扑排序的**逆序**。将其反转，即为一个正确的拓扑排序。

“为什么是逆序呢？”安妮问。

“因为，”黛芙解释道，“一个节点，越是‘基础’（没有依赖），它就会越早地结束自己的DFS过程（因为它的邻居少或没有），从而被‘更早’地压入栈底。而那些依赖众多的‘顶层’课程，会等待所有依赖都结束后，才最后结束自己的DFS，从而被‘更晚’地压入栈顶。所以，从栈顶到栈底的顺序，恰好就是从‘顶层’到‘基础’的顺序，我们把它反过来，就是正确的学习顺序了。”

冬夜的星空，繁星点点，却又遵循着宇宙的法则，在各自的轨道上有序运行。安妮明白了，拓扑排序，就是去寻找和揭示这种隐藏在复杂依赖关系之下的、内在的、单向的“时间流”。它告诉我们，即使在看似盘根错节的世界里，只要没有死循环，就总能找到一条可以开始、并最终完成所有任务的、清晰的道路。

---

🌸 **拓扑排序算法核心要点** 🌸

**1. 算法设计的根本思想**
- **有向无环图（DAG）：** 拓扑排序是专门针对DAG的一种操作。它的存在性，是判断一个有向图是否无环的充要条件。
- **依赖关系的处理：** 拓扑排序的核心，是处理一系列任务或事件之间的“依赖”或“偏序”关系，并给出一个满足所有这些偏序约束的“全序”排列。
- **两种核心思路：**
    -   **Kahn (BFS-based):** 不断地移除“没有依赖”（入度为0）的节点，并更新其邻居的依赖状态。是一种“消除源头”的思路。
    -   **DFS-based:** 深入到依赖链的最末端，在返回的路径上，逆序地构建出结果。是一种“追根溯源”的思路。

**2. 核心设计哲学**
- **环的检测：** 两种拓扑排序算法，都内建了“环检测”的能力。Kahn算法通过最后判断结果集的数量；DFS算法通过维护“访问中”状态来判断是否遇到了“返祖边”。
- **队列 vs. 栈：** Kahn算法使用队列来管理入度为0的节点，体现了BFS的层序思想。DFS算法使用递归（隐式栈）或显式栈来管理探索路径，并将结果逆序存入栈中。
- **结果的非唯一性：** 必须理解，一个DAG的拓扑排序通常不是唯一的。选择不同的入度为0的节点开始，或DFS时遍历邻居的顺序不同，都可能导致不同的、但都正确的拓扑序列。

**3. 算法思维的启发**
- **“剥洋葱”模型：** Kahn算法就像在剥洋葱，每次都剥掉最外层（入度为0），暴露出新的一层，直到核心。
- **“反向”的智慧：** DFS解法的精髓在于“反向构造”。当一个任务的所有后续任务都完成了，才把它加入结果。这种“事后诸葛亮”式的记录方式，巧妙地解决了顺序问题。
- **应用场景的识别：** 当你遇到任何涉及“任务调度”、“编译顺序”、“依赖解析”等具有先后约束的问题时，都应该立刻联想到拓扑排序。

---

🎀 **安妮的小小日记本**

拓扑排序，听起来好高深，但学完之后，发现它其实非常贴近生活！

就像我们做菜，必须先洗菜、切菜，然后才能下锅炒。这个“菜谱”的顺序，就是一种拓扑排序！我们总不能先把锅炒热了，再回头去洗菜吧？那就会“死循环”了！

Kahn算法，就像是把所有“现在就能做”的事情（入度为0），都先放到一个“待办清单”（队列）里。做完一件，就划掉它，然后看看它做完之后，又有哪些新的事情可以做了，再加到清单里。

DFS算法则更有趣，它像一个喜欢刨根问底的人。为了做“红烧肉”，他发现要先“焯水”，为了“焯水”，要先“烧水”……他会一直问到最基础的那一步，然后从后往前，把步骤记录下来：“1.烧水, 2.焯水, 3.红烧肉”。这个顺序反过来，就是正确的执行顺序了！

感觉又学会了一个超有用的工具，以后安排学习计划，再也不会手忙脚乱了！

---

### 今日关键词

- **拓扑排序 (Topological Sort):** 对一个有向无环图（DAG）的所有顶点进行线性排序，使得图中任意一条有向边`(u, v)`，顶点`u`都在顶点`v`之前出现。
- **有向无环图 (DAG - Directed Acyclic Graph):** 不存在有向环路的有向图。
- **入度 (In-degree):** 在有向图中，指向一个顶点的边的数量。
- **Kahn算法:** 一种基于BFS和入度计数的拓扑排序算法。
- **返祖边 (Back Edge):** 在DFS遍历有向图时，从一个节点指向其在DFS树中的祖先节点的边。返祖边的存在，是图中有环的标志。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（模板与理解）**  
1.  LC 207. Course Schedule ⭐⭐ —— 课程表。这是拓扑排序最经典、最直接的应用。问题就是判断给定的课程依赖关系（一个图）是否存在环。用Kahn算法或DFS算法都能解决。
2.  LC 210. Course Schedule II ⭐⭐ —— 课程表II。上一题的升级版，在判断无环的基础上，还需要返回一个“可行”的学习顺序，即一个完整的拓扑序列。

**进阶巩固（模型应用与变种）**  
3.  LC 269. Alien Dictionary ⭐⭐⭐ —— 火星词典。一个非常巧妙的拓扑排序问题。通过比较字典中相邻两个单词的第一个不同字母，可以推断出字母之间的“偏序”关系（如`wrt`和`wrf`，可知`t`在`f`前面）。将这些关系建成一张图，然后进行拓扑排序，就能得到火星字母的顺序。
4.  LC 802. Find Eventual Safe States ⭐⭐ —— 找到最终的安全状态。一个节点是“安全”的，当且仅当从它出发的所有路径，都能到达一个“终端节点”（出度为0的节点）。这个问题可以反向思考：将所有边反向，问题就变成了“从终端节点出发，能到达的所有节点都是安全的”。然后可以用拓扑排序（Kahn）或DFS来解决。
5.  LC 444. Sequence Reconstruction ⭐⭐⭐ —— 序列重建。判断一个序列`org`是否是`seqs`中所有序列的唯一超序列。需要将`seqs`中的前后关系建成一张图，然后进行拓扑排序，并判断排序过程中，队列中的元素是否始终只有一个，以确定序列的唯一性。
