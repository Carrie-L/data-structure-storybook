### **14.1 火光跳跃的最优抉择【DP 核心思想】**

*"摇曳的火焰，是当下的状态；添入的木柴，是未来的抉择。于光影变幻中，寻得那通往永恒温暖的最优路径。"*

秋意渐深，为了体验一个完整的秋日，社团的女孩们组织了一次特别的露营活动。夜幕降临，她们围坐在一堆温暖的篝火旁，火焰发出“噼啪”的轻响，将每个人的脸庞映得通红。

“递归真是太强大了，”安妮一边用树枝拨弄着火焰，一边总结着上一章的收获，“但有时候，它也挺‘笨’的。”

她想起了之前黛芙学姐举过的斐波那契数列的例子。`fib(5)`会去计算`fib(4)`和`fib(3)`；而`fib(4)`又会去计算`fib(3)`和`fib(2)`。“你看，`fib(3)`被重复计算了两次！如果数字更大，这种重复会多到难以想象。”

“你说到了点子上！”黛芙的眼中闪烁着比火焰更亮的光芒，“你发现的这个‘**重叠子问题**’（Overlapping Subproblems）现象，正是我们开启下一扇大门的钥匙。这扇门背后，是算法世界中最强大的思想之一——‘**动态规划**’（Dynamic Programming，简称DP）。”

“动态规划……”安妮轻声念着这个听起来非常高级的名字，“它和‘分而治之’有什么不同吗？”

“很好的问题。它们都将大问题分解为子问题。但分而治之的子问题通常是‘相互独立’的，就像归并排序的左右两半。而动态规划面对的，是像斐波那契这样，子问题被大量‘重叠复用’的情况。”

“除了‘重叠子问题’，DP能解决的问题，还必须满足另一个重要特性——‘**最优子结构**’（Optimal Substructure）。”黛芙补充道，“它的意思是，一个问题的‘最优解’，包含了其子问题的‘最优解’。”

伊莎贝尔用一个生动的比喻解释道：“比如，我们从山脚的营地，要找到一条最短的路径登上山顶。如果我们选定的这条最短路径，中途经过了半山腰的那个小木屋，那么，我们从营地到小木屋的这一段路，也‘必然’是从营地到小木屋的最短路径。否则，我们就能找一条更短的路到小木屋，从而让整条登顶路径变得更短，这就矛盾了。”

#### **DP的核心要素：状态与转移**

“所以，一个问题如果同时具有‘重叠子问题’和‘最优子结构’这两个特性，我们就可以尝试使用动态规划来解决。”黛芙总结道，“而解决一个DP问题，核心在于定义两样东西：‘**状态**’和‘**状态转移方程**’。”

她指着眼前的篝火，开始了今晚的核心教学：

-   **状态 (State):** “状态，就是对‘原问题’和‘子问题’的一种描述。比如，`f(n)`可以代表‘爬上n级台阶有多少种方法’这个问题的解。这里的`n`，就是定义状态的变量。在篝火的比喻里，‘火势的大小和温度’就是当前的状态。”

-   **状态转移方程 (State Transition Equation):** “这是DP的灵魂。它描述了不同状态之间是如何关联和演变的。也就是说，一个更大问题的解，如何通过一个或多个更小问题的解来计算得出。这就像我们决定‘下一步要加哪块木柴’的决策公式。”

#### **初试牛刀：攀登阶梯**

“我们来看一个最经典的DP入门题：**爬楼梯**。”

**问题：** 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶？

“我们来尝试用DP的语言来描述它。”

1.  **定义状态：**
    -   `dp[i]` 代表：爬到第 `i` 级台阶，总共有多少种不同的方法。
    -   我们的最终目标，就是求 `dp[n]`。

2.  **寻找状态转移方程：**
    -   “思考一下，要想到达第`i`级台阶，我们上一步可能在哪里？”黛芙提问。
    -   安妮很快反应过来：“可能在第`i-1`级，然后爬1步上来；也可能在第`i-2`级，然后爬2步上来！”
    -   “完全正确！所以，到达第`i`级的总方法数，就是‘到达第i-1级的方法数’与‘到达第i-2级的方法数’之和。”
    -   于是，我们得到了状态转移方程：**`dp[i] = dp[i-1] + dp[i-2]`**

3.  **确定基例 (Base Cases):**
    -   “这个方程需要有起点。爬到第1级台阶有几种方法？”
    -   “只有1种（爬1步）。”
    -   “爬到第2级呢？”
    -   “有2种（1+1，或者直接爬2步）。”
    -   所以，基例是：`dp[1] = 1`, `dp[2] = 2`。

“看，”黛芙笑道，“这不就是我们熟悉的斐波那契数列吗？我们通过定义状态、寻找转移方程、确定基例这三步，成功地将一个看似复杂的问题，转化成了一个简单的数学递推。”

```python
def climb_stairs(n: int) -> int:
    if n <= 2:
        return n
    
    # dp数组，dp[i]表示爬到i阶的方法数
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    
    for i in range(3, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
        
    return dp[n]
```

篝火静静地燃烧，火光在每个人的脸上跳跃。安妮感觉自己仿佛触摸到了一个全新世界的门扉。递归，是自顶向下地发问与分解；而动态规划，则是自底向上地计算与构建。它不走回头路，将每一个子问题的解（记忆碎片）精心保存，作为通往最终答案的坚实阶梯。

---

🌸 **动态规划核心要点** 🌸

**1. 算法设计的根本思想**
- **记忆化（Memoization）：** DP的本质，是通过“记住”已经解决过的子问题的解，来避免重复计算。这是它与普通递归最核心的区别，也是其高效的根源。
- **空间换时间：** DP通常需要一个数组或矩阵（`dp`表）来存储子问题的解。这是一种典型的“空间换时间”策略，用额外的存储空间，换取了计算时间的极大缩减。
- **寻找最优子结构：** 应用DP的前提，是判断问题是否具有最优子结构。即，问题的最优解可以通过子问题的最优解来构造。如果子问题的选择会影响到其他子问题，那么DP可能不适用。

**2. 核心设计哲学**
- **状态的定义是关键：** 如何定义`dp[i]`或`dp[i][j]`的含义，是解决DP问题的重中之重。一个清晰、准确、无后效性的状态定义，是写出正确状态转移方程的基础。
- **从子问题到原问题：** DP的思考方式，是站在“原问题”的角度，思考它与“规模更小的子问题”之间的关系。这种关系，就是状态转移方程。
- **自底向上（Bottom-up）：** 标准的DP解法（表格法），通常是从最小的子问题（基例）开始，一步步地、迭代地计算出更大问题的解，直到求出最终答案。这种构建过程，稳健而高效。

**3. 算法思维的启发**
- **“未来”只与“过去”有关：** 在DP的状态转移中，当前状态的解，只依赖于它之前的、已经计算过的状态的解。这种“无后效性”是马尔可夫链等更高级概率模型思想的雏形。
- **表格化思考：** 将问题表格化，是DP的一种重要思考方式。通过填充表格，将复杂的递推关系，转化为直观的填表过程，有助于理清思路、避免出错。
- **降维打击：** 许多看似需要指数级时间（如暴力穷举）才能解决的问题，如果被识别出具有DP的两个特性，就可以被“降维”到多项式时间（如O(N²), O(N)）来解决，这是DP最强大的威力所在。

---

🎀 **安妮的小小日记本**

动态规划！光听名字就感觉深不可测！

但经过学姐们的讲解，我感觉自己好像摸到了一点门道。原来，它就是递归的“聪明版”！递归像一个有点健忘的天才，总是在重复计算自己算过的东西。而DP，则像一个带着笔记本的学霸，每算出一个小问题的答案，就立刻记下来，下次再遇到，直接翻笔记就行了，绝不做重复劳动！

解决DP问题的“三步曲”——定义状态、找转移方程、定基例——感觉就像在做一道严谨的数学证明题。特别是“状态转移方程”，它就像连接过去与未来的桥梁，告诉我们如何从已知走向未知。爬楼梯的`dp[i] = dp[i-1] + dp[i-2]`，简直是这个思想最完美的诠释！

虽然感觉DP的世界还很庞大，有很多很多复杂的模型，但今晚，围着这堆篝火，我感觉自己已经找到了那扇门的钥匙。有点激动，又有点紧张，我已经迫不及待想看看门后的风景了！

---

### 今日关键词

- **动态规划 (Dynamic Programming, DP):** 一种通过将原问题分解为相对简单的、具有重叠性质的子问题，并存储子问题的解来避免重复计算，从而解决复杂问题的算法思想。
- **最优子结构 (Optimal Substructure):** 指一个问题的最优解包含其子问题的最优解。这是问题能用DP解决的必要条件之一。
- **重叠子问题 (Overlapping Subproblems):** 指在递归求解的过程中，许多相同的子问题被一次又一次地重复计算。这是问题适合用DP优化的标志。
- **状态 (State):** 在DP中，对一个子问题的形式化描述。通常用一个或多个变量来定义，如`dp[i]`。
- **状态转移方程 (State Transition Equation):** 描述问题状态之间递推关系的数学表达式，是DP算法的核心。
- **无后效性 (No Aftereffect):** 指一旦某个状态的值被确定，它就不会再被后续的决策所改变。当前状态只与之前的状态有关，与之后的状态无关。

### 名词小传

**理查德·贝尔曼 (Richard Bellman)** (1920-1984)，美国应用数学家。他在20世纪50年代，为了解决多阶段决策过程的优化问题，提出了动态规划。据说，他之所以取“Dynamic Programming”这个名字，是为了让这个数学理论听起来更“高大上”，以便于在当时的环境下申请研究经费。“Programming”在这里并非指“编程”，而是指“规划”或“决策”。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（感受DP思想）**  
1.  LC 70. Climbing Stairs ⭐ —— 本章的范例，斐波那契数列最直接的应用，是理解状态和状态转移方程的绝佳起点。
2.  LC 509. Fibonacci Number ⭐ —— 直接考察斐波那契数，要求用DP（迭代）的方式来解，避免递归的低效。
3.  LC 746. Min Cost Climbing Stairs ⭐ —— 爬楼梯的变种。状态`dp[i]`的定义变为“爬到第i阶的最小花费”，状态转移方程也相应地变为`dp[i] = cost[i] + min(dp[i-1], dp[i-2])`，是练习定义状态和转移的好题目。
4.  LC 198. House Robber ⭐⭐ —— “打家劫舍”系列入门题。对于第`i`间房，你可以选择“抢”或“不抢”。如果抢，则总金额为`nums[i] + dp[i-2]`；如果不抢，则总金额为`dp[i-1]`。状态转移方程`dp[i] = max(nums[i] + dp[i-2], dp[i-1])`是其核心。
