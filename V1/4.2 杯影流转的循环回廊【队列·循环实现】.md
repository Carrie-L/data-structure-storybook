### **4.2 杯影流转的循环回廊【队列·循环实现】**

*"当线性的长廊，于逻辑中首尾相连，便化为一座无尽的循环回廊。指针的追逐，于此间，上演着永不落幕的、关于满与空的优雅博弈。"*

在理解了队列可以用“头出尾进”的链表来实现后，安妮对这种“管道”结构，有了更深的认识。但她也记得，黛芙学姐曾提到，用“数组”也可以实现队列，但有一个“坑”。

“学姐，”安妮问，“如果我们用数组来实现队列，在队头`front`出队，在队尾`rear`入队。`rear`指针会一直向后移动，很快就会到达数组的末尾。但此时，数组的前面部分，因为不断地出队，可能已经空出来很多位置了。这些空间，不就浪费了吗？”

“说得太好了！”黛芙赞许道，“这正是‘普通数组’实现队列的‘**假溢出**’问题。即，数组明明还有空位，但我们却因为`rear`指针到达了物理尽头，而无法再入队。”

“为了解决这个问题，让这些‘被浪费’的空间能被‘循环利用’起来，我们就需要构建一个‘**循环队列**’（Circular Queue）。”

#### **循环队列：逻辑的圆环**

伊莎贝尔拿起桌上的一个琉璃杯，用手指，在圆形的杯口，画着圈。“循环队列，就是将一个线性的、有限的数组，在‘逻辑’上，想象成一个‘**首尾相连**’的圆环。就像这个杯口。”

黛芙在白板上，画出了这个结构。

**数据结构：**
-   一个固定大小的数组 `arr`。
-   两个指针（或下标）：`front` 指向队头元素的位置，`rear` 指向队尾元素**之后**的第一个空位。
-   一个`capacity`变量，表示数组的总容量。

**核心操作：取模运算 (`%`)**
“实现‘循环’的关键，是‘**取模运算**’。”黛芙强调道，“当`front`或`rear`指针，移动到数组的物理末尾时，我们让它‘绕’回数组的开头。这个‘绕’的动作，通过`% capacity`来实现。”

-   `rear = (rear + 1) % capacity` (入队时，`rear`指针的移动)
-   `front = (front + 1) % capacity` (出队时，`front`指针的移动)

#### **满与空的判定：牺牲一个空间**

“但是，这个设计，带来了一个新的、非常微妙的难题。”黛芙提问，“我们如何判断，队列现在是‘**满**’的，还是‘**空**’的？”

希娅很快发现了问题：“如果队列是空的，`front`和`rear`会指向同一个位置。但如果队列是满的，比如容量为8，我们塞满了8个元素，`rear`指针绕了一圈回来，也会和`front`指针指向同一个位置！我们无法区分这两种状态！”

“是的。为了解决这个‘歧义’，我们有两种经典的方法。”

1.  **方法一：使用一个额外的`size`变量。**
    -   用一个`size`变量，来实时记录队列中的元素个数。`size == 0`时为空，`size == capacity`时为满。简单直接，但需要额外维护一个变量。

2.  **方法二：牺牲一个存储空间。**
    -   “这是一种更常用、也更巧妙的约定。”黛芙说，“我们规定，数组中，永远要‘**至少留一个空位**’。我们不把它完全填满。”
    -   **判满条件:** 当`rear`指针，再走一步，就要“追上”`front`指针时，我们就认为队列已满。即：**`(rear + 1) % capacity == front`**。
    -   **判空条件:** 保持不变，`rear == front`。

“通过牺牲一个微不足道的存储单元，我们换来了仅用`front`和`rear`两个指针，就能清晰地、无歧义地，判断队列满与空的能力。”

#### **代码实现**

```cpp
// C++ 循环队列实现 (牺牲一个空间法)
class MyCircularQueue {
private:
    vector<int> data;
    int head; // 队头指针
    int tail; // 队尾指针 (指向下一个可插入位置)
    int capacity;

public:
    MyCircularQueue(int k) {
        capacity = k + 1; // 实际容量为k+1
        data.resize(capacity);
        head = 0;
        tail = 0;
    }

    bool enqueue(int value) {
        if (isFull()) return false;
        data[tail] = value;
        tail = (tail + 1) % capacity;
        return true;
    }

    bool dequeue() {
        if (isEmpty()) return false;
        head = (head + 1) % capacity;
        return true;
    }

    int Front() {
        if (isEmpty()) return -1;
        return data[head];
    }

    bool isEmpty() {
        return head == tail;
    }

    bool isFull() {
        return (tail + 1) % capacity == head;
    }
};
```

安妮看着这个在`head`和`tail`之间，不断追逐、循环的逻辑，感觉自己仿佛在观看一场优雅的双人舞。`tail`指针在前面领舞，不断地探索新的空间；`head`指针在后面跟随，释放掉旧的空间。而取模运算，则像一个无形的“圆形舞台”，让这场舞蹈，得以在有限的空间里，永不落幕地进行下去。这，就是循环队列的、关于空间与秩序的精妙平衡。

---

🌸 **循环队列核心要点** 🌸

**1. 算法设计的根本思想**
- **逻辑环化：** 循环队列的核心，是通过数学技巧（取模运算），将一个物理上“线性”的存储空间，在“逻辑”上，转化为一个“环形”的空间。这是一种典型的、用逻辑来弥补物理局限的思想。
- **指针的相对位置：** 在循环队列中，`front`和`rear`指针的“绝对位置”不再重要，重要的是它们的“相对位置”。队列是否满、是否空、有多少元素，都取决于这两个指针的相对关系。
- **解决“假溢出”：** 循环队列的根本目的，是为了解决普通数组在实现队列时，因一端不断出队而导致的“空间浪费”和“假溢出”问题。

**2. 核心设计哲学**
- **空间的权衡：** “牺牲一个存储单元”来区分“满”和“空”，是一种非常经典、优雅的设计权衡。它用一个极小的、恒定的空间代价，换取了逻辑判断的简洁与高效，避免了引入额外的状态变量（如`size`）。
- **取模运算的本质：** `(index + 1) % capacity` 这个操作，本质上是在做一个“周期性”的映射。它将一个无限增长的、线性的索引，映射回一个`[0, capacity-1]`的有限区间内。
- **并发场景下的挑战：** 在多线程环境中，需要对`head`和`tail`的访问进行“加锁”保护，以避免数据竞争。如何设计一个高效的、无锁的（Lock-Free）并发循环队列，是系统编程领域一个非常深入的挑战。

**3. 算法思维的启发**
- **“循环”的模式：** 当你遇到任何具有“周期性”、“循环”、“轮转”特性的问题时，都可以思考，是否能用“循环数组”或“取模运算”来建模。
- **“相对”代替“绝对”：** 在很多问题中，我们关心的，可能不是某个变量的绝对值，而是几个变量之间的“相对关系”或“差值”。将思考的焦点，从绝对转移到相对，有时能让问题变得更简单。
- **优雅的边界处理：** “牺牲一个单元”的判满技巧，是一种非常优雅的边界处理方式。它告诉我们，有时，对问题定义或实现，做一个小小的、看似“不完美”的妥协，反而能换来整体逻辑的巨大简化。

---

🎀 **安妮的小小日记本**

今天，我见识到了数学的“魔力”！

一个普普通通的数组，只因为它被“取模”了一下，就好像被施了魔法，从一条直直的“走廊”，变成了一个可以无限兜圈的“循环回廊”！

我最佩服的，是那个“故意浪费一个格子”来判断队列是否已满的设计。感觉好有智慧！就像我们在一个房间里，为了保证能顺利开门，我们约定，门前的那一小块地方，永远不许放东西。这个小小的“浪费”，却保证了整个房间的“通畅”。

`head`和`tail`两个指针，就像在回廊里，你追我赶的两个小精灵。`tail`在前面欢快地撒下面包屑（入队），`head`在后面，不紧不慢地，把面包屑捡起来吃掉（出队）。只要`tail`不“套圈”追上`head`，这个游戏就可以一直玩下去。

感觉自己对“数组”这个老朋友，又有了新的认识。原来，只要思想不滑坡，办法总比困难多！一个简单的数组，也能玩出这么多花样！

---

### 今日关键词

- **循环队列 (Circular Queue):** （回顾）使用数组实现队列时，通过逻辑上的“环形”结构，来避免数据搬移，实现高效出入队操作的一种结构。
- **假溢出 (False Overflow):** 在普通数组实现的队列中，当队尾指针到达数组末端，即使数组前面有空闲空间，也无法再入队的现象。
- **取模运算 (`%`):** （回顾）求两个数相除的“余数”。在循环队列中，用于将数组索引“环化”。
- **队空/队满的判断:** 循环队列设计的核心难点。通常通过“牺牲一个空间”或“额外使用一个size变量”来解决。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议：通过亲手实现，来深刻理解循环队列的指针移动和边界判断。

**练习**  
1.  LC 622. Design Circular Queue ⭐⭐ —— （回顾）设计循环队列。这是循环队列的标准模板题，要求你用数组，完整地实现一个循环队列，并处理好`head`, `tail`指针的移动，以及队空、队满的判断。
2.  **用size变量实现循环队列** ⭐⭐ —— 在上一题的基础上，尝试用“额外引入`size`变量”的方式，来重新实现循环队列的`isEmpty`和`isFull`判断，并与“牺牲一个空间”的方法进行比较。
3.  LC 641. Design Circular Deque ⭐⭐ —— （回顾）设计循环双端队列。这是循环队列的“升级版”，要求在两端都能进行增删。你需要用`front`和`rear`两个指针，来共同维护一个环形数组，其指针操作和边界判断，比循环队列更复杂，是绝佳的练习题。
