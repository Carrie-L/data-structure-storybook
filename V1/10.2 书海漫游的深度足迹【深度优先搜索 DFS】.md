### **10.2 书海漫游的深度足迹【深度优先搜索 DFS】**

*"在知识的瀚海中，最执着的旅人，会沿着一条思想的藤蔓，追溯到它最深的根系，然后再回溯，去探索另一片未知的繁花。"*

拥有了图书馆的“地图”（邻接表），安妮心中大定。她的下一个目标，是找到一本关于“古代星辰神话”的珍稀古籍。她只知道这本书被收藏在与区域A（历史区）相连的某个书架上，但具体是哪一个，她完全不清楚。这意味着，她可能需要走遍所有与A区相连的书架。

“有了地图，我该按什么策略来寻找呢？”安妮看着自己画的草图，向学姐们求助，“我不想像无头苍蝇一样，在A区、B区、C区之间来回乱跑，那样肯定会晕头转向。我想要一个系统性的方法，能保证我走遍所有相连的书架，一个都不会漏掉。”

“这正是图遍历算法要解决的核心问题：如何设计一条‘寻访路线’，能不重不漏地访问图中的每一个顶点。”黛芙说道。

“你可以试试‘一条路走到黑’的策略。”伊莎贝尔温柔地提示，“这是一种非常符合人类直觉的探索方式。想象一下，你现在在A区。”

1.  “你从A区出发，随便选择一条没走过的路，比如，通往B区（神话区）的路。”
2.  “到达B区后，**不要回头**，而是继续从B区出发，再选择一条新的、没走过的路，比如通往C区（艺术区）。”
3.  “就这样，一直深入下去，直到你到达一个‘死胡同’——比如，你到了F区，发现所有与F区相连的路，都通往你已经去过的书架。”

“到了‘死胡同’，我该怎么办呢？”安妮顺着思路问道。

“原路返回一步。”伊莎贝尔微笑着说，“退回到你上一个经过的路口，看看那里还有没有别的岔路是你没走过的。如果有，就走上那条新岔路，继续‘一条路走到黑’。这个策略，就像在书海中留下一串深深的、连续的足迹，我们称之为——**深度优先搜索（Depth-First Search, DFS）**。”

#### **DFS的实现之一：递归的优雅**

“‘退回到上一个路口，再探索别的岔路’，这种‘回溯’（Backtracking）的行为模式，让你想到了我们哪位熟悉的老朋友？”黛芙提问道。

“**递归！**”安妮立刻回答。递归函数在执行完毕后，会自动返回到上一层调用的状态，这与DFS的回溯行为完美契合。

“没错。DFS的递归实现，非常简洁和优雅。”黛芙开始在白板上勾勒算法的轮廓。

“首先，为了不在图书馆里兜圈子，我们必须有一个‘访问笔记’（一个`visited`集合），记录下所有我们已经去过的书架。去一个新的书架前，先查查笔记，如果去过了，就绝不再去。”

**DFS递归函数 `dfs(vertex)` 的逻辑：**
1.  将当前顶点`vertex`标记为“已访问”，并处理该顶点（比如，检查这个书架上有没有我们要找的书）。
2.  遍历当前顶点`vertex`在邻接表中的所有邻居`neighbor`。
3.  如果邻居`neighbor`还**没有被访问过**，就对它递归调用`dfs(neighbor)`。

```python
graph = { # 邻接表表示的图
    'A': ['B', 'D'],
    'B': ['A', 'C'],
    'C': ['B', 'D'],
    'D': ['A', 'C']
}
visited = set() # 访问笔记

def dfs_recursive(node):
    if node not in visited:
        print(f"访问到: {node}") # 处理节点
        visited.add(node)
        for neighbor in graph[node]:
            dfs_recursive(neighbor)

# 从A点开始深度优先搜索
# dfs_recursive('A')
```

黛芙在图上，一步步地模拟了递归调用的过程：
`dfs('A')` -> 访问A -> 发现邻居B未被访问 -> 调用`dfs('B')`
  `dfs('B')` -> 访问B -> 发现邻居A已被访问 -> 发现邻居C未被访问 -> 调用`dfs('C')`
    `dfs('C')` -> 访问C -> 发现邻居B已被访问 -> 发现邻居D未被访问 -> 调用`dfs('D')`
      `dfs('D')` -> 访问D -> 发现邻居A,C均已被访问 -> **返回**
    `dfs('C')` -> D的邻居已处理完 -> **返回**
  `dfs('B')` -> C的邻居已处理完 -> **返回**
`dfs('A')` -> B的邻居已处理完 -> 发现邻居D已被访问 -> **返回**

“最终的访问顺序可能是：A -> B -> C -> D。你看，它就像一个执着的探险家，沿着一条路径尽可能地走远，直到无路可走，才肯回头。”

#### **DFS的实现之二：栈的坚韧**

“递归的写法虽然优雅，但如果图的深度非常大，可能会导致函数调用层级太深，引发‘栈溢出’（Stack Overflow）。”希娅补充道，“而且，递归的背后，其实就是计算机在帮我们维护一个函数调用栈。我们完全可以自己手动来管理一个**栈（Stack）**，实现一个迭代版的DFS。”

“用栈？”安妮想起了在卷一中学到的“后进先出”的盘子。

“是的。”希娅在白板上写下了迭代版DFS的步骤，“过程就像这样：”

**DFS迭代函数 `dfs_iterative(start_node)` 的逻辑：**
1.  创建一个`stack`和一个`visited`集合。
2.  将起始顶点`start_node`推入栈中。
3.  当栈不为空时，循环执行：
    a. 从栈顶**弹出一个**顶点`vertex`。
    b. 如果`vertex`还未被访问：
        i. 将其标记为“已访问”，并处理它。
        ii. 将其所有**未被访问过**的邻居，**推入**栈中。

```python
def dfs_iterative(start_node):
    stack = [start_node]
    visited = set()
    
    while stack:
        vertex = stack.pop() # 从栈顶弹出一个节点
        
        if vertex not in visited:
            print(f"访问到: {vertex}")
            visited.add(vertex)
            
            # 将邻居逆序推入栈，可以得到和递归版一样的访问顺序
            for neighbor in reversed(graph[vertex]):
                if neighbor not in visited:
                    stack.append(neighbor)
```

希娅也模拟了一遍执行过程：
1.  `stack: [A]`
2.  `pop A`, 访问A, `visited: {A}`, `push D, B` -> `stack: [D, B]`
3.  `pop B`, 访问B, `visited: {A, B}`, `push C` -> `stack: [D, C]`
4.  `pop C`, 访问C, `visited: {A, B, C}`, `push D` (但D已在栈中) -> `stack: [D, D]`
5.  `pop D`, 访问D, `visited: {A, B, C, D}` -> `stack: [D]`
6.  `pop D`, D已被访问，跳过 -> `stack: []`
7.  栈为空，结束。

“访问顺序同样是 A -> B -> C -> D。”希娅总结道，“栈在这里，完美地帮我们扮演了‘记忆岔路口’的角色。每次深入时，我们把其他可能的岔路都压在栈里，等当前的路走完了，再从栈顶取出最近的那个岔路口，继续探索。”

安妮跟随着两种不同的实现方式，在心中将那座图书馆“走”了一遍。她发现，无论是浑然天成的递归，还是严谨坚韧的栈，它们都完美地诠释了深度优先搜索那“不撞南墙不回头”的探索精神。她感觉自己手中那张潦草的“地图”，此刻已经变成了一套可以被精确执行的、强大的寻路程序。

---

🌸 **DFS核心要点** 🌸

**1. 算法设计的根本思想**
- **穷尽探索与回溯：** DFS的本质是一种“不撞南墙不回头”的穷尽式搜索策略。它沿着一条路径不断深入，直到无法再前进时，就“回溯”到上一个分岔口，选择另一条路径继续深入。这个过程，天然地与递归和栈的“后进先出”特性相匹配。
- **连通性的判断：** 一次完整的DFS（从某个起点开始），可以访问到所有与该起点处于同一个“连通分量”中的顶点。因此，DFS是判断图连通性的基本算法。
- **路径查找：** DFS的探索过程，本身就是在寻找一条从起点到某个终点的路径。它的“深度”特性，使其非常适合用于需要找到一条可行路径（不一定是最近的）的场景。

**2. 核心设计哲学**
- **“一条路走到底”的专注：** 与其“广撒网”，DFS更倾向于“深度挖掘”。这种策略在很多问题中非常有效，比如解迷宫（找到出口）、解数独（在一个格子中尝试一个数字，然后深入下去看是否可行）。
- **“记忆”是关键（`visited`集合）：** 如果没有`visited`集合来记录已访问的节点，DFS在有环的图中将会陷入无限循环。因此，“记忆”机制是保证DFS能够正确终止、且每个节点只访问一次的核心。
- **递归的自然表达：** “探索一个顶点的邻居”，可以自然地分解为“探索第一个邻居的子世界”、“探索第二个邻居的子世界”…… 这种问题的自我相似性，使得DFS成为展现递归思想魅力的经典范例。

**3. 算法思维的启发**
- **栈作为“待办事项”列表：** 迭代版的DFS，将栈用作一个“待办事项”或“未来路径”的存储器。栈顶永远是当前最优先要探索的深层路径。这启发我们，可以用栈来管理具有“后进先出”逻辑顺序的任务流。
- **回溯法的基础：** 许多高级的搜索算法，如回溯法（用于解决排列、组合、棋盘等问题），其算法框架都与DFS如出一辙。掌握了DFS，就等于掌握了回溯法的半壁江山。
- **前序遍历的延伸：** 图的DFS，可以看作是树的“前序遍历”在更广义结构上的延伸。在访问一个节点后，立刻去探索它的“孩子们”（邻居）。理解这种从树到图的思想迁移，有助于我们构建统一的知识体系。

---

🎀 **安妮的小小日记本**

今天，我感觉自己像个真正的探险家！

面对图书馆这座巨大的“图”，我不再感到迷茫，因为我学会了深度优先搜索（DFS）这个寻路“咒语”。这个咒语的核心就是“一条路走到黑”！

用递归来实现它，感觉超级优雅，就像是在念一首诗，代码自己就知道该在什么时候前进，什么时候“回溯”。

用栈来实现它，则感觉更像一个严谨的徒步者，背着一个“路标”背包（栈）。每到一个岔路口，就把暂时不走的路标放进背包，然后一往无前。等走到头了，再从背包里拿出最近存放的路标，去探索新的未知。

两种方法，一样的探索精神！我发现，只要有了一个清晰的策略，再复杂的迷宫，也终将被我的足迹所丈量。这种用代码去探索未知世界的感觉，真的太棒了！

---

> **深度优先搜索（Depth-First Search, DFS）**是一种用于遍历或搜索树或图的算法。这个算法会尽可能深地搜索图的分支。当节点v的所在边都已被探寻过，搜索将**回溯**到发现v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个过程反复进行直到所有节点都被访问完毕。DFS的实现通常采用**递归**，或使用一个显式的**栈**来模拟递归过程。

### 今日关键词

- **深度优先搜索 (DFS):** 一种“一条路走到黑”的图遍历算法。
- **递归 (Recursion):** 实现DFS的自然且优雅的方式。
- **栈 (Stack):** 用于实现迭代版DFS的核心数据结构，模拟递归的“后进先出”行为。
- **回溯 (Backtracking):** 当路径走到尽头时，返回上一个节点，尝试其他路径的行为，是DFS的精髓。
- **访问集合 (Visited Set):** 用于记录已访问过的节点，以防止在有环的图中陷入无限循环。
- **连通分量 (Connected Component):** 在无向图中，一个子图，其中任意两个顶点都相互连通。一次DFS可以找到一个连通分量。

### 名词小传

**深度优先搜索（DFS）**的系统性研究，可以追溯到19世纪。法国数学家**Charles Pierre Trémaux**在研究如何走出迷宫时，提出了一种有效的算法，其核心思想与DFS完全一致：在墙上画线以标记路径，绝不重复进入同一条路径，走到死胡同时则返回。然而，将DFS作为一种重要的计算机算法进行形式化描述和分析，则是在20世纪50年代之后，随着计算机科学的发展而逐步完成的。它与广度优先搜索（BFS）一起，构成了图遍历算法的基石，是无数更高级图算法的起点。

### DFS定义

**深度优先搜索（DFS）**是一种图遍历算法，它从一个起始顶点出发，沿着一条路径尽可能深地探索，直到到达一个无法再前进的顶点（死胡同），然后回溯至上一个分岔口，选择另一条未探索的路径继续深入。这个过程不断重复，直到所有与起始顶点连通的顶点都被访问过。为了避免重复访问和在有环图中死循环，DFS需要使用一个数据结构（如集合或布尔数组）来记录已访问过的顶点。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard

**基础入门**
1.  **LC 200 Number of Islands** ⭐⭐
    > **推荐理由**：**DFS/BFS入门必做题**。将二维网格看作一个图，陆地是顶点。从一个未访问的陆地格子开始，用DFS（或BFS）找到所有与它相连的陆地（即整个岛屿），并将它们全部标记为“已访问”。每当你需要选择一个新的、未访问的陆地格子开始DFS时，就意味着你发现了一个新的岛屿。

2.  **LC 695 Max Area of Island** ⭐⭐
    > **推荐理由**：上一题的自然延伸。在每次DFS的过程中，不仅要标记访问，还要用一个计数器记录下当前岛屿的面积。在所有DFS调用中，取最大的那个计数器值即可。

3.  **LC 547 Number of Provinces** ⭐⭐
    > **推荐理由**：输入是一个邻接矩阵，问题本质与“岛屿数量”完全相同，都是寻找图的“连通分量”个数。这道题能让你练习如何在邻接矩阵上进行DFS。

**路径与回溯应用**
4.  **LC 797 All Paths From Source to Target** ⭐⭐
    > **推荐理由**：一道非常纯粹的、考察DFS路径查找能力的题目。你需要用DFS来探索所有可能从起点到终点的路径，并在递归的过程中，维护一个`current_path`列表。当到达终点时，将当前路径的副本加入结果集。

5.  **LC 79 Word Search** ⭐⭐
    > **推荐理由**：在二维网格中进行DFS，寻找一个单词。这道题是回溯思想的经典体现：在进入一个新格子时，先将其标记（例如改成一个特殊字符），防止重复使用；在从这个格子回溯时，再将其恢复原状，以便其他路径可以继续使用它。

6.  **LC 417 Pacific Atlantic Water Flow** ⭐⭐⭐
    > **推荐理由**：一道构思巧妙的图遍历问题。常规思路（从每个点出发看能否流到两大洋）会超时。正确的做法是“逆向思维”：分别从所有与太平洋相连的岸边出发进行DFS/BFS，标记所有能被太平洋水流到的格子；再从与大西洋相连的岸边出发，标记能被大西洋水流到的格子。最后，同时被两种水流标记的格子，就是答案。
