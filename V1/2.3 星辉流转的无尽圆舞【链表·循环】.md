### **2.3 星辉流转的无尽圆舞【链表·循环】**

*"当终点与起点相连，线性的长路，便化为无尽的圆舞。在这永恒的轮回中，每一个节点，都既是开始，也是结束。"*

在为链表装上了可以回溯的“`prev`指针”后，安妮以为，链表的形态，已经达到了完美的境界。但黛芙告诉她，还有一种更特殊的、充满了哲学意味的变体。

“我们之前讨论的所有链表，都有一个明确的‘终点’，那就是一个指向`null`的`next`指针。”黛芙说，“但如果，我们打破这个‘终点’的设定呢？”

伊莎贝尔拿起那条彩色的纸环链，将它的“头”和“尾”，也用一小段胶带，粘在了一起，形成了一个封闭的、美丽的圆环。

“看，”她将这个纸环举到安妮面前，“现在，它没有头，也没有尾了。从任何一个纸环出发，你都可以顺着一个方向，最终回到你自己。这种‘**首尾相连**’的链表，就叫做‘**循环链表**’（Circular Linked List）。”

#### **循环链表：没有终点的旅程**

黛芙在白板上，画出了循环链表的结构。

“它的实现非常简单：只需要将普通单向链表的‘最后一个节点’的`next`指针，不再指向`null`，而是指向‘**头节点**’。”

```ascii
      +---+---+    +---+---+    +---+---+
----->| 1 | ● |-->| 2 | ● |-->| 3 | ● |---
|     +---+---+    +---+---+    +---+---+   |
|           ↑                              |
|          head                            |
+----------------------------------------+
```

“这个小小的改动，却让链表的性质，发生了根本性的变化。”

**特性与优势：**

1.  **无限循环与遍历:** “从任意一个节点出发，我们都可以遍历到链表中的所有其他节点。遍历的终止条件，不再是`current == null`，而是`current.next == head`（当我们再次回到起点时）。”

2.  **从“尾”到“头”的捷径:** “在某些实现中，我们可以只用一个`tail`指针，来代表整个循环链表。”希娅补充了这个巧妙的技巧，“因为通过`tail`，我们可以O(1)地访问到尾节点（`tail`本身），也可以O(1)地访问到头节点（`tail.next`）！这在需要频繁地在头尾进行操作的场景下，非常方便。”

#### **循环链表的应用：时间片轮转**

“这种‘循环往复’的特性，使得循环链表，成为了模拟‘**轮转调度**’问题的天然选择。”黛芙讲解了它最经典的应用场景。

“想象一下，一个CPU，需要为多个正在等待的程序（A, B, C）提供服务。为了公平，它不能一直服务A，而让B和C饿死。于是，‘**时间片轮转调度算法**’（Round-Robin Scheduling）诞生了。”

-   **过程:**
    1.  所有待服务的程序，被放入一个“循环队列”（用循环链表实现）。
    2.  CPU从队头的程序A开始，为它服务一个固定的“时间片”（比如10毫秒）。
    3.  时间片用完后，如果程序A还没执行完，CPU就暂停它，并将它，重新放回“**队尾**”。
    4.  然后，CPU开始为队伍中新的队头程序B，服务一个时间片。
    5.  ……如此循环往复。

“这个过程，就像是老师在给小朋友们轮流发糖，每个人一次一颗，发完一轮，再从头开始。循环链表，完美地模拟了这种‘**公平的、无尽的轮转**’。”

“当然，”黛芙总结道，“我们也可以有‘**双向循环链表**’，它既有`prev`指针，也首尾相连，是功能最强大的链表形态，常用于各种复杂的内核数据结构中，因为它提供了在环上任意节点，进行双向O(1)邻居访问的能力。”

安妮看着那个在伊莎贝尔手中，缓缓转动的纸环。她明白了，数据结构的设计，有时，是在追求一种“逻辑上的完美”。通过打破“终点”的束缚，循环链表创造了一个“无穷”的意象，为那些需要周而复始、公平轮转的现实问题，提供了最优雅、最贴切的数字模型。

---

🌸 **循环链表核心要点** 🌸

**1. 算法设计的根本思想**
- **打破线性边界：** （回顾）循环链表通过将`tail.next`指向`head`，打破了传统线性表的“起点”和“终点”的边界概念，将其转化为一个可以无限循环的环形结构。
- **逻辑上的“环”：** 它是用指针，在逻辑层面，构建了一个“环”，而其在内存中的物理存储，依然是离散的节点。
- **相对性：** 在循环链表中，“头”和“尾”的概念，变得相对。任何一个节点，都可以被看作是遍历的起点。

**2. 核心设计哲学**
- **结构的同构性：** （回顾）循环链表的环形结构，与“轮转”、“循环”、“周期性”这类问题的模型，是天然同构的。选择与问题模型最匹配的数据结构，能让解决方案变得更自然、更简单。
- **指针的精妙用法：** 仅用一个`tail`指针，就能同时代表“尾”和“头”，是链表指针灵活运用的一个极佳范例。它减少了需要维护的外部指针数量，简化了数据结构的管理。

**3. 算法思维的启发**
- **“环”形结构的妙用：** （回顾）在“一致性哈希”等算法中，我们已经见识过“环”形结构的威力。它能优雅地处理边界问题，实现平滑的过渡。在遇到需要“循环”或“取模”特性的问题时，可以联想循环链表。
- **警惕“死循环”：** 在遍历循环链表时，必须小心处理终止条件。如果终止条件设置不当（例如，依然使用`curr != null`），程序就会陷入永不结束的死循环。

---

🎀 **安妮的小小日记本**

今天，我的珍珠项链，变成了一个没有缺口的、完美的“圆环”！

循环链表，这个名字听起来就充满了禅意。它没有开始，也没有结束。从任何一颗珍珠出发，都能遇见所有其他的珍珠，并且最终，回到自己。这就像我们学习的旅程，学得越多，就越发现自己回到了最初的那些基础概念上，但每一次回去，都有新的感悟。

我最喜欢那个“时间片轮转”的比喻！CPU就像一个勤劳的老师，面对一群叽叽喳喳等着被辅导功课的小朋友（程序）。老师不会只盯着一个孩子教，他会给A讲10分钟，然后拍拍他的肩膀说：“你先自己消化一下”，然后走向B，再给他讲10分钟……这样轮流来，保证了每个小朋友都能得到老师的关注，非常公平！

原来，计算机世界里那些看起来很复杂的“公平调度”，其最底层的模型，竟然就是这样一个简单的、手拉手组成的“圆圈”呀！

---

### 今日关键词

- **循环链表 (Circular Linked List):** （回顾）一种链表，其最后一个节点的`next`指针，指向头节点，形成一个环状结构。
- **双向循环链表 (Doubly Circular Linked List):** （回顾）同时具备双向链表和循环链表特性的链表。
- **时间片轮转 (Round-Robin Scheduling):** （回顾）一种操作系统进程调度算法，它将CPU时间划分为一个个“时间片”，轮流地分配给每个就绪进程。
- **约瑟夫环问题 (Josephus Problem):** （回顾）一个经典的、与循环链表或循环队列相关的算法问题。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议：通过实现和应用，来巩固对循环结构的理解。

**练习**  
1.  **手动实现循环链表** ⭐⭐ —— 亲手实现一个循环单向链表类，并实现其`insert`, `delete`, `traverse`等操作。重点在于处理好`tail.next`与`head`之间的连接关系，以及遍历时的终止条件。
2.  **约瑟夫环问题 (Josephus Problem)** ⭐⭐ —— （回顾）N个人围成一圈，从第K个人开始报数，报到M的人出局，然后从下一个人开始重新报数，直到剩下最后一个人。用你实现的循环链表，来完整地模拟这个过程，并找出最后的胜利者。
3.  LC 622. Design Circular Queue ⭐⭐ —— （回顾）设计循环队列。虽然这道题通常用“循环数组”来实现，但你也可以尝试用“循环链表”来实现它。比较一下，两种实现方式，在逻辑和性能上，各有什么优缺点？
