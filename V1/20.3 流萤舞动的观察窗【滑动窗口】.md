### **20.3 流萤舞动的观察窗【滑动窗口】**

*"我打开一扇窗，窥见一段流动的风景。窗的左沿收缩，右沿扩张，于这伸缩之间，便框住了整个夏夜最美的瞬间。"*

在学习了Trie树和Z算法这些处理字符串前缀和模式的“重型武器”后，黛芙决定，介绍一种更轻量、更灵活、也更常见的算法技巧——“**滑动窗口**”（Sliding Window）。

“并非所有字符串问题，都需要复杂的预处理或数据结构。”黛芙说，“很多时候，问题只是要求我们，在一个长序列中，找到一个满足特定条件的‘**连续子串**’或‘**连续子数组**’。对于这类问题，滑动窗口是一种非常优雅和高效的解法。”

时值夏末初秋的夜晚，她们仍在营地。夜空中，几只流萤，拖着微弱的绿光，在草丛间飞舞，时隐时现。

“看那几只萤火虫，”伊莎贝尔指着远方，“想象一下，我们的眼睛，就是一扇‘**窗口**’。我们想透过这扇窗，找到一段‘包含了最多萤火虫’的风景。我们会怎么做？”

“我们会移动我们的视线，”安妮说，“当右边的视野里出现新的萤火虫时，我们会把视线（窗口）向右扩大，把它包含进来。但如果，我们发现窗口里的风景不满足某些条件了（比如，窗口太宽了，或者里面的萤火虫种类不对），我们可能就需要把左边的视野收缩一下，放弃掉一些左边的风景。”

“这，就是滑动窗口的全部精髓！”伊莎贝尔笑道，“它用两个指针，`left`和`right`，构成了一个‘窗口’。`right`指针负责‘**扩张**’窗口，探索新的元素；`left`指针则负责‘**收缩**’窗口，放弃旧的元素。在这一扩一缩之间，我们就能以线性的时间，扫过所有的子数组，并找到我们想要的答案。”

#### **滑动窗口的通用框架**

“滑动窗口的题目，通常都可以套用一个非常相似的框架。”黛芙在白板上写下了它的通用伪代码。

```python
def sliding_window(s: str):
    left, right = 0, 0
    window_data = ... # 用于记录窗口内数据的状态，如字符计数等
    result = ... # 最终结果

    while right < len(s):
        # 1. 扩张窗口：将 right 指针指向的元素移入窗口
        char_in = s[right]
        right += 1
        # 更新窗口数据...

        # 2. 判断与收缩：当窗口不再满足要求时，收缩左边界
        while window_needs_to_shrink():
            # 将 left 指针指向的元素移出窗口
            char_out = s[left]
            left += 1
            # 更新窗口数据...

        # 3. 更新结果：在窗口收缩完毕，再次满足条件时，更新结果
        # ...
    return result
```

“这个框架的核心，就是外层的`while`循环驱动`right`指针前进，和内层的`while`循环在必要时驱动`left`指针前进。由于两个指针都只从左到右移动，绝不后退，所以整个算法的时间复杂度，就是O(N)。”

#### **实例：寻找最长无重复子串**

“我们来看一道最经典的滑动窗口题：**LC 3. 无重复字符的最长子串**。”

**问题：** 给定一个字符串`s`，请你找出其中不含有重复字符的**最长子串**的长度。
例如: `s = "abcabcbb"` -> 结果是`"abc"`，长度为3。
`s = "pwwkew"` -> 结果是`"wke"`，长度为3。

“我们来套用一下刚才的框架。”

1.  **`window_data`需要什么？**
    -   我们需要一个数据结构，能快速地告诉我们“窗口内每个字符出现了多少次”。一个哈希表（`dict`或`Counter`）是完美的选择。

2.  **`window_needs_to_shrink()`的条件是什么？**
    -   当新移入窗口的字符`char_in`，它在窗口内的计数`window_counts[char_in]`大于1时，说明出现了重复，窗口需要收缩。

3.  **如何收缩？**
    -   不断地移动`left`指针，并将`s[left]`这个字符的计数减一，直到重复的那个字符被移出窗口为止。

4.  **如何更新结果？**
    -   在每一次`right`指针扩张后，我们都得到了一个新的、不含重复字符的窗口。它的长度是`right - left`。我们用这个长度，去更新我们记录的`max_length`。

```python
def length_of_longest_substring(s: str) -> int:
    left, right = 0, 0
    window_counts = {}
    max_length = 0

    while right < len(s):
        char_in = s[right]
        right += 1
        window_counts[char_in] = window_counts.get(char_in, 0) + 1

        # 当发现重复时，收缩窗口
        while window_counts[char_in] > 1:
            char_out = s[left]
            left += 1
            window_counts[char_out] -= 1
        
        # 更新结果
        max_length = max(max_length, right - left)

    return max_length
```

安妮看着这段代码，感觉豁然开朗。一个看似需要O(N²)暴力求解（枚举所有子串）的问题，通过`left`和`right`两个指针的精妙配合，像一只灵动的萤火虫一样，在O(N)的时间内就完成了对整个字符串的“扫描”和“勘探”。

---

🌸 **滑动窗口核心要点** 🌸

**1. 算法设计的根本思想**
- **双指针与区间：** 滑动窗口本质上是“双指针”技巧的一种特例。`left`和`right`两个指针，共同构成了一个动态变化的“区间”（窗口），算法的核心，就是对这个区间的维护和更新。
- **避免重复计算：** 暴力解法的低效，在于它对每个子串都进行了重复的检查。而滑动窗口通过“增量”的方式来移动窗口（右指针移动一步，左指针可能移动若干步），巧妙地复用了上一个窗口的计算结果，避免了从头开始。
- **单调性：** 滑动窗口的两个指针`left`和`right`，都始终保持着“只向右移动，不后退”的单调性。这个性质，是其线性时间复杂度的根本保证。

**2. 核心设计哲学**
- **通用框架：** 滑动窗口技巧具有高度的“模板化”特征。大多数相关问题，都可以归结为思考“需要维护什么窗口数据？”、“何时收缩？”、“何时更新结果？”这三个核心问题。
- **“扩张”与“收缩”的博弈：** 算法的推进，是`right`指针不断扩张，试图将更多元素纳入考察范围；而`left`指针则在`right`扩张导致不满足条件时，被迫收缩，以维持窗口的“合法性”。这一扩一缩的动态平衡，构成了算法的主体。
- **问题的转化：** 很多问题都可以转化为滑动窗口问题。例如，“寻找包含目标子串的最小子串”、“寻找和为定值的最长/最短子数组”等。

**3. 算法思维的启发**
- **从“子串”到“窗口”：** 在思考连续子数组/子串问题时，建立“窗口”的思维模型。不要去想“如何枚举所有子串”，而是去想“如何移动一个窗口，来扫过所有可能的解”。
- **状态的维护：** 思考如何用一个高效的数据结构（通常是哈希表）来维护窗口内的状态。这个数据结构，必须能支持快速地“添加”新元素和“删除”旧元素。
- **识别适用场景：** 当题目要求在“连续”的子数组或子串上，寻找满足某些条件的“最长”、“最短”、“最大”、“最小”或“是否存在”时，就应该立刻对滑动窗口保持高度警惕。

---

🎀 **安妮的小小日记本**

滑动窗口，这个名字太形象了！

我感觉自己就像一个摄影师，`left`和`right`指针，就是我手里的变焦镜头。`right`指针负责把远处的风景拉近（扩大窗口），`left`指针则负责切掉画面边缘多余的部分（收缩窗口）。我的任务，就是在这一推一拉之间，抓拍到那幅最完美的“构图”（符合条件的子串）。

以前我看到“最长子串”这种问题，第一反应就是用两个`for`循环去暴力枚举，但那样太慢了。滑动窗口只用两个指针，从头走到尾，就把所有情况都聪明地考虑到了，时间一下子就从O(N²)变成了O(N)！

我发现，很多高效的算法，都是在想办法“减少重复”。DP用备忘录来减少重复计算，而滑动窗口，则用两个指针的协同移动，来避免对子串的重复扫描。算法的世界，真是充满了“偷懒”的智慧呀！

---

### 今日关键词

- **滑动窗口 (Sliding Window):** 一种基于双指针的算法技巧，用于解决数组或字符串中的子区间问题。它通过维护一个动态的窗口，并在线性时间内扫描整个序列来找到最优解。
- **双指针 (Two Pointers):** （回顾）使用两个指针在序列上进行移动，以解决问题的一种常用技巧。滑动窗口是其一种形式，此外还有“快慢指针”、“左右指针”等。
- **连续子串/子数组 (Contiguous Substring/Subarray):** 指在原始序列中，位置是连续的一部分。
- **哈希表 (Hash Table):** 在滑动窗口问题中，常用于存储窗口内元素的频率或信息，以便进行O(1)的查询和更新。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（固定窗口/简单条件）**  
1.  LC 3. Longest Substring Without Repeating Characters ⭐⭐ —— （回顾）无重复字符的最长子串。滑动窗口最经典的入门题。
2.  LC 438. Find All Anagrams in a String ⭐⭐ —— 找到字符串中所有字母异位词。窗口的大小是固定的（等于目标词的长度），在窗口滑动时，维护窗口内各字符的频率，并与目标词的频率进行比较。
3.  LC 567. Permutation in String ⭐⭐ —— 字符串的排列。与上一题几乎完全一样，只是要求判断“是否存在”，而不是找出所有位置。

**进阶巩固（可变窗口/复杂条件）**  
4.  LC 76. Minimum Window Substring ⭐⭐⭐ —— 最小窗口子串。在一个字符串`S`中，找到一个最短的子串，要求包含字符串`T`中的所有字符。这是滑动窗口技巧的集大成者，需要同时维护`window`和`need`两个哈希表，逻辑较为复杂。
5.  LC 209. Minimum Size Subarray Sum ⭐⭐ —— 和大于等于target的最短子数组。窗口内维护一个`sum`，当`sum >= target`时，记录长度并尝试收缩左边界，是可变窗口的经典应用。
6.  LC 1004. Max Consecutive Ones III ⭐⭐ —— 最大连续1的个数III。问题可以转化为“找到一个最长的子数组，其中最多包含K个0”。用滑动窗口来维护窗口内0的个数，即可求解。
