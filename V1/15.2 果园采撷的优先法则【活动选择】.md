### **15.2 果园采撷的优先法则【活动选择】**

*"我并不在意果实有多甜美，我只选择那颗最先成熟的。因为我知道，摘下它，我才能拥有采撷整个果园的、最多的可能。"*

在理解了贪心算法“瞬间心动”的本质与风险后，安妮迫切地想知道，到底在什么样的问题上，贪心选择是可靠的。

秋日祭典的第二天，社团活动是去学校的生态果园，帮助采摘成熟的苹果。果园里，一排排的苹果树硕果累累，散发着诱人的果香。

“今天的任务，”黛芙宣布道，“就是‘**活动选择问题**’（Activity Selection Problem）的现实版。”

她指着果园的日程表：“这里有很多需要采摘的区域，每个区域都有一个‘开始采摘时间’和一个‘结束采摘时间’。我们的帮工时间是有限的，一次只能在一个区域采摘。我们的目标是，在一天之内，尽可能多地完成不同区域的采摘任务（即参加尽可能多的‘活动’）。”

**日程表 (活动列表):**
`[ [1, 4], [3, 5], [0, 6], [5, 7], [3, 9], [5, 9], [6, 10], [8, 11], [8, 12], [2, 14], [12, 16] ]`
(每个元组代表 `[开始时间, 结束时间]`) 

“面对这么多时间有重叠的活动，我们该如何选择呢？”黛芙问道。

#### **贪心策略的思辨**

“我来试试！”安妮积极地思考起来，“我们可以尝试几种贪心策略。”

1.  **策略一：选择开始时间最早的活动？**
    -   “听起来很合理，先到先得嘛。”希娅说。
    -   安妮马上找到了反例：“日程表里，开始最早的是`[0, 6]`。但如果我们选了它，在时间6之前，我们就什么都做不了了。而实际上，我们可以先完成`[1, 4]`，再完成`[5, 7]`，能做两件事。所以这个策略不对。”

2.  **策略二：选择持续时间最短的活动？**
    -   “这个也很有道理，速战速决，才能做更多事。”
    -   安妮又找到了反例：“假设有三个活动`[4, 7]`（持续3小时），`[3, 5]`（持续2小时），`[6, 8]`（持续2小时）。持续时间最短的是`[3, 5]`和`[6, 8]`。但如果我们选了`[4, 7]`，它会和另外两个都冲突，我们只能做一个活动。而选择`[3, 5]`和`[6, 8]`，却可以做两个。所以这个策略也不对。”

“非常棒的分析！”黛芙赞许道，“你通过举反例，证明了这两种最直观的贪心策略都是错误的。那么，正确的贪心选择应该是什么？”

#### **结束时间的优先法则**

伊莎贝尔微笑着，摘下一个苹果，递给安妮。“安妮，你看。要想采到更多的苹果，关键不在于你什么时候‘开始’摘，也不在于你摘一颗苹果要花‘多久’。关键在于，你什么时候能‘结束’这一次采摘，然后腾出手来，去摘下一个。”

安妮的眼睛一亮：“我明白了！我应该优先选择那个‘**结束时间最早**’的活动！”

“为什么？”黛芙追问。

“因为……”安妮组织着语言，“一个活动，它结束得越早，就意味着它占用的时间段越靠前，从而为后面的活动，留出了越多的、可供选择的空闲时间。这使得我更有可能安排下更多的活动。”

“这正是‘贪心选择性质’在此问题上的体现！”黛芙总结道，“**在所有当前可选的活动中，选择那个结束时间最早的活动，这个局部最优选择，一定可以导向全局最优解。**”

**证明思路（反证法）：**
假设存在一个最优解，它没有包含第一个结束的活动`A1`，而是包含了另一个活动`Ax`。因为`A1`是第一个结束的，所以`A1`的结束时间一定早于或等于`Ax`的结束时间。这意味着，我们可以用`A1`替换掉`Ax`，而不会影响后续任何活动的选择，得到的新解至少和原最优解一样好。因此，总存在一个最优解，它包含了第一个结束的活动。以此类推，该贪心策略是正确的。

#### **算法实现**

“所以，我们的算法步骤就非常清晰了。”

1.  **排序:** 将所有活动，按照它们的**结束时间**，从早到晚进行升序排序。
2.  **贪心选择:**
    -   选择第一个活动（它必然是结束最早的），加入我们的最终活动列表，并记录下它的结束时间 `end_time`。
    -   遍历剩余的已排序活动。对于每个活动，如果它的**开始时间**，大于或等于我们记录的 `end_time`（意味着它与我们已安排的活动不冲突），我们就选择它，并更新 `end_time` 为这个新活动的结束时间。

```python
def activity_selection(activities: list[list[int]]) -> list[list[int]]:
    if not activities:
        return []
    
    # 1. 按结束时间升序排序
    activities.sort(key=lambda x: x[1])
    
    # 2. 贪心选择
    result = []
    # 2.1 选择第一个活动
    result.append(activities[0])
    last_end_time = activities[0][1]
    
    # 2.2 遍历剩余活动
    for i in range(1, len(activities)):
        current_start_time = activities[i][0]
        if current_start_time >= last_end_time:
            result.append(activities[i])
            last_end_time = activities[i][1]
            
    return result
```

“这个算法，在排序之后，只需要一次线性扫描，所以总的时间复杂度就是排序的复杂度，O(N logN)。”

果园里的采摘，在贪心策略的指导下，变得井然有序。女孩们总是在完成一片区域后，迅速地奔赴下一片最早可以开工的区域。阳光下，她们的笑声和苹果的香甜，共同构成了一幅秋日丰收的、最优化画卷。

---

🌸 **贪心算法核心要点** 🌸

**1. 算法设计的根本思想**
- **寻找贪心标准：** 解决贪心问题的核心，是找到那个正确的“贪心标准”。对于活动选择问题，这个标准就是“结束时间最早”，而不是更直观的“开始时间最早”或“持续时间最短”。
- **排序是贪心的伙伴：** 许多贪心算法，都需要先对输入数据进行排序，以便于进行局部最优选择。排序为贪心策略的实施，创造了必要的前提条件。
- **构建解集：** 贪心算法通过一个循环，不断地将符合当前局部最优的元素，加入到最终的解集中，一步步地、不可撤销地构建出全局最优解。

**2. 核心设计哲学**
- **面向未来的选择：** “选择结束时间最早”的策略，其深层含义是“为未来留下最多的可能性”。这是一种极具远见的贪心，它不只看当前利益，而是看哪个选择能让未来的选择空间最大化。
- **证明的重要性：** 活动选择问题，是展示“如何思考并证明一个贪心策略正确性”的经典范例。通过反证法，我们可以严谨地证明，每一步的贪心选择，都不会让我们错失最优解。
- **DP vs. 贪心：** 这个问题也可以用DP解决，但其状态定义和转移会复杂得多。而贪心法则提供了一个极其简洁、高效的解法。这说明，对于同时具有最优子结构和贪心选择性质的问题，贪心是比DP更优先的“利器”。

**3. 算法思维的启发**
- **反例驱动的思考：** 在不确定一个贪心策略是否正确时，积极地去寻找它的“反例”，是最高效的证伪方法。如果找不到反例，再尝试去证明其正确性。
- **排序的预处理价值：** 再次印证了排序作为“预处理”步骤的巨大价值。排序本身不解决问题，但它能创造出一种“秩序”，使得后续的贪心选择变得简单而明确。
- **从问题本质出发：** 为什么是“结束时间”？因为它直接决定了下一个活动“最早可以开始”的时间，这正是我们优化目标（活动数量）的关键约束。深入分析问题的核心约束，是找到正确贪心标准的钥匙。

---

🎀 **安妮的小小日记本**

今天的果园采摘，简直就是一堂生动的贪心算法课！

一开始，我本能地觉得应该先去摘那些最早可以开工的果树，或者先摘那些最好摘（用时最短）的。但很快就发现，这样可能会让我错过更多的机会。比如，为了摘一个需要很久的大果园，结果旁边好几个小果园的采摘时间都错过了。

伊莎贝尔学姐一语点醒了我：关键不是别的，而是“我什么时候能腾出手”！所以，我应该优先选择那些能让我最快“完工”的活动。这样，我才能拥有最多的时间，去迎接下一个挑战。

这个“结束时间最早”的策略，听起来有点反直觉，但仔细一想，真的好有道理！它不是只看眼前，而是做出一个对“未来”最有利的选择。原来，最高明的“贪心”，是“贪”得最有远见！

---

### 今日关键词

- **活动选择问题 (Activity Selection Problem):** 也称区间调度问题，是一类经典的贪心算法问题。旨在从一堆时间上有重叠的活动中，选出一个数量最多的、互不冲突的活动子集。
- **区间调度 (Interval Scheduling):** 活动选择问题的另一个名字。
- **贪心标准 (Greedy Criterion):** 在贪心算法中，用于进行局部最优选择的规则或标准。
- **反证法 (Proof by Contradiction):** 一种数学证明方法，通过假设一个命题不成立，并从该假设推导出逻辑矛盾，来证明该命题的正确性。常用于证明贪心算法的正确性。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（经典模型练习）**  
1.  LC 435. Non-overlapping Intervals ⭐⭐ —— 无重叠区间。这道题是活动选择问题的“反面”。它要求计算“最少需要移除多少个区间，才能使剩余区间不重叠”。这等价于“最多能保留多少个不重叠的区间”，是活动选择模型的直接应用。
2.  LC 452. Minimum Number of Arrows to Burst Balloons ⭐⭐ —— 用最少数量的箭引爆气球。将每个气球的直径看作一个区间，问题转化为“需要多少个点，才能覆盖所有区间”。其贪心策略与活动选择惊人地相似：按区间的“结束点”排序，然后每次在结束点放箭，并看这支箭能穿透多少个后续的气球。

**进阶巩固（模型变种与应用）**  
3.  LC 1288. Remove Covered Intervals ⭐⭐ —— 删除被覆盖区间。先按起始点排序，如果起始点相同则按结束点降序排序。然后遍历，看当前区间是否被前一个“大”区间完全覆盖。这是排序+贪心思想的巧妙结合。
4.  LC 56. Merge Intervals ⭐⭐ —— （回顾）合并区间问题。先按起始点排序，然后贪心地合并所有能合并的区间。这里的贪心策略是“如果当前区间和结果集里的最后一个区间有重叠，就尽可能地扩展结果集里最后一个区间的边界”。
5.  LC 763. Partition Labels ⭐⭐ —— 划分字母区间。一个非常巧妙的贪心问题。先遍历一遍，记录下每个字母最后出现的位置。然后再次遍历，维护一个当前分区的“最远结束边界”，当遍历到这个边界时，就完成了一次划分。
