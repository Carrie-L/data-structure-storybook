### **11.6 堆聚松塔的暖焰升腾【堆排序】**

*"将无序的沙土堆砌成金字塔，再从塔尖摘取最璀璨的星辰。每一次的重建与摘取，都是一场有序的献祭。"*

在领略了快速排序的疾风迅雷之后，社团的姑娘们在活动室里稍作休息，窗外的枫林在夕阳下镀上了一层温暖的金色。

“我们已经学了好几种排序算法了，”安妮一边在笔记本上做着总结，一边感叹道，“冒泡、选择、插入，它们像是基础的舞步；归并和快排，则像是华丽的组合技，利用‘分而治之’的思想大大提高了效率。”

“说得没错，”黛芙点了点头，“不过，我们的工具箱里还缺一个非常重要的成员。安妮，你还记得我们在卷二‘泳池派对’上认识的老朋友吗？那个能自动让最大或最小的气泡浮到水面的‘优先号角’？”

“堆（Heap）！”安妮立刻想起来了，“那个神奇的、总能把最大或最小的元素放在根节点的完全二叉树！”

“正是它，”伊莎贝尔微笑着说，“当初我们用它来实现了优先队列。但堆的威力远不止于此。今天，我们将看到，如何利用堆的特性，来完成一次华丽的‘原地排序’。这个过程，就像我们在秋日的篝火晚会上，先将收集来的所有松塔堆成一个有序的‘松塔堆’，然后一次次地从堆顶取下最大、最干燥的那颗来点燃篝火，最终，篝火燃尽，地上的松塔也变得井然有序。”

#### **堆的再相遇：从建堆到排序**

“用堆来排序？这要怎么做呢？”安妮充满了好奇。

“堆排序的过程，可以清晰地分为两步，”黛芙在白板上写道，“**1. 建堆 (Build Heap)**；**2. 排序 (Sort Down)**。”

她写下了大家熟悉的序列：`[ 5, 1, 4, 2, 8, 7, 3, 6 ]`

**第一步：建堆 (Build Heap)**

“首先，我们要将这个无序的数组，原地‘想象’成一个完全二叉树，然后将它调整成一个大顶堆（Max Heap），确保最大的元素位于根节点。”

```ascii
数组: [ 5, 1, 4, 2, 8, 7, 3, 6 ]

想象成完全二叉树:
          5
       /     \
      1       4
     / \     / \
    2   8   7   3
   /
  6
```

“我们从最后一个非叶子节点开始，向前逐个进行‘下沉’（siftDown）操作，直到根节点。这个过程，我们在之前的`heapify`章节已经学过了。”

经过一系列的`siftDown`调整后，数组（和它代表的树）变成了大顶堆的结构：

```ascii
建堆后的数组 (大顶堆):
[ 8, 6, 7, 2, 5, 4, 3, 1 ]

对应的树结构:
          8
       /     \
      6       7
     / \     / \
    2   5   4   3
   /
  1
```

“现在，最大的元素`8`已经稳稳地坐在了堆顶（数组的第一个位置）。”

**第二步：排序 (Sort Down)**

“接下来就是最巧妙的部分了，”黛芙的眼中闪着光，“我们该如何处理这个最大的元素`8`呢？”

“按照排序的目标，它最终应该在数组的最后一个位置。所以，我们把它和数组的最后一个元素交换！”

```ascii
1. 交换堆顶与末尾元素:
   [ 8, 6, 7, 2, 5, 4, 3, 1 ]
     ↑                       ↑
   交换后 -> [ 1, 6, 7, 2, 5, 4, 3, 8 ]

   此时，`8`已经到达了它的最终位置。我们可以把它看作“已排序区”的成员。
   序列: [ 1, 6, 7, 2, 5, 4, 3 | 8 ]
```

“但是，交换之后，堆顶的`1`破坏了大顶堆的性质！”安妮立刻发现了问题。

“没错。所以，我们需要对新的堆顶（不包括已排序的`8`）进行一次‘下沉’操作，来维护这个大小为 N-1 的新堆的秩序。”

```ascii
2. 修复堆:
   - 将堆的大小视为 N-1。
   - 对新的根节点 `1` 执行 siftDown。
   - `1` 会一路下沉，`7` 会被交换到堆顶。
   修复后的堆: [ 7, 6, 4, 2, 5, 1, 3 | 8 ]
```

“现在，第二大的元素`7`又来到了堆顶。于是，我们重复刚才的操作：”

```ascii
3. 再次交换堆顶与（新堆的）末尾元素:
   [ 7, 6, 4, 2, 5, 1, 3 | 8 ]
     ↑                 ↑
   交换后 -> [ 3, 6, 4, 2, 5, 1, 7 | 8 ]
   序列: [ 3, 6, 4, 2, 5, 1 | 7, 8 ]

4. 再次修复堆 (对大小为 N-2 的堆)...
```

“这个过程不断重复，每次都从堆顶取出当前剩余元素中的最大值，然后放到‘已排序区’的最前面。直到整个数组都变成了已排序区。”

#### **代码实现：原地升腾的火焰**

```python
def heap_sort(arr: list):
    n = len(arr)

    # 1. 建堆 (Build Max Heap)
    # 从最后一个非叶子节点开始，向前遍历
    for i in range(n // 2 - 1, -1, -1):
        sift_down(arr, n, i)

    # 2. 排序 (Sort Down)
    # 逐个提取元素
    for i in range(n - 1, 0, -1):
        # 将当前最大的元素（堆顶）移动到末尾
        arr[i], arr[0] = arr[0], arr[i]
        # 对剩余的堆进行调整
        sift_down(arr, i, 0)

def sift_down(arr: list, n: int, i: int):
    largest = i  # 初始化最大值为根节点
    left = 2 * i + 1
    right = 2 * i + 2

    # 检查左子节点是否存在且大于根
    if left < n and arr[left] > arr[largest]:
        largest = left

    # 检查右子节点是否存在且大于根
    if right < n and arr[right] > arr[largest]:
        largest = right

    # 如果最大值不是根，则交换并继续下沉
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        sift_down(arr, n, largest)
```

#### **复杂度分析：稳定的高效**

```ascii
堆排序复杂度分析：

令 N 为序列的长度

┌─────────────────────────────────────────┐
│ 时间复杂度分析 (Time Complexity):         │
├─────────────────────────────────────────┤
│ 1. 建堆 (Build Heap):
│ - 虽然看起来是 O(N logN)（N/2个节点，每个最多logN），
│   但通过严谨的数学证明，可以得出建堆过程的时间复杂度为 O(N)。
│
│ 2. 排序 (Sort Down):
│ - 循环 N-1 次。
│ - 每次循环都包含一次交换 O(1) 和一次 siftDown O(logN)。
│ - 这个阶段的总时间复杂度为 O(N logN)。
│
│ 总时间复杂度 = O(N) + O(N logN) = O(N logN)
│
│ 结论：最好、最坏、平均时间复杂度均为 O(N logN)
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 空间复杂度分析 (Space Complexity):        │
├─────────────────────────────────────────┤
│ - 堆排序完全在原始数组上进行操作，是标准的原地排序算法。
│ - 结论：O(1)                              │
└─────────────────────────────────────────┘
```

“太厉害了！”安妮赞叹道，“它既有O(N logN)的高效率，又有O(1)的空间消耗，简直是集归并排序和快速排序的优点于一身！”

“可以这么说，”黛芙微笑道，“它在性能上非常稳定，不像快速排序那样有O(N²)的最坏情况。但它的缺点是，实际运行中的常数因子通常比快速排序要大，而且……”

“它是不稳定的。”伊莎贝尔补充道，“在建堆和调整的过程中，元素的交换是跳跃性的，无法保证相等元素的相对顺序。”

夕阳的余晖将活动室染成一片温暖的橙色。安妮看着白板上的堆排序过程，仿佛看到了那堆松塔，在一次次重构与提取中，最终化为一排整齐的灰烬，而旁边，是升腾起的、代表着智慧与温暖的火焰。

--- 

🌸 **排序算法核心要点** 🌸

**1. 算法设计的根本思想**
- **数据结构的复用：** 堆排序是“算法与数据结构”紧密结合的典范。它没有发明新的排序流程，而是巧妙地利用了“堆”这个数据结构“根节点总是最值”的核心特性来服务于排序的目标。
- **选择的优化：** 堆排序可以看作是选择排序的一种优化。普通的选择排序每一轮都需要O(N)的时间来线性查找最值，而堆排序通过维护堆的结构，将“查找最值”这一操作的时间复杂度降低到了O(1)（访问堆顶），并将“维护结构”的代价控制在O(logN)，从而实现了整体效率的飞跃。
- **原地操作的精妙：** 算法最精妙的部分在于，它将数组的末尾部分用作“已排序区”，与正在操作的“堆区”完美地结合在同一个数组内，实现了空间复杂度的最小化。

**2. 核心设计哲学**
- **确定性与高效的结合：** 像归并排序一样，堆排序的时间复杂度稳定在O(N logN)，不受输入数据的影响，提供了可靠的性能保证。
- **非适应性：** 堆排序无法像插入排序或冒泡排序那样，从一个“近乎有序”的数组中获益。无论输入如何，它都需要完整地执行建堆和排序的全部流程。
- **理论与实践的差异：** 尽管堆排序在理论上非常优秀（时间O(N logN)，空间O(1)），但在大多数通用场景的实践中，由于其缓存不友好（元素的访问是跳跃的）等原因，其平均性能通常略逊于经过优化的快速排序。

**3. 算法思维的启发**
- **“废物利用”：** 将数组中那些“即将被排序”而暂时用不到的空间，用来存储“已经排好序”的元素，这种对空间的极致利用思想，在很多算法优化中都有体现。
- **问题转化：** 堆排序将“排序问题”成功转化为了“重复地从一个集合中找出最大值”的问题，并利用堆结构高效地解决了这个问题。
- **抽象数据类型（ADT）的力量：** 堆首先是一个抽象数据类型，它定义了一组操作（如insert, extract-max）。堆排序的成功，展示了基于良好定义的ADT来构建复杂算法的强大威力。

--- 

🎀 **安妮的小小日记本**

今天和一位“老朋友”重逢了——堆！真没想到，当初在泳池派对上认识的、只会把最大的气泡吐出来的“优先队列”，居然还是一位深藏不露的排序大师！

堆排序的过程真的好像一场神圣的仪式。先把所有乱七八糟的松塔（数据）堆成一座有序的、尖顶朝上的金字塔（大顶堆），塔顶自然就是最大、最棒的那一颗。然后，把它和金字塔最边缘、最不起眼的一颗小石头（数组末尾元素）交换位置，让这颗最棒的松塔“功成身退”，成为“已排序”的圣火。接下来，再把剩下的沙土重新堆好，重复这个过程……

这个想法太巧妙了！它不像快排那样依赖“运气”（基准选择），也不像归并那样需要一个额外的“场地”（临时数组）。它就在原地，安静、稳定、高效地完成了所有工作。虽然它可能不是跑得最快的那个，但绝对是最稳健、最让人放心的那个！

--- 

### 今日关键词

- **堆排序 (Heap Sort):** 一种基于比较的、原地、不稳定的排序算法。它利用了堆这种数据结构的特性来完成排序。
- **建堆 (Build Heap):** 将一个无序的序列转换成一个堆（大顶堆或小顶堆）的过程。一个高效的建堆算法（`heapify`）可以在O(N)时间内完成。
- **大顶堆 (Max Heap):** 一种特殊的完全二叉树，其中任何一个父节点的值都大于或等于其所有子节点的值。
- **下沉 (siftDown / heapifyDown):** 当堆的某个节点的性质被破坏时（如根节点变小），通过将其与子节点中较大者交换，并递归地向下进行此过程，以恢复堆性质的操作。
- **原地排序 (In-place Sort):** 指基本上不需要额外辅助数据结构，仅使用O(1)的额外空间来对数据进行排序的算法。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 2 题）**  
1.  **手动实现堆排序** ⭐ —— 亲手实现堆排序，重点是`sift_down`函数和“建堆”、“排序”两个主要阶段的逻辑。这是完全理解堆排序的必经之路。
2.  LC 912 Sort an Array ⭐⭐ —— 再次挑战这个纯粹的排序题，这次用你实现的堆排序来解决它。比较它和快速排序在AC时间和内存消耗上的细微差别。

**进阶巩固（练习 3 题）**  
3.  LC 215 Kth Largest Element in an Array ⭐⭐ —— 这道题除了用快速选择（快排思想）外，用堆也是一个非常经典和稳妥的解法。可以构建一个大小为K的小顶堆，遍历数组，最终堆顶就是第K大的元素。这能让你对比两种不同思想解决Top-K问题的方法。
4.  LC 347 Top K Frequent Elements ⭐⭐ —— 堆的另一个经典应用。先用哈希表统计频率，然后用一个大小为K的小顶堆来筛选出频率最高的K个元素。
5.  LC 703 Kth Largest Element in a Stream ⭐ —— 这道题是为堆结构量身定做的。需要设计一个数据结构，能不断地加入新元素，并随时返回当前第K大的元素。用一个大小为K的小顶堆可以完美解决。
