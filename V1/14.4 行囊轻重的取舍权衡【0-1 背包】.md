### **14.4 行囊轻重的取舍权衡【0-1 背包】**

*"有限的行囊，无尽的宝藏。每一次的拾取与舍弃，都是对价值最深刻的度量与誓约。"*

在掌握了动态规划的两种实现范式后，安妮感觉自己已经准备好迎接更复杂的挑战了。篝火旁，黛芙提出了一个算法史上极富盛名，也是动态规划最经典的应用场景——“**背包问题**”。

“想象一下，安妮，”黛芙的眼神在火光下显得格外明亮，“我们即将踏上一段艰苦的徒步旅程，但我们的背包容量是有限的，比如，最多只能装下4公斤的东西。”

希娅则在一旁，像变魔术一样，拿出了几样东西：

-   一个水壶：重3公斤，价值10分
-   一本厚书：重2公斤，价值8分
-   一盒饼干：重1公斤，价值4分
-   一个手电筒：重1公斤，价值3分

“现在的问题是，”伊莎贝尔接过话头，温柔地解释道，“面对这些宝物，你该如何选择，才能在不超过背包容量的前提下，让所带物品的总价值最高？”

“这就是‘**0-1 背包问题**’，”黛芙总结道，“‘0-1’的意思是，对于每一件物品，你只有两种选择：‘不放进背包（0）’，或者‘完整地放进背包（1）’，不能只放半个。”

#### **定义二维状态**

“这个问题，比爬楼梯要复杂。”安妮思索着，“爬楼梯的状态只需要一个变量`i`（台阶数）。但现在，我们不仅要考虑‘有多少件物品’，还要考虑‘背包还剩多少容量’。我们需要两个变量来定义一个子问题。”

“完全正确！”黛芙非常高兴安妮能想到这一点，“这就是二维动态规划。我们需要一个二维的`dp`表来解决它。”

**状态定义 (State):**
`dp[i][j]` 代表：在只考虑前 `i` 件物品，且背包容量为 `j` 的情况下，所能获得的最大总价值。

-   `i`: 代表物品的编号 (从1到N)
-   `j`: 代表背包的容量 (从1到W)
-   我们的最终目标，是求 `dp[N][W]`。

#### **状态转移的抉择**

“现在，我们来思考核心的状态转移方程。”黛芙引导道，“当我们站在`dp[i][j]`这个状态时，我们正在对第`i`件物品，做一个‘取’或‘舍’的决策。”

-   **决策1：不放第 `i` 件物品 (舍):**
    -   “如果我们决定不把第`i`件物品放进背包，那么，背包里能装下的最大价值，就完全取决于‘只考虑前`i-1`件物品，在容量依然是`j`的情况下’能获得的最大价值。”
    -   **`dp[i][j] = dp[i-1][j]`**

-   **决策2：放第 `i` 件物品 (取):**
    -   “这个决策有一个前提：我们的背包必须能装得下它！即 `j >= weight[i]`。”
    -   “如果我们决定放，那么第`i`件物品的价值`value[i]`就被我们获得了。同时，背包的容量被占用了`weight[i]`。剩下的`j - weight[i]`容量，就必须用来装‘前`i-1`件物品’所能获得的最大价值。”
    -   **`dp[i][j] = value[i] + dp[i-1][j - weight[i]]`**

“好了，”黛芙总结道，“既然我们要做最优选择，那么最终的决策，就是在这两种可能性中，取那个价值更大的！”

**状态转移方程:**
`dp[i][j] = max( dp[i-1][j], value[i] + dp[i-1][j - weight[i]] )`  (当 `j >= weight[i]` 时)
`dp[i][j] = dp[i-1][j]` (当 `j < weight[i]` 时，装不下，只能不放)

#### **填表的艺术**

黛芙在白板上画出了一个二维表格，并开始一步步地填充它。

```ascii
物品: 1(饼干,w=1,v=4), 2(手电,w=1,v=3), 3(书,w=2,v=8), 4(水壶,w=3,v=10)
容量W=4

dp[i][j] (i:物品, j:容量)

  j=0  j=1  j=2  j=3  j=4
i=0 [ 0,   0,   0,   0,   0 ]
i=1 [ 0,   4,   4,   4,   4 ]  (只考虑饼干)
i=2 [ 0,   4,   7,   7,   7 ]  (考虑饼干、手电)
i=3 [ 0,   4,   8,  12,  12 ]  (考虑饼干、手电、书)
i=4 [ 0,   4,   8,  10,  14 ]  (考虑饼干、手电、书、水壶)

...例如计算 dp[3][3] (前3件物品，容量3):
- 不放第3件(书,w=2,v=8): 价值来自 dp[2][3] = 7
- 放第3件(书): 价值 = 8 + dp[2][3-2] = 8 + dp[2][1] = 8 + 4 = 12
- max(7, 12) = 12. 所以 dp[3][3] = 12。

最终答案: dp[4][4] = 14
```

“通过自底向上地填完这张表，我们就得到了最终的答案。”

#### **空间优化：滚动的行囊**

“大家再观察一下这个状态转移方程，”黛芙提示道，“计算第`i`行的状态，只依赖于哪一行的状态？”

“只依赖于第`i-1`行！”安妮立刻回答。

“没错！所以，我们是不是也不需要一个完整的二维`dp`表？”

“我们可以用‘滚动数组’的思想，只保留两行就够了！”安妮兴奋地说。

“更进一步，”黛芙笑道，“我们甚至可以只用‘一行’（一个一维数组）来完成！但需要一点小技巧。”

```python
# 空间优化后的一维DP
def knapsack_01_optimized(weights, values, W):
    n = len(weights)
    dp = [0] * (W + 1) # dp[j] 代表容量为j时的最大价值
    
    for i in range(n):
        # 关键：必须从后往前遍历容量！
        for j in range(W, weights[i] - 1, -1):
            dp[j] = max(dp[j], values[i] + dp[j - weights[i]])
            
    return dp[W]
```

“为什么必须从后往前？”希娅问。

“因为，”黛芙解释道，“`dp[j]`的更新，依赖于本轮`i`中、容量更小的`dp[j - weights[i]]`的值。而这个值，在我们的状态转移方程里，应该是来自‘上一轮’（即`i-1`）的。如果从前往后遍历，当我们计算`dp[j]`时，`dp[j - weights[i]]`可能已经被‘本轮’更新过了，这就串台了，相当于一件物品被重复放了多次。而从后往前，可以保证我们用到的`dp[j - weights[i]]`还是上一轮留下的‘旧值’。”

篝火仍在燃烧，但女孩们的心思，已经完全沉浸在了这“0-1背包”的取舍与权衡之中。安妮第一次如此深刻地感受到，动态规划不仅仅是算法，更是一种在有限资源下，做出最优决策的智慧。

---

🌸 **动态规划核心要点** 🌸

**1. 算法设计的根本思想**
- **多维状态定义：** 当一个子问题不足以用单个变量描述时，就需要引入更多的维度来定义状态。背包问题中的`dp[i][j]`，同时包含了“物品”和“容量”两个维度，是二维DP的经典入门。
- **决策的枚举：** 状态转移方程的核心，是清晰地枚举出到达当前状态的所有“最后一步”可能（对于0-1背包，就是“放”与“不放”），然后从中选择最优的。
- **子问题的构建：** `dp[i-1][j]`和`dp[i-1][j - weight[i]]`这两个部分，精确地定义了当前决策所依赖的、规模更小的子问题，体现了DP的递推本质。

**2. 核心设计哲学**
- **化繁为简：** 背包问题是一个NP完全问题，暴力解法是指数级的（2^N）。动态规划通过利用其内在结构，将其转化为一个伪多项式时间（O(N*W)）的解法，实现了“降维打击”。
- **空间与时间的再平衡：** 从二维DP表的O(N*W)空间，到一维滚动数组的O(W)空间，这个优化过程，深刻地体现了通过“改变计算顺序”来节约空间的思想，是DP优化中的常用技巧。
- **问题的变种：** 0-1背包是所有背包问题的基础。理解了它，就能更容易地去理解“完全背包”（物品可无限次取）和“多重背包”（每种物品有有限件）等变种，它们的核心差异，只在于状态转移方程的微小变化。

**3. 算法思维的启发**
- **表格驱动思考：** 面对复杂的DP问题，画出一个二维表格，并尝试手动填充前几行，是理清状态和转移关系的最有效方法之一。
- **“滚动”的智慧：** “从后往前”遍历以保证使用的是“上一轮”的状态，这个技巧在很多DP空间优化中都会用到。它要求我们对状态依赖关系有极其清晰的认识。
- **抽象建模能力：** 学会识别生活和工作中的“背包问题”模型。例如：有限的预算（背包容量）下，如何选择投资项目（物品）以获得最大回报（价值）？有限的时间里，如何安排学习任务以获得最高分数？这些都可以抽象为背包问题。

---

🎀 **安妮的小小日记本**

0-1背包问题，听起来就像一个真正的冒险！

我感觉自己就像一个要去屠龙的勇者，但我的背包格子有限。我面前摆着屠龙宝刀、无敌圣水、闪光弹、还有我最爱吃的巧克力……我不能全都带走，必须做出取舍。这种感觉太真实了！

用二维`dp`表来解决这个问题，就像是制作一张巨大的决策流程图。每一个格子都在问我：“如果给你这些东西和这点容量，你的最佳选择是什么？”当我们把所有格子的答案都填满，最终的答案就自然浮现了。

最让我佩服的，还是那个一维数组的优化！通过“从后往前”更新，就巧妙地解决了数据污染的问题，把空间一下子减少了那么多！这就像一个高明的魔术师，用最简单的道具，完成了最不可思议的表演。DP的世界，真是充满了智慧的细节！

---

### 今日关键词

- **背包问题 (Knapsack Problem):** 一类经典的组合优化问题。旨在给定一组物品，每种物品都有自己的重量和价值，在限定的总重量内，如何选择，才能使得物品的总价值最高。
- **0-1 背包 (0-1 Knapsack):** 背包问题的最基本形式，其中每种物品只有一个，要么不选（0），要么选（1）。
- **二维DP (2D Dynamic Programming):** 使用二维数组（矩阵）作为DP表来解决问题。通常因为状态需要两个变量来定义。
- **伪多项式时间 (Pseudo-polynomial Time):** 指算法的运行时间是输入数值（而不是输入规模的位数）的多项式。对于背包问题，其复杂度O(N*W)依赖于容量W的具体数值，因此是伪多-项式时间。
- **滚动数组优化 (Rolling Array Optimization):** DP空间优化的一种，通过复用DP表中的空间，来减少其维度。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（0-1背包的理解与实现）**  
1.  **手动实现0-1背包** ⭐⭐ —— 亲手实现0-1背包问题的二维DP解法和一维空间优化解法，确保两种方法都能正确运行。
2.  LC 416. Partition Equal Subset Sum ⭐⭐ —— “分割等和子集”。这个问题可以转化为一个0-1背包问题：能否从数组中，选出一些数，使得它们的和恰好等于`sum(nums) / 2`？这里的“背包容量”就是`sum/2`，“物品的重量和价值”都是`nums[i]`。
3.  LC 494. Target Sum ⭐⭐ —— （回顾）这道题也可以用0-1背包的思路来解。问题可以转化为：在数组中选出一个子集P，使其和为`(target + sum(nums)) / 2`。`dp[j]`的含义变为“和为j的子集有多少个”。

**进阶巩固（背包问题的变种）**  
4.  **完全背包问题** ⭐⭐⭐ —— LC 322. Coin Change, LC 518. Coin Change 2。完全背包的特点是，每种物品可以无限次地选取。与0-1背包唯一的代码区别，就是在一维DP优化时，内层循环需要**从前往后**遍历。理解为什么这个改动是正确的，是掌握完全背包的关键。
5.  LC 139. Word Break ⭐⭐ —— （回顾）单词拆分问题，也可以看作是一个完全背包问题。背包是字符串`s`，物品是字典`wordDict`中的单词。`dp[i]`表示`s`的前`i`个字符能否被拆分。
6.  **多重背包问题** ⭐⭐⭐ —— 查阅资料，学习多重背包问题（每种物品有有限个）。了解如何通过“二进制拆分”等技巧，将其转化为0-1背包问题来求解。
