### **12.1 林间漫步的逐影寻踪【顺序查找】**

*"沿着唯一的足迹，踏遍每一寸土地。最朴素的寻觅，是所有复杂探索的起点。"*

告别了排序算法的“秋日乐章”，社团的算法之旅，翻开了名为“查找”的全新卷宗。为了转换心情，也为了更好地贴近自然，女孩们将这堂课的地点，选在了枫林深处的一条山间小径上。

秋日午后的阳光温暖而和煦，脚下是厚厚的、踩上去会发出“沙沙”声的落叶地毯。空气中是只有山林里才有的、混合着草木与土壤的清香。

“我们已经学会了如何将混乱的序列，变得井然有序。”伊莎贝尔一边走，一边开启了今天的话题，“但很多时候，我们面临的另一个核心任务是：如何从成千上万的数据中，快速地‘找到’我们想要的那一个。这就是‘查找’算法要解决的问题。”

她停下脚步，从随身携带的书本里，取出一枚精致的、被制作成标本的银杏叶，递给安妮。“安妮，你来扮演一个‘寻宝人’。现在，你闭上眼睛，我会把这枚‘宝藏’藏在我们身后走过的这段路上。”

安妮听话地闭上眼。片刻后，伊莎贝尔示意她可以睁开了。

“好了，安妮，现在你要如何找到那枚银杏叶书签呢？”

安妮看了看身后长长的小径，毫不犹豫地回答：“很简单呀，我只要从我刚才站的位置开始，一步一步往回走，仔细检查路上的每一片叶子，直到找到它为止。”

“完全正确！”希娅拍手笑道，“恭喜你，安妮！你刚刚独立‘发明’了世界上最基础、最古老的查找算法——‘顺序查找’（Sequential Search）！”

#### **最直观的策略：线性扫描**

“顺序查找，也叫线性查找（Linear Search），”黛芙开始她标志性的结构化讲解，“它的策略就和你刚才说的一模一样：从序列的第一个元素开始，逐个向后检查，直到找到目标元素，或者检查完所有元素仍未找到为止。”

她在便携白板上写下一个数组，代表小径上的“物品”：`[ 枫叶, 石子, 松果, 银杏叶, 橡果 ]`

“我们的目标是找到‘银杏叶’。顺序查找的过程就像这样：”

```ascii
查找过程演示: target = '银杏叶'

序列: [ 枫叶, 石子, 松果, 银杏叶, 橡果 ]

1. 查看第一个元素 '枫叶'。不是目标。
   ↑

2. 查看第二个元素 '石子'。不是目标。
         ↑

3. 查看第三个元素 '松果'。不是目标。
               ↑

4. 查看第四个元素 '银杏叶'。是目标！查找成功，返回其位置。
                     ↑
```

“它的优点显而易见：”黛芙总结道，“实现极其简单，而且对数据没有任何要求——无论序列是否有序，它都能工作。这是它最强大的普适性。”

#### **代码实现：一步一个脚印**

“它的代码，可能也是我们学过的所有算法里最简单的之一了。”希娅说着，几秒钟内就完成了代码的编写。

```python
def sequential_search(arr: list, target) -> int:
    """在一个列表中顺序查找目标元素，返回其索引，未找到则返回-1。"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # 找到目标，返回索引
    return -1 # 遍历结束仍未找到
```

#### **复杂度分析：期望与现实**

“那么，这个‘笨办法’的效率如何呢？”黛芙引导大家进行分析。

```ascii
顺序查找复杂度分析：

令 N 为序列的长度

┌─────────────────────────────────────────┐
│ 时间复杂度分析 (Time Complexity):         │
├─────────────────────────────────────────┤
│ 最好情况 (Best Case): 目标是第一个元素 │
│ - 只需要比较 1 次。
│ - 时间复杂度为 O(1)
├─────────────────────────────────────────┤
│ 最坏情况 (Worst Case): 目标是最后一个元素，或不存在 │
│ - 需要比较 N 次。
│ - 时间复杂度为 O(N)
├─────────────────────────────────────────┤
│ 平均情况 (Average Case): 假设目标在序列中均匀分布 │
│ - 期望的比较次数为 (1 + 2 + ... + N) / N = (N+1)/2
│ - 时间复杂度为 O(N)
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 空间复杂度分析 (Space Complexity):        │
├─────────────────────────────────────────┤
│ - 算法只需要一个额外的变量 `i` 来作为循环索引。 │
│ - 结论：O(1)                              │
└─────────────────────────────────────────┘
```

“所以，虽然它看起来很‘笨’，但在数据量不大的时候，由于其简单、开销小，可能比那些复杂的算法还要快。”黛芙说道，“而且，当数据是无序的时候，我们别无选择，只能用它。”

#### **哨兵的设置：一个微小的优化**

“对于这种简单的算法，有没有优化的空间呢？”安妮举一反三地问。

“有一个很古典的技巧，叫做‘设置哨兵’（Sentinel）。”黛芙介绍道，“你看，在我们的代码里，每一次循环，其实都包含两个判断：`i < len(arr)`（由`for`循环隐式完成）和 `arr[i] == target`。我们可以通过一个巧妙的设置，把判断次数减少。”

```python
def sequential_search_sentinel(arr: list, target):
    n = len(arr)
    # 将目标元素临时放置在数组末尾，作为“哨兵”
    last_element = arr[n - 1]
    if last_element == target:
        return n - 1
    arr[n - 1] = target
    
    i = 0
    while arr[i] != target:
        i += 1
        
    # 恢复原始数组
    arr[n - 1] = last_element
    
    if i == n - 1:
        return -1 # 循环直到末尾才停下，说明原数组中没有
    else:
        return i
```

“通过把`target`放在末尾，我们保证了循环一定能找到`target`而停下，从而省去了在循环中判断`i`是否越界的开销。”伊莎贝尔解释道，“虽然在现代高级语言中，这种优化的效果可能不明显，但它体现了一种精益求精的算法优化思想。”

阳光透过树叶的缝隙，在小径上洒下点点金光。安妮明白了，任何宏大的旅程，都始于脚下第一步的迈出。而顺序查找，这最朴素、最踏实的“逐影寻踪”，正是她们在“查找”这片广袤森林里，迈出的坚实的第一步。

---

🌸 **查找算法核心要点** 🌸

**1. 算法设计的根本思想**
- **遍历与匹配：** 查找算法的本质，是在一个数据集合中，通过系统性的遍历，来匹配一个给定的目标值。
- **普适性与效率的权衡：** 顺序查找提供了绝对的普适性（适用于任何数据结构和顺序），但牺牲了效率。这是算法世界中最基本的权衡之一。
- **查找成功与失败：** 一个完整的查找算法，必须能处理两种情况：找到目标，并返回其信息；或遍历所有可能后，确认目标不存在。

**2. 核心设计哲学**
- **KISS原则 (Keep It Simple, Stupid):** 顺序查找是该原则的完美体现。在没有特殊要求、数据量不大的情况下，最简单的方案往往就是最好的方案。
- **基础操作的定义：** 顺序查找定义了“查找”这一行为最基础的操作：取出一个元素，与目标进行比较。所有更高级的查找算法，都是在想办法减少这个基础操作的执行次数。
- **优化的边界：** “哨兵”优化展示了即使在最简单的算法中，也存在着对底层计算（如循环判断）进行优化的空间，这体现了对计算成本的极致追求。

**3. 算法思维的启发**
- **构建基线（Baseline）：** 在解决一个查找问题时，顺序查找提供了一个最基础的性能基线。任何你设计的新算法，都应该以超越O(N)为目标，否则其复杂性就可能是不必要的。
- **无序的代价：** 顺序查找的O(N)复杂度，从反面告诉我们数据“无序”状态的代价有多高。为了实现更快的查找，我们往往需要先通过“排序”或其他方式，为数据建立“秩序”。
- **从确定性到概率：** 顺序查找的平均情况分析，让我们初次接触到基于概率和期望的算法分析方法，即假设输入是随机的，来评估算法的平均表现。

---

🎀 **安妮的小小日记本**

今天我们开启了“查找”的新篇章！感觉比“排序”要更直接一些，目标很明确，就是“找到它”！

伊莎贝尔学姐那个藏书签的游戏很有趣，我的第一反应，就是顺序查找的思路。原来最符合直觉的方法，也是一种正经的算法呀！它虽然看起来有点笨，需要一个一个地找，但它不挑剔，不管数据是整齐的还是乱七八糟的，它都能工作，感觉很可靠。

黛芙学姐讲的“哨兵”优化也很有意思，就像在寻宝路线的终点放一个假宝藏，让自己可以放心地、头也不回地往前冲，直到终点再确认找到的是真是假。这种为了减少一点点重复劳动而做的精巧设计，让我感觉算法的世界真是充满了智慧的闪光点。

虽然我知道，后面肯定有更快的查找方法，但今天学的顺序查找，就像是探险家手册里的第一条准则：当你没有地图时，地毯式搜索永远是保底的方案！

---

### 今日关键词

- **查找 (Searching):** 在数据集合中寻找特定元素的过程。
- **顺序查找 / 线性查找 (Sequential Search / Linear Search):** 一种最简单的查找算法，它逐个检查集合中的元素，直到找到目标或遍历完整个集合。
- **普适性 (Universality):** 指算法对输入数据的结构或状态没有特殊要求，具有广泛的适用性。
- **哨兵 (Sentinel):** 在算法中，通过在数据边界设置一个特殊的“标记”值，来简化或优化循环判断条件的一种技巧。
- **性能基线 (Performance Baseline):** 用于衡量和比较其他算法性能的一个基础标准。对于查找问题，顺序查找的O(N)就是这样一个基线。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy
> 建议顺序：基础
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 4 题）**  
1.  **手动实现顺序查找** ⭐ —— 在数组、链表等不同数据结构上，亲手实现顺序查找，体会其普适性。
2.  LC 27 Remove Element ⭐ —— 这道题的核心是找到所有不等于`val`的元素。顺序查找的思想贯穿其中。
3.  LC 28 Implement strStr() (BF版) ⭐ —— 朴素的字符串匹配算法（Brute-Force），其外层循环就是在主串中“顺序查找”与模式串首字母相同的位置，是顺序查找思想的二维应用。
4.  LC 1672 Richest Customer Wealth ⭐ —— 解决这个问题需要遍历（顺序查找）每个客户的账户列表并求和，再找到其中的最大值。这是对基础遍历和查找操作的综合练习。
