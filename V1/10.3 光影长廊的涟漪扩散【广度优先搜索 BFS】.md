### **10.3 光影长廊的涟漪扩散【广度优先搜索 BFS】**

*"光自一点而起，以最温柔、也最公平的方式，逐层照亮黑暗。它抵达万物的顺序，便是离那光之源头，最短的距离。"*

安妮用深度优先搜索（DFS）的策略，成功地在一排偏僻的书架上找到了那本关于“古代星辰神话”的古籍。正当她准备返回时，书的扉页上，一行娟秀的字迹吸引了她的注意：“恭喜你找到这里。真正的秘密，藏在离此地**最近**的线索卡片上。”

原来，这是图书馆为了推广冷门书籍，精心设计的一个解谜活动。从这本书的位置（我们称之为起点`A`）出发，有多条路径通往不同的书架，而其中一些书架上，藏着下一阶段的线索卡片。

“要找到‘最近’的线索……”安妮陷入了新的思考，“我可以用DFS，遍历所有能从A到达的书架，记下它们各自到A的距离，然后再比较出哪个最近？”

“理论上可以，但效率太低了。”黛芙一针见血地指出，“DFS的特点是‘一条路走到黑’。它可能会先沿着一条很长的路径，跑到图书馆的另一个角落，才发现那里有一张线索卡。但也许，就在起点旁边，一步之遥的地方，就有另一张更近的线索卡。为了找到最短路径，你可能需要遍历完所有路径，这太慢了。”

“那……有没有一种策略，能让我优先访问离我近的地方呢？”安妮问。

“当然有。”伊莎贝尔指向图书馆中庭一座静谧的室内喷泉，“安妮，想象一下，你在这座平静的水池中央，轻轻投入一颗小石子（起点`A`）。水波是如何扩散的？”

“它会……先形成一个小小的、完美的圆圈，同时到达所有离`A`距离为1的石头。”安妮回答。

“然后呢？”

“然后，这个圆圈会继续均匀地扩大，变成一个更大的圆圈，再同时到达所有离`A`距离为2的石头……”

“完全正确！”伊莎贝尔的眼中闪烁着赞许的光芒，“这种像水波纹一样，一层一层、由近及远地探索世界的方式，就是我们今天要学习的第二种图遍历算法——**广度优先搜索（Breadth-First Search, BFS）**。它的核心特性决定了，它找到的第一个目标，**天然就是离起点最近的那个**！”

#### **BFS的实现：队列的节拍**

“这种‘一层一层’的模式，让你想起了我们哪位老朋友？”黛芙笑着提问。

“我想想……”安妮回忆着，“一层一层地处理……就像树的层序遍历！它的核心工具是——**队列（Queue）**！”

“Bingo！”希娅兴奋地打了个响指，“BFS和队列，就是天造地设的一对！它们的合作，就像一场按节拍进行的集体舞。”

**BFS迭代函数 `bfs(start_node)` 的逻辑：**
1.  创建一个`queue`（队列）和一个`visited`（访问笔记）。
2.  将起始顶点`start_node`放入队列，并标记为已访问。
3.  当队列不为空时，循环执行：
    a. 从队头**取出一个**顶点`vertex`（这是当前这一层“涟漪”的中心）。
    b. 处理`vertex`（检查这里有没有线索卡）。
    c. 遍历`vertex`的所有邻居`neighbor`。
    d. 如果`neighbor`还**没有被访问过**，就将其标记为已访问，并**放入队尾**排队，等待下一轮的扩散。

```python
from collections import deque

graph = { # 邻接表
    'A': ['B', 'D'],
    'B': ['A', 'C', 'E'],
    'C': ['B'],
    'D': ['A', 'E'],
    'E': ['B', 'D']
}

def bfs(start_node):
    queue = deque([start_node])
    visited = {start_node}
    
    while queue:
        vertex = queue.popleft() # 队头出队
        print(f"访问到: {vertex}")
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor) # 队尾入队
```

希娅在白板上，清晰地模拟了队列的变化过程，以及节点被访问的顺序：

1.  **初始:** `queue: [A]`, `visited: {A}`
2.  **第1轮:** `pop A`, 访问A. 将A的邻居B, D加入队列。
    `queue: [B, D]`, `visited: {A, B, D}`
3.  **第2轮:** `pop B`, 访问B. 将B的邻居C, E加入队列。
    `queue: [D, C, E]`, `visited: {A, B, D, C, E}`
4.  **第3轮:** `pop D`, 访问D. D的邻居A, E都已访问过。
    `queue: [C, E]`
5.  **第4轮:** `pop C`, 访问C. C的邻居B已被访问。
    `queue: [E]`
6.  **第5轮:** `pop E`, 访问E. E的邻居B, D都已被访问。
    `queue: []`
7.  队列为空，结束。

“最终的访问顺序是：A -> B -> D -> C -> E。”希娅总结道，“你看，它完美地按照离A的距离，一层一层地进行访问。A是第0层，B和D是第1层，C和E是第2层。”

#### **BFS的天然优势：最短路径**

“正因为BFS的这种逐层扩散的特性，”黛芙接着说，“它在求解**无权图（Unweighted Graph）**的**最短路径**问题上，拥有无与伦比的优势。”

“无权图，就是我们这个图书馆的地图，我们只关心书架之间‘通不通’，而不关心路程的‘长短’，可以认为每条边的长度都是1。”

“在BFS的遍历过程中，当我们第一次到达某个节点时，我们所经过的路径，必然是所有可能路径中最短的那一条。这就像水波纹，它不可能先绕个大圈子去触碰一个远处的石头，再回来触碰一个近处的石头。它总是先触碰所有最近的。”

“我们可以稍微改造一下BFS，让它在遍历的同时，记录下起点到每个节点的最短距离。”

```python
def bfs_shortest_path(start_node):
    queue = deque([(start_node, 0)]) # 队列中存入 (节点, 距离)
    visited = {start_node}
    distances = {start_node: 0}
    
    while queue:
        vertex, dist = queue.popleft()
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                distances[neighbor] = dist + 1 # 距离加一
                queue.append((neighbor, dist + 1))
    return distances
```

安妮立刻用这个新“程序”在心中寻找线索卡。她从A出发，第一层就检查了B和D。如果在B或D上发现了线索卡，她可以百分之百地确定，这就是最近的，无需再做任何多余的探索。

#### **DFS vs. BFS：深度与广度的对决**

黛芙在白板的最后，画上了一张总结性的对比图。

| 特性 | 深度优先搜索 (DFS) | 广度优先搜索 (BFS) |
| :--- | :--- | :--- |
| **数据结构** | **栈 (Stack)** (或递归) | **队列 (Queue)** |
| **探索方式** | 一条路走到黑，再回溯 | 逐层向外，像涟漪扩散 |
| **路径查找** | 能找到路径，但不保证最短 | **能找到无权图的最短路径** |
| **空间消耗** | O(h) (h为最深路径长) | O(w) (w为图的最大宽度) |
| **应用场景** | 寻找可行解、拓扑排序、检测环 | **寻找最短路径**、社交网络好友推荐 |

安妮看着这张对比图，心中关于两种遍历方式的最后一点迷雾也消散了。DFS像一个执着的深潜者，而BFS则像一个严谨的测量员。它们没有绝对的优劣，只是为解决不同类型的问题而生的、同样强大的工具。

---

🌸 **BFS核心要点** 🌸

**1. 算法设计的根本思想**
- **逐层扩展：** BFS的本质，是一种“地毯式”的、逐层向外扩展的搜索策略。它保证了在访问第`k`层的任何节点之前，必须已经访问完所有第`k-1`层的节点。
- **距离的有序性：** BFS的遍历顺序，天然地等价于节点按“离起点的距离”的升序排列。这个内在的有序性，是其能够解决最短路径问题的根本原因。
- **队列作为“待办”列表：** BFS使用队列来管理“待访问”的节点。队列的“先进先出”特性，完美地契合了“先发现的节点（更靠近起点的层）其邻居也应被先探索”的逐层扩展逻辑。

**2. 核心设计哲学**
- **“广度”优先于“深度”：** 与DFS相反，BFS在探索完当前层的所有可能性之前，绝不会进入更深的一层。这种策略确保了算法的“公平性”，不会因某条路径过深而忽略了其他更近的、可能更优的路径。
- **“最短”的保证：** 在边权为1的图中，BFS找到的通往任意节点的第一条路径，必然是该节点的最短路径。这是一个极其强大且有用的性质，使其成为许多最短路径问题的基础算法。
- **空间换时间：** BFS需要一个队列来存储待访问的节点。在某些“矮胖”形的图中（宽度极大），队列可能会存储大量的节点，导致空间开销较大。这是它为了保证找到最短路径而付出的空间代价。

**3. 算法思维的启发**
- **层序遍历的泛化：** 图的BFS，可以看作是树的“层序遍历”在更广义结构上的应用。两者都使用队列，都体现了逐层处理的思想。理解这种从特定到一般的泛化，有助于构建更通用的算法思维。
- **问题的模型匹配：** 当一个问题的核心诉求是“找到最短/最快/最少步数……”时，应立刻将BFS作为首选的思维模型。例如，“走迷宫的最少步数”、“社交网络中两人之间的最少中间人”等。
- **状态的有序探索：** BFS不仅能探索物理空间，更能探索“状态空间”。在很多谜题和游戏中（如魔方、八数码问题），可以将每一种状态看作一个顶点，将一次操作看作一条边。用BFS进行搜索，就能找到从初始状态到目标状态的最少操作步骤。

---

🎀 **安妮的小小日记本**

今天，我感觉自己像一颗被投入水中的石子。

当我需要找到“最近”的线索时，我学会了像涟漪一样思考。这就是广度优先搜索（BFS）。它不像DFS那样一根筋地往前冲，而是很“公平”地、一层一层地向外探索。先看看离我1步远的地方，再看看2步远的地方……这样，我第一个找到的目标，肯定就是最近的！

实现这个“涟漪”的魔法道具，竟然又是我们的老朋友——队列！新发现的节点，就像新产生的水波，乖乖地排在队尾，等待着轮到自己去扩散。这个过程好有秩序感！

现在，DFS和BFS在我心里，就像是两个性格不同的探险家。DFS是“深潜专家”，适合找有没有路。而BFS是“测绘大师”，最擅长测量最短距离。以后遇到寻路问题，我知道该派哪位专家出马了！

---

> **广度优先搜索（Breadth-First Search, BFS）**是一种用于遍历或搜索树或图的算法。它从一个起始顶点出发，首先访问所有与起始顶点直接相邻的邻居节点，然后逐层地向外扩展，访问更远的节点。BFS算法通常使用一个**队列（Queue）**来实现。由于其逐层遍历的特性，BFS非常适合用于寻找**无权图中的最短路径**，它找到的任何一个节点的第一条路径，都保证是距离起点最近的。

### 今日关键词

- **广度优先搜索 (BFS):** 一种“逐层扩散”的图遍历算法。
- **队列 (Queue):** 实现BFS的核心数据结构，遵循“先进先出”原则。
- **层序遍历 (Level Order):** BFS在树上的别称，按层级顺序访问节点。
- **最短路径 (Shortest Path):** 在无权图中，从起点到终点所经过的最少边数。BFS是解决此类问题的首选算法。
- **无权图 (Unweighted Graph):** 图中所有的边都没有被赋予权重（或权重都为1），只关心连通性。

### 名词小传

**广度优先搜索（BFS）**作为一种基础的图搜索算法，其思想的早期形式也出现在迷宫求解等问题中。然而，将其形式化并应用于计算机科学领域，公认的先驱是美国计算机科学家**爱德华·F·摩尔（Edward F. Moore）**。他在1959年发表了一篇关于寻找迷宫中路径的论文，其中描述的算法，就是我们今天所熟知的BFS。他展示了如何使用BFS来找到从起点到终点的最短路径。此后，C. Y. Lee在1961年独立地提出了一个几乎相同的算法，并将其应用于电路布线问题。因此，BFS有时也被称为“Moore算法”或“Lee算法”。

### BFS定义

**广度优先搜索（BFS）**是一种图遍历算法，它从给定的源顶点开始，系统地探索图。它首先访问源顶点的所有直接邻居，然后是这些邻居的未被访问的邻居，以此类推，逐层向外扩展。BFS使用一个队列来管理待访问的顶点，以保证“先发现的先探索”的顺序。在无权图中，BFS保证了找到的从源到任何其他顶点的路径都是最短路径。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard

**基础入门**
1.  **LC 102 Binary Tree Level Order Traversal** ⭐⭐
    > **推荐理由**：**BFS入门必做**。这是BFS在树这种特殊图上的最直接应用，能让你熟练掌握用队列进行层序遍历的模板代码。

2.  **LC 199 Binary Tree Right Side View** ⭐⭐
    > **推荐理由**：层序遍历的巧妙应用。在每一层遍历结束前，将该层最后一个被访问的节点加入结果集即可。

3.  **LC 994 Rotting Oranges** ⭐⭐
    > **推荐理由**：一个非常经典的BFS问题。将所有初始的腐烂橘子看作起点，放入队列。然后进行多源BFS，每一轮扩散代表一分钟。最终的分钟数，就是所有新鲜橘子都被腐烂所需的时间。

**最短路径应用**
4.  **LC 111 Minimum Depth of Binary Tree** ⭐⭐
    > **推荐理由**：**再次推荐**。这道题是“寻找最短”的典型，用BFS是最佳解法。一旦在某一层遍历时，遇到了一个叶子节点，那么当前层数就是答案。

5.  **LC 542 01 Matrix** ⭐⭐
    > **推荐理由**：多源BFS的经典应用。将所有值为0的格子作为起点，全部放入队列，然后向外扩散，更新所有值为1的格子到最近的0的距离。

6.  **LC 752 Open the Lock** ⭐⭐
    > **推荐理由**：将问题抽象为图搜索的典范。每个4位密码组合都是一个图的顶点，转动一次是一位就是一条边。问题转化为，从`"0000"`到`target`的最短路径是什么？同时要避开“死亡数字”（障碍物）。这是BFS的标准应用场景。

7.  **LC 127 Word Ladder** ⭐⭐⭐
    > **推荐理由**：另一道将问题抽象为图搜索的难题。每个单词是一个顶点，如果两个单词只差一个字母，则它们之间有一条边。问题转化为从`beginWord`到`endWord`的最短路径长度。这道题综合考察了BFS和字符串处理，是面试高频难题。
