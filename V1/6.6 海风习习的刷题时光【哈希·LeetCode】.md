### **6.6 海风习习的刷题时光【哈希·LeetCode】**

*"当理论的星图化为指尖的航线，每一次代码的敲击，都是在向未知的算法星辰，发起一次勇敢的远征。"*

夜幕悄然降临，白日的燥热被清凉的海风温柔取代。沙滩上，一堆篝火烧得正旺，橙红色的火光映照着女孩们青春的脸庞，空气中弥漫着烤棉花糖和海鲜的诱人香气。

“今天的学习真是太充实了！”安妮满足地叹了口气，手里拿着一串刚烤好的鱿鱼，眼睛却还盯着自己写满了笔记的小本子，“哈希的概念、函数、冲突处理、再哈希……感觉脑子里装得满满的。”

“光装满还不够哦，”希娅眨了眨眼，她从沙滩垫上拿起自己的笔记本电脑，屏幕上是一个简洁的编程挑战网站界面，“理论学得再好，不拉出来‘实战’一下，永远都只是纸上谈兵。是时候来一场‘海风习习的刷题时光’，检验一下我们今天的学习成果啦！”

伊莎贝尔笑着递给每人一杯冰镇柠檬水：“别太紧张，就当是饭后消食的趣味游戏。”

#### **开胃菜：两数之和 (Two Sum)**

“锵锵！第一道题，也是哈希表应用中最最经典的一道——**LeetCode 1. 两数之和**。”希娅将屏幕转向大家。

> **题目描述：** 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。
> 
> 示例：`nums = [2, 7, 11, 15]`, `target = 9`  
> 输出：`[0, 1]` (因为 `nums[0] + nums[1] == 9`)

“这道题……”安妮看着题目，陷入了沉思。她最先想到的，是最朴素的方法：“我是不是可以……用两个循环？第一个循环固定一个数，第二个循环去找数组里剩下的数，看看有没有加起来等于`target`的？”

“嗯，这是暴力解法，思路很清晰。”黛芙肯定了她的想法，并在沙滩上画了起来，“但你想想，如果数组有一万个数，那得比较多少次？”

安妮心算了一下，一万乘以一万，那可是一亿次！“太多了，肯定会超时的。”

“那么，换个思路，”黛芙引导道，“当你拿起第一个数，比如`2`，你心里真正想找的‘另一半’是谁？”

“是`9 - 2 = 7`！”安妮脱口而出。

“对！问题就变成了：我们如何能**瞬间**知道，数组里存不存在一个`7`呢？”黛芙的目光带着一丝笑意，“我们今天学的哪个工具，最擅长回答‘某某在不在’的问题？”

“哈希表！”安妮的眼睛瞬间亮了，“我明白了！我们可以用一个**哈希映射（HashMap）**！”

在黛芙的鼓励下，安妮说出了自己的思路：“我们可以遍历一遍数组。对于每个数，我们先不去后面找它，而是先去‘哈希地图’里问问，我们要找的‘另一半’是不是**已经出现过**了？如果问到了，那就找到了答案！如果没问到，就把我们当前这个数和它的下标，存进‘地图’里，供后面的数来查询！”

黛芙满意地点了点头，在白板上清晰地展示了这个绝妙的过程：

```python
def two_sum(nums: list[int], target: int) -> list[int]:
    """使用哈希映射解决两数之和问题"""
    num_map = {}  # 创建一个空的HashMap
    
    # 遍历数组，i是下标，num是数值
    for i, num in enumerate(nums):
        complement = target - num
        
        # 检查“另一半”是否已经在地图里
        if complement in num_map:
            # 找到了！返回“另一半”的下标和当前数的下标
            return [num_map[complement], i]
        
        # 如果没找到，就把当前数和它的下标存入地图
        num_map[num] = i
```

**执行过程可视化 (`nums = [2, 7, 11, 15]`, `target = 9`)**

```ascii
步骤 1: i=0, num=2
- complement = 9 - 2 = 7
- 在 map {} 中查找 7: 未找到
- 将 {2: 0} 存入 map

步骤 2: i=1, num=7
- complement = 9 - 7 = 2
- 在 map {2: 0} 中查找 2: 找到了！
- 返回 [map[2], i] -> [0, 1]

程序结束。
```

“看，”黛芙总结道，“我们只用了一次循环，时间复杂度是O(n)。代价是，我们用了一个哈希表来存储数据，所以空间复杂度是O(n)。这就是典型的‘**空间换时间**’！”

#### **甜点一：存在重复元素 (Contains Duplicate)**

“太棒了！感觉HashMap好强大！”安妮兴奋地说。

“别急，我们来个简单的‘甜点’。”伊莎贝尔微笑着提出了第二道题，“**LeetCode 217. 存在重复元素**。”

> **题目描述：** 给你一个整数数组 `nums`。如果任一数值在数组中出现 **至少两次** ，返回 `true`；如果数组中每个元素互不相同，返回 `false`。

这次，安妮几乎没有犹豫：“这个问题，只关心‘有还是没有’重复，不关心具体的值和位置。用 **哈希集合（HashSet）** 最合适了！”

“我们可以遍历数组，把每个数字都尝试着加入到HashSet里。因为集合的元素不能重复，如果哪一次我们添加失败了，或者在添加前发现它已经存在于集合中，那就说明我们遇到了重复元素，立刻返回`true`！如果整个数组都遍历完了，所有元素都成功地加了进去，那就说明没有重复，返回`false`。”

```python
def contains_duplicate(nums: list[int]) -> bool:
    """使用哈希集合解决存在重复元素问题"""
    num_set = set()  # 创建一个空的HashSet
    
    for num in nums:
        if num in num_set:
            return True
        num_set.add(num)
        
    return False
```

“完全正确！”伊莎贝尔赞许道，“你看，当你明确了问题是`判断存在性`还是`查找对应关系`后，选择合适的工具就变得如此自然。”

#### **主菜：字母异位词分组 (Group Anagrams)**

“好了，开胃菜和甜点都吃完了，该上‘主菜’了！”希娅的眼神里闪烁着兴奋的光芒，“这道题稍微有点挑战哦！**LeetCode 49. 字母异位词分组**。”

> **题目描述：** 给你一个字符串数组 `strs`，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。
> 
> **字母异位词** 是由完全相同的字母组成、但排列顺序不同的字符串。
> 
> 示例: `strs = ["eat","tea","tan","ate","nat","bat"]`
> 输出: `[["bat"],["nat","tan"],["ate","eat","tea"]]`

这道题让安妮犯了难。“要把它们分组……我得先判断哪些是字母异位词。`eat`、`tea`、`ate`是一组，因为它们都由`a, e, t`三个字母组成……”

“那计算机要怎么知道它们是由相同的字母组成的呢？”黛芙提示道，“有没有一种方法，能让`eat`、`tea`、`ate`都变成一个**一模一样**的东西，而`tan`和`nat`变成另一个**一模一样**的东西？”

“一模一样的东西……”安妮喃喃自语。她看着篝火旁，伊莎贝尔正在将一串五颜六色的彩椒块串到签子上，她会先把同种颜色的放在一起，再按大小排列。

“排序！”安妮的脑中灵光一闪，“如果我把每个单词的字母都按字母表顺序重新排列！那`eat`、`tea`、`ate`都会变成`aet`！`tan`和`nat`都会变成`ant`！”

“绝妙的想法！”黛芙的赞赏毫不掩饰，“这个排序后的字符串`aet`，就是一个完美的 **‘身份证’** ！所有字母异位词都共享同一个‘身份证’。现在，我们该用什么数据结构，来建立‘身份证’和它所有者们的关联呢？”

“**哈希映射（HashMap）**！”安妮和希娅异口同声地喊道。

“我们可以创建一个HashMap，其中：”安妮接着说，“**键（Key）** 就是排序后的字符串（比如`aet`），而**值（Value）** 就是一个列表，用来存放所有排序后等于这个Key的原始单词！”

黛芙在白板上，将这个优雅的解决方案流程化：

```python
from collections import defaultdict

def group_anagrams(strs: list[str]) -> list[list[str]]:
    """使用哈希映射解决字母异位词分组问题"""
    anagram_map = defaultdict(list)  # 创建一个值默认为列表的HashMap
    
    for s in strs:
        sorted_s = "".join(sorted(s))  # 将字符串排序，作为Key
        anagram_map[sorted_s].append(s) # 将原字符串加入Key对应的列表中
        
    return list(anagram_map.values())
```

**执行过程可视化 (`strs = ["eat","tea","tan","ate","nat","bat"]`)**

```ascii
map = {}

s = "eat" -> sorted_s = "aet" -> map["aet"] = ["eat"]
s = "tea" -> sorted_s = "aet" -> map["aet"] = ["eat", "tea"]
s = "tan" -> sorted_s = "ant" -> map["ant"] = ["tan"]
s = "ate" -> sorted_s = "aet" -> map["aet"] = ["eat", "tea", "ate"]
s = "nat" -> sorted_s = "ant" -> map["ant"] = ["tan", "nat"]
s = "bat" -> sorted_s = "abt" -> map["abt"] = ["bat"]

最终 map:
{
  "aet": ["eat", "tea", "ate"],
  "ant": ["tan", "nat"],
  "abt": ["bat"]
}

返回 map 的所有 values 即可。
```

篝火噼啪作响，将温暖的光洒在每个人的笑脸上。从最简单的“两数之和”，到巧妙的“字母异位词分组”，安妮感觉自己对哈希的应用，从一个模糊的概念，变成了一套触手可及、威力无穷的组合拳。她知道，今晚，她不仅学会了哈希，更学会了如何像一个真正的算法思考者那样，去剖析问题，选择最恰当的工具，设计最优雅的解决方案。

---

🌸 **哈希应用核心模式** 🌸

**1. 空间换时间，实现“瞬间”查找**
   - **核心模式：** 将数据（或其关键信息）预处理后存入哈希表，将后续的重复性查找操作，从O(n)或O(log n)优化至O(1)。
   - **典型应用：** `两数之和`。通过将已遍历的数字存入哈希表，将“寻找另一半”这个操作的时间复杂度从O(n)降为O(1)，“空间”换“时间”的典范。

**2. 利用唯一性，进行快速“判重”与“计数”**
   - **核心模式：** 利用哈希集合（HashSet）元素不重复的特性，高效地判断元素是否存在、去重。或利用哈希映射（HashMap）的Key唯一性，进行频率统计。
   - **典型应用：** `存在重复元素`（HashSet判断存在）、`有效的字母异位词`（HashMap计数）。

**3. 创造“标准形态”，进行“归一化”分组**
   - **核心模式：** 针对一类具有共同本质、但表现形式不同的数据（如字母异位词），设计一种“标准化”或“范式化”的转换规则，将它们都映射到同一个Key上。这个Key作为“身份证”，统领一组数据。
   - **典型应用：** `字母异位词分组`。将字符串排序，这个“有序”形态就是其“标准形态”，作为分组的依据。

**4. 建立“值”与“索引/位置”的快速映射**
   - **核心模式：** 在需要快速知道某个值在数组中出现的位置时，可以使用哈希映射来存储`{值: 下标}`的对应关系。
   - **典型应用：** `两数之和`的解法中，存储`{数字: 下标}`，以便在找到答案时能立刻返回正确的下标。

---

🎀 **安妮的小小日记本**

今晚的烧烤太好吃了，但比烧烤更好吃的，是解开算法题时那种“啊哈！”的感觉！

以前看这些题目，我可能只会用最笨的办法，让计算机傻傻地一个一个去找。但今天，我学会了使用“哈希”这个魔法放大镜！

遇到“两数之和”，我立刻就想到了用HashMap来建一个“寻亲布告栏”，每个数字都能快速找到它的另一半！

遇到“存在重复元素”，我马上就想到了用HashSet这个“点名册”，谁的名字被念了两次，一下就抓住了！

最酷的是“字母异位词分组”！我竟然想到了把单词排序作为它们的“身份证”！然后用HashMap建一个“同乡会”，所有老乡（异位词）都能找到组织！

原来，学姐们教我的那些概念，真的不是空中楼阁。它们就像一把把瑞士军刀里的小工具，看似简单，但在合适的场景下，真的能爆发出超强的力量！我爱上这种感觉了！

---

> 本章的旅程到此结束。从沙滩上的贝壳游戏，到篝火旁的解题时光，我们一同探索了哈希思想的起源、哈希函数的设计、冲突处理的智慧，以及它在哈希集合与哈希映射中的具体应用。哈希表，作为现代编程中无处不在的高效工具，其“空间换时间”的核心思想和O(1)的理想效率，是每一位算法学习者都必须熟练掌握的利器。愿你在未来的算法海洋中，也能善用哈希这片“魔法索引”，瞬间定位到属于你的答案。

### 本章推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard  
> 建议顺序：基础 ➜ 进阶 ➜ 面试 ➜ 考研  
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 10 题）**  
1.  LC 1 Two Sum ⭐ —— Map入门第一题，面试必考，练习“用值找另一半”的核心思维。
2.  LC 217 Contains Duplicate ⭐ —— Set入门第一题，练习利用Set唯一性进行快速判重。
3.  LC 242 Valid Anagram ⭐ —— Map/数组计数入门，练习统计字符频率。
4.  LC 771 Jewels and Stones ⭐ —— Set基础应用，将“珠宝”存入Set，快速判断“石头”归属。
5.  LC 387 First Unique Character in a String ⭐ —— Map两次遍历，练习“先统计，后查找”的经典模式。
6.  LC 290 Word Pattern ⭐ —— 双向映射，需要用两个Map维护`pattern[i] -> word`和`word -> pattern[i]`的唯一对应。
7.  LC 205 Isomorphic Strings ⭐ —— 同构字符串判断，与上一题类似，巩固映射关系。
8.  LC 349 Intersection of Two Arrays ⭐ —— Set运算，用Set高效求两个数组的交集。
9.  LC 136 Single Number ⭐ —— Set/位运算，体会哈希在“寻找唯一/重复元素”问题中的应用。
10. LC 594 Longest Harmonious Subsequence ⭐⭐ —— Map统计频率，并查找相邻键（`key+1`），练习在Map上做简单分析。

**进阶巩固（练习 10 题）**  
11. LC 49 Group Anagrams ⭐⭐ —— Map进阶，核心在于设计巧妙的Key（排序字符串）来进行归类。  
12. LC 219 Contains Duplicate II ⭐⭐ —— Map/Set与滑动窗口结合，维护一个固定大小的窗口或记录下标，判断重复。  
13. LC 380 Insert Delete GetRandom O(1) ⭐⭐⭐ —— Map与数组结合的精妙设计题，要求O(1)删除，需深刻理解数据结构组合。  
14. LC 560 Subarray Sum Equals K ⭐⭐ —— Map与前缀和结合，是子数组问题中的必会技巧。  
15. LC 128 Longest Consecutive Sequence ⭐⭐⭐ —— Set/Map高级应用，空间换时间，将排序解法O(n log n)优化至O(n)。  
16. LC 454 4Sum II ⭐⭐ —— 分组求和，将四个数组分为两两一组，用Map存储第一组的和，再计算第二组的和去Map中查找。  
17. LC 705 Design HashSet ⭐⭐ —— 设计题，亲手实现HashSet，深入理解底层（哈希函数+冲突处理）。  
18. LC 706 Design HashMap ⭐⭐ —— 设计题，亲手实现HashMap，巩固对整个哈希表体系的理解。  
19. LC 2053 Kth Distinct String in an Array ⭐⭐ —— Map统计频率，再遍历找出第k个唯一的字符串，练习多阶段处理。  
20. LC 350 Intersection of Two Arrays II ⭐⭐ —— Map求交集（考虑数量），与349题对比，练习用Map处理重复元素的交集问题。  
