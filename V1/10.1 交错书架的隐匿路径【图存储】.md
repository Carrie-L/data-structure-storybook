### **10.1 交错书架的隐匿路径【图存储】**

*"每一座图书馆，都是一座由知识构成的巨大迷宫。而绘制这张迷宫的地图，是走出它的第一步，也是理解它的开始。"*

告别了水上乐园的喧嚣，为了沉淀近期的学习，女孩们选择在市立的中央图书馆度过一个安静的下午。这座图书馆历史悠久，建筑宏伟，内部由无数高大的橡木书架组成，它们纵横交错，形成了一个个静谧的、只闻得到书香与微尘气息的阅读角落。

安妮正在根据一张参考书目，寻找几本相关的古籍。她在一排书架上找到了第一本，书后的“延伸阅读”指引她去另一区的另一排书架寻找第二本。在绕了几个弯，差点迷路后，她终于找到了第二本，而这本书又将她引向了第三个、完全不同方向的书架。

“呼……这座图书馆好大啊，”安妮抱着两本厚重的书，回到座位上，小声地对学姐们说，“书架和书架之间的关系好复杂，有的可以直接走过去，有的却要绕好大一圈。真希望有一张‘图书馆地图’，能把所有书架之间的‘连接关系’都画下来，这样就不会迷路了。”

“安妮，你刚刚描述的，正是我们算法世界里最复杂、也最包罗万象的一种数据结构——**图（Graph）**。”伊莎贝尔微笑着，为她递上一杯温水，“你已经不知不觉地，踏入了图论的宏伟大门。”

“你可以把图书馆里的每一个关键路口，或者每一整排书架，都看作一个**顶点（Vertex）**。”伊莎贝尔解释道，“而连接两个顶点的、可以直接走通的路径，就是一条**边（Edge）**。你刚才的寻书之旅，就是在图上，沿着一条条边，从一个顶点移动到另一个顶点。整个图书馆，就是一个巨大的、错综复杂的图。”

#### **绘制地图：计算机如何存储“图”？**

“你想要的‘图书馆地图’，在计算机里，就是图的存储结构。”黛芙在她的白板上，画了一个由几个圈和几条线组成的简单图形，代表图书馆的一个小角落。

```ascii
      (A)-------(B)
       |         |
       |         |
      (D)-------(C)
```

“假设A、B、C、D是四个区域的书架。现在，我们要怎么用代码来描述它们之间的连接关系呢？主要有两种方法。”

#### **方法一：邻接矩阵 (Adjacency Matrix) —— “飞行航线图”**

“第一种方法，非常直接，就像制作一张‘城市间的飞行航线总图’。”黛芙说，“我们画一个巨大的表格（一个二维数组），表格的行和列，都代表图里所有的顶点。”

“如果顶点`i`和顶点`j`之间有直接的路径（边），我们就在表格的第`i`行第`j`列，标记为`1`；如果没有，就标记为`0`。”

她为刚才那个小图，画出了对应的邻接矩阵：

```ascii
Graph:          Adjacency Matrix:

(A)---(B)         A B C D
 |     |        A [0,1,0,1]
 |     |        B [1,0,1,0]
(D)---(C)         C [0,1,0,1]
                D [1,0,1,0]
```

“如果是有方向的图（比如单行道），`A->B`就在`(A,B)`位置标1，但`(B,A)`可以是0。如果边带有权重（比如路径的长度），我们就可以在格子里存权重值，而不是简单的1。”

希娅很快就看出了这种方法的优缺点：
-   **优点：** “这个好！判断两个顶点（比如A和B）之间有没有路，我只要直接去看矩阵的`(A,B)`位置是0还是1就行了，查询速度是 **O(1)**！超级快！”
-   **缺点：** “但是……”她皱起了眉头，“如果这个图书馆有一万个顶点，那这个矩阵就得是‘一万乘以一万’，也就是一亿个格子！这也太浪费空间了！特别是如果路很少（我们称之为**稀疏图 (Sparse Graph)**），那这个巨大的表格里，绝大部分都填的是0，太浪费了。”

#### **方法二：邻接表 (Adjacency List) —— “旅行便签”**

“希娅说得完全正确。所以，为了解决空间浪费的问题，我们有了第二种更常用的方法——**邻接表（Adjacency List）**。”黛芙继续道。

“这种方法，不再绘制一张包含所有可能性的巨大地图，而是更像一本‘个性化的旅行指南’。我们为**每一个顶点**，都准备一张‘便签’（一个列表），在这张便签上，我们**只记录**从这个顶点出发，可以直接到达的所有邻居。”

她为同一个图，画出了邻接表的表示方法：

```ascii
Graph:          Adjacency List:

(A)---(B)         A -> [ B, D ]
 |     |        B -> [ A, C ]
 |     |        C -> [ B, D ]
(D)---(C)         D -> [ A, C ]
```

“在代码实现中，这通常是一个‘数组+链表’的结构，或者更灵活地，用一个‘哈希表+列表’的结构来实现，键是顶点，值是它的邻居列表。”

希娅再次分析了这种方法的优缺点：
-   **优点：** “这个方法非常节省空间！图中有多少条边，我们就记录多少信息，一点空间都不浪费。对于稀疏图，这个优势太明显了！它的空间复杂度是 **O(V+E)**，V是顶点数，E是边数。”
-   **缺点：** “但是，查找效率就变慢了。如果我想判断顶点A和C之间有没有直连的路，我不能像矩阵那样一眼看出来。我得先找到A的‘便签’，然后把它邻居列表`[B, D]`从头到尾看一遍，才能确定C不在里面。这个查询的时间复杂度是 **O(k)**，其中`k`是顶点A的**度**（Degree），也就是邻居的数量。”

#### **两种地图的选择**

黛芙在白板上，为两种存储方式做出了最终的总结：

| 特性 | 邻接矩阵 (Adjacency Matrix) | 邻接表 (Adjacency List) |
| :--- | :--- | :--- |
| **空间复杂度** | **O(V²)** | **O(V + E)** |
| **查询两点是否邻接** | **O(1)** | **O(k)** (k为点的度) |
| **遍历一个点的所有邻接点** | O(V) (需遍历一行) | O(k) |
| **适用场景** | **稠密图 (Dense Graph)** | **稀疏图 (Sparse Graph)** |

“所以，”伊莎贝尔柔声说道，“选择哪种‘地图’，取决于我们的‘图书馆’有多‘拥挤’。如果它是一个**稠密图**，几乎每个顶点都与其他很多顶点相连，那邻接矩阵的空间浪费就不那么严重，其`O(1)`的查询速度就很有优势。但如果它是一个**稀疏图-**，像我们现实世界中的大多数网络（社交网络、道路网络）一样，顶点很多，但每个顶点只与少数几个邻居直接相连，那么邻接表无疑是更明智、更普遍的选择。”

安妮低头看着自己画的寻书路线草图，那上面几个书架的名字被圈起，并用箭头连接着。她明白了，自己下意识画出的，其实就是一张“邻接表”的雏形。她终于理解了，面对一个像图书馆这样复杂的、由连接关系构成的世界，计算机是如何用它那严谨而高效的语言，为这个世界绘制出清晰、可被计算的“地图”的。

---

🌸 **图存储核心要点** 🌸

**1. 算法设计的根本思想**
- **抽象与建模：** 图论的第一步，是将现实世界中错综复杂的“关系”网络（如社交关系、交通线路、依赖关系），抽象为由“顶点（Vertex）”和“边（Edge）”组成的数学模型。这是所有图算法的基础。
- **空间与时间的权衡：** 邻接矩阵和邻接表是图存储中又一个经典的“空间换时间”的权衡案例。矩阵用巨大的空间（O(V²)）换取了极致的邻接查询速度（O(1)）。列表则用更长的查询时间（O(k)）换取了与图规模成正比的、极低的空间开销（O(V+E)）。
- **表示法的选择决定算法效率：** 选择哪种存储方式，会直接影响后续图算法的性能。例如，对于需要频繁判断两点是否邻接的算法，矩阵更优；而对于需要遍历所有邻居的算法（如DFS/BFS），列表则更高效。

**2. 核心设计哲学**
- **“全局视图” vs “局部视图”：** 邻接矩阵提供了一个“全局视图”，它是一个包含了所有顶点之间可能关系的完整信息表，即使很多关系并不存在。邻接表则提供了一个“局部视图”，每个节点只关心与自己直接相关的邻居，信息更聚焦、更紧凑。
- **稠密与稀疏的二元性：** 在图论的世界里，“稠密”和“稀疏”是描述图性质的一对核心概念。一个图的稠密程度（边的数量相对于顶点数量的平方）是我们在选择存储方式和算法时，必须首先考虑的关键因素。
- **数据结构的组合：** 邻接表的实现本身，就是数据结构组合的体现。它通常由一个数组（或哈希表）和多个链表（或动态数组）组合而成，外层结构用于快速定位顶点，内层结构用于动态存储邻居列表。

**3. 算法思维的启发**
- **“关系”的可计算化：** 图存储的核心，是将“关系”这种抽象概念，转化为计算机可以处理的、结构化的数据（矩阵或列表）。这启发我们，很多看似无法量化的问题，都可以通过合适的建模，变得可计算。
- **根据“查询模式”选择数据结构：** 在设计系统时，应深入分析最核心、最频繁的“查询模式”是什么。如果最常见的操作是“判断两点是否相连”，那么邻接矩阵的优先级就更高。如果最常见的操作是“获取一个点的所有朋友”，那么邻接表就更合适。
- **图是“终极”数据结构：** 很多其他数据结构，都可以看作是图的一种特例。例如，链表是一条线的图，树是一种没有环的、特殊的图。理解了图，就等于拥有了理解更广泛数据结构的通用视角。

---

🎀 **安妮的小小日记本**

今天我才发现，我每天都生活在一张张巨大的“图”里！社交网络是图，地铁线路图是图，甚至这座图书馆也是一张巨大的知识之图！

原来，把这些复杂的“关系”画成地图，在计算机里主要有两种方法。一种叫“邻接矩阵”，像一张大而全的飞行图，优点是查两地通不通航超快，缺点是如果航线很少，地图上就全是空白，太浪费纸了。

另一种叫“邻接表”，更像是一本旅行指南，每一页只介绍一个城市和从它出发能去的地方。优点是超级省纸，信息一点不浪费，但想知道两个不相关的城市之间有没有路，就得在那一页上找半天。

所以，当地图上的路很密（稠密图）时，用矩阵；路很稀疏时，用列表。感觉自己又掌握了一项重要的“决策”技能！以后再遇到复杂的“关系”问题，我第一步就知道该怎么为它“绘制地图”了！

---

> **图（Graph）**是一种由**顶点（Vertex）**的非空集合和一组描述顶点之间关系的**边（Edge）**组成的数学结构。它是用来对物体与物体之间的成对关系建模的工具。在计算机科学中，存储图主要有两种标准方式：**邻接矩阵（Adjacency Matrix）**，一个V×V的二维数组，其中`matrix[i][j]=1`表示顶点i和j之间有边，它查询快但空间开销大，适用于稠密图。**邻接表（Adjacency List）**，一个包含V个列表的数组，其中`list[i]`存储了所有与顶点i邻接的顶点，它节省空间，适用于稀疏图，是绝大多数图算法的首选存储方式。

### 今日关键词

- **图 (Graph):** 由顶点和边组成，用于表示“关系”的数据结构。
- **顶点 (Vertex / Node):** 图中的一个基本单元，代表一个实体。
- **边 (Edge):** 连接两个顶点的线，代表它们之间的关系。
- **邻接矩阵 (Adjacency Matrix):** 用二维数组存储图，`M[i][j]`表示i和j之间的连接关系。
- **邻接表 (Adjacency List):** 用数组（或哈希表）加列表的方式存储图，每个顶点对应一个记录其所有邻居的列表。
- **稀疏图 (Sparse Graph):** 边的数量远小于顶点数量平方的图。
- **稠密图 (Dense Graph):** 边的数量接近顶点数量平方的图。
- **度 (Degree):** 一个顶点所拥有的边的数量。

### 名词小传

**图论（Graph Theory）**的起源，通常被追溯到1736年，与一个著名的问题——**柯尼斯堡七桥问题**紧密相连。当时，普鲁士的柯尼斯堡（现俄罗斯加里宁格勒）被普雷格尔河环绕，河上有七座桥连接着两岸和两个岛屿。问题是：一个散步者能否一次性地走遍七座桥，且每座桥只走一次？伟大的瑞士数学家**莱昂哈德·欧拉（Leonhard Euler）**解决了这个问题。他天才地将陆地抽象为“顶点”，将桥抽象为“边”，从而将一个现实的地理问题，转化为了一个纯粹的、关于点和线的数学问题。他证明了这种走法是不可能的，并在此过程中，开创了“图论”这一全新的数学分支，为后来的网络科学、拓扑学和计算机算法奠定了基础。

### 图存储定义

**图的存储（Graph Representation）**是指在计算机内存中，选择一种合适的数据结构来表示一个图的顶点和边，以便于后续算法的执行。主要方法包括**邻接矩阵**，一个表示所有顶点对之间邻接关系的二维数组，其空间复杂度为O(V²)，适用于稠密图；以及**邻接表**，它为每个顶点维护一个邻接顶点的列表，其空间复杂度为O(V+E)，适用于稀疏图。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard

**思维辨析与实现题**
1.  **手绘练习（无代码）**：给定一个包含5个顶点和6条边的无向图（可以自己随意设计），请分别画出它的邻接矩阵和邻接表示意图。
2.  **手绘练习（无代码）**：给定一个包含4个顶点的有向图，其中A->B, A->C, B->C, D->A，请分别画出它的邻接矩阵和邻接表示意图。
3.  **代码实现（无代码，或伪代码）**：请描述如何用“哈希表嵌套列表”的方式（如 `Map<Vertex, List<Vertex>>`）来实现一个邻接表。这种实现方式与“数组嵌套列表”相比，有什么优缺点？（提示：考虑顶点不是整数，而是字符串的情况）

**应用题**
4.  **LC 997 Find the Town Judge** ⭐⭐
    > **推荐理由**：一个非常好的、将现实问题转化为图论问题的入门题。你需要将“信任”关系，建模为图的边。然后，根据“法官”的定义（不信任任何人，被所有人信任），计算每个顶点的“入度”和“出度”。这个问题能让你练习如何从零开始，思考并构建一个图的表示（虽然不一定需要显式地建图，但思维是图论的）。

5.  **LC 1791 Find Center of Star Graph** ⭐
    > **推荐理由**：一个极简的图问题。星形图的中心节点，会出现在每一条边中。你只需要检查前两条边，找出那个共同的顶点即可。这道题能让你快速理解“边”和“顶点”的关系。
