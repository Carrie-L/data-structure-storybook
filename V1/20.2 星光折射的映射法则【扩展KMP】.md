### **20.2 星光折射的映射法则【扩展KMP】**

*"一道星光，自我的原点折射而出，映照出我与宇宙深处的每一寸相似。这道光的轨迹，便是Z算法的全部奥秘。"*

在领略了Trie树这种巧妙处理“前缀”的数据结构后，女孩们对字符串算法的“空间换时间”思想有了更深的体会。但黛芙指出，字符串的世界里，还有另一类更关心“匹配”与“模式”的算法。

“我们之前在卷一，学习过KMP算法。”黛芙回忆道，“它通过一个`next`数组，预处理‘模式串’自身，记录了其前缀和后缀的相似信息，从而在匹配失败时，能进行‘智能’的跳转。”

“今天，我们要学习一种思想上类似，但应用更广、也更独特的算法——**Z算法**（也称扩展KMP）。它同样通过预处理，来揭示字符串内部的深层结构。”

伊莎贝尔指着窗外夜空中最亮的北极星。“想象一下，整个字符串就是一条长长的星河。Z算法所做的，就是以星河的‘起点’为观测站，发射出一道神奇的‘星光’。这道光，会沿着星河一路前进，并同时与从‘起点’开始的星轨，进行比对。它要记录的，就是‘从星河的每一个位置出发，能与星河的‘开头’（前缀）拥有多长的共同路径’。”

#### **Z-Box与Z-Array：定义相似度**

“Z算法的核心，是计算一个叫做‘**Z数组**’（Z-array）的东西。”黛芙在白板上写下一个字符串 `S = "aabcaabxaaaz"`。

“对于这个字符串S，它的Z数组`Z`的定义是这样的：”

-   `Z[i]` 代表：从字符串`S`的第`i`个位置开始的子串，与`S`的**整个前缀**，所拥有的**最长公共前缀**的长度。

“这个定义有点绕，我们来分解一下。”

-   `Z[0]` 没有意义，通常设为0或N。
-   `Z[1]`: 从`S[1]`（`'a'`）开始的子串是`"abcaabxaaaz"`。它与`S`的完整前缀`"aabcaabxaaaz"`的最长公共前缀是`"a"`，长度为1。所以 `Z[1] = 1`。
-   `Z[2]`: 从`S[2]`（`'b'`）开始的子串是`"bcaabxaaaz"`。它与`S`的前缀，第一个字符就不匹配。所以 `Z[2] = 0`。
-   `Z[5]`: 从`S[5]`（`'a'`）开始的子串是`"abxaaaz"`。它与`S`的前缀`"aabcaabxaaaz"`的最长公共前缀是`"ab"`，长度为2。所以 `Z[5] = 2`。
-   `Z[8]`: 从`S[8]`（`'a'`）开始的子串是`"aaaz"`。它与`S`的前缀`"aabcaabxaaaz"`的最长公共前缀是`"aaa"`，长度为3。所以 `Z[8] = 3`。

“这个`Z[i]`的值，所对应的匹配区间 `[i, i+Z[i]-1]`，我们称之为‘**Z-box**’。”

#### **线性时间的构建奇迹：Z-Box的扩展**

“如果对每个`i`，我们都用一个循环去暴力比较`S[i:]`和`S[0:]`，那计算整个Z数组的复杂度就是O(N²)，这没什么了不起的。”希娅指出了问题。

“没错，”黛芙笑道，“Z算法的真正威力，在于它能以**O(N)的线性时间**，计算出整个Z数组。它利用了一个和Manacher算法非常相似的‘扩展’思想。”

**核心思想：**
在从左到右计算`Z[i]`时，我们会维护一个“**当前已知的、右边界最靠右的Z-box**”。我们称这个Z-box为 `[L, R]`。

当我们要计算新的`Z[i]`时：

1.  **如果`i`在`[L, R]`的范围之外（`i > R`）：**
    -   说明我们没有任何历史信息可以利用。只能从`i`开始，一个一个地向后和`S`的前缀进行**暴力比较**，直到不匹配为止。然后用这个新的Z-box，来更新`[L, R]`。

2.  **如果`i`在`[L, R]`的范围之内（`i <= R`）：**
    -   “这正是奇迹发生的地方！”黛芙强调，“`i`在`[L,R]`内，意味着`S[L...R]`这一段，是和`S`的某个前缀`S[0...R-L]`完全一样的！”
    -   “所以，`S[i]`这个位置，就对应着前缀中的`S[i-L]`这个位置。那么，`Z[i]`的值，就和`Z[i-L]`的值，有着密切的关系！”

    -   **情况A:** 如果`Z[i-L]`的值比较小，小到`i-L + Z[i-L]`这个范围，完全没有超出`[0, R-L]`，那么我们就可以断定：**`Z[i] = Z[i-L]`**。因为`S[i-L]`能匹配多长，`S[i]`就能匹配多长，而且不会超出已知的`[L,R]`范围。

    -   **情况B:** 如果`Z[i-L]`的值很大，大到`i-L + Z[i-L]`超出了`[0, R-L]`的范围。这意味着，`Z[i]`的匹配长度，**至少**能达到`R-i+1`（即从`i`到`R`的长度）。至于能不能更长，我们就需要从`R+1`的位置开始，继续向后进行**暴力比较**，并用可能形成的、更大的新Z-box，来更新`[L, R]`。

“通过复用之前计算过的Z值，并巧妙地扩展已知的匹配区间`[L,R]`，Z算法保证了每个字符最多只会被访问常数次，从而实现了O(N)的惊人效率。”

#### **Z算法的应用：字符串匹配**

“这个神奇的Z数组，有什么用呢？”安妮问。

“它最直接的应用，就是进行字符串匹配。”黛芙说，“假设我们要在文本`T`中，寻找模式串`P`。”

-   **构造新串:** 我们将`P`和`T`用一个不会出现的特殊字符（如`#`）拼接起来，形成一个新的字符串 `S = P + # + T`。
-   **计算Z数组:** 对这个新的字符串`S`，计算其Z数组。
-   **查找答案:** 遍历Z数组。如果在某个位置`i`，我们发现`Z[i]`的值，恰好等于模式串`P`的长度，这意味着什么？

“意味着……从`S`的第`i`个位置开始的子串，与`S`的前缀（也就是`P`）的匹配长度，正好是`P`的长度！”安妮恍然大悟，“这不就说明，我们在文本`T`中，找到了一个完整的模式串`P`吗！”

冬夜的星光，仿佛也凝聚成了Z算法的射线，从一个原点出发，洞察着整个字符串宇宙的内在结构与相似性。安妮感觉，自己不再是简单地学习一个“算法”，而是在学习一种全新的“视角”——一种能将一维的序列，映射到高维的、充满关联的结构中去审视的强大视角。

---

🌸 **Z算法核心要点** 🌸

**1. 算法设计的根本思想**
- **自身匹配：** Z算法的核心，是计算一个字符串的每一个后缀，与它自身整体的匹配程度。它将“外部匹配”（文本串与模式串）的问题，转化为了一个纯粹的“内部结构分析”问题。
- **信息的复用：** 算法的线性时间效率，来源于对已计算信息的最大化复用。通过维护一个“最右”的匹配区间`[L, R]`，使得在区间内的计算，可以借助已有的Z值来“初始化”或“加速”，避免了大量的重复比较。
- **“扩展”思想：** Z算法与Manacher算法在思想上高度一致，都是通过维护一个已知的、最有利的“回文/匹配”区间，并尝试“扩展”这个区间的边界，来实现线性时间复杂度。

**2. 核心设计哲学**
- **线性扫描的艺术：** Z算法是一个单次遍历（Single Pass）的算法。它在从左到右的扫描过程中，动态地维护和利用`[L, R]`区间，展现了在线性扫描中处理复杂逻辑的精妙艺术。
- **代码的简洁与深刻：** 相比于KMP算法需要单独构建`next`数组，Z算法的实现，将Z数组的计算和匹配过程，统一在了一个循环内，代码通常更短，但其背后的“区间复用”思想，需要更深刻的理解。
- **通用性：** Z数组本身，作为一个字符串的“结构指纹”，其信息量非常丰富，可以被用于解决多种不同的字符串问题，而不仅仅是简单的模式匹配。

**3. 算法思维的启发**
- **寻找“对称性”或“重复性”：** 许多高效的字符串算法，其根源都在于挖掘字符串内部的对称、周期、前后缀重复等结构性特征。Z算法就是这种思想的典范。
- **维护“最优状态”：** 在迭代或扫描过程中，维护一个“当前最优”的状态（如最长、最右、最大），并利用这个状态来加速后续的计算，是一种非常重要的算法优化技巧。
- **从具体到抽象：** 将字符串匹配问题，抽象为“计算一个拼接字符串的Z数组”的问题，这种“问题转化”和“模型抽象”的能力，是解决复杂算法问题的关键。

---

🎀 **安妮的小小日记本**

Z算法，听起来就像一个来自未来的、很酷的代号！

我太佩服这个算法的设计者了！它的想法真的好巧妙。通过维护一个“已知匹配区域”`[L, R]`，就像是在地图上标记出一个“安全区”。当我走到安全区里面的时候，我就可以参考前面探过路的人（`Z[i-L]`）的经验，快速知道我能走多远。只有当我走到安全区之外，或者我的参考经验告诉我可能会走出安全区时，我才需要自己一步步地去探索。这样，就省掉了好多好多力气！

用它来做字符串匹配，那个`P + # + T`的构造方法，也像一个魔法。把两个不相干的东西拼在一起，然后用Z算法去分析这个“缝合怪”的“自我相似性”，竟然就能得到我们想要的匹配结果！

我感觉，高级的算法，越来越像是在玩一种“转化”的游戏。把一个看似无从下手的问题，转化成另一个我们有高效工具可以解决的模型。这种思维，真的太迷人了！

---

### 今日关键词

- **Z算法 (Z-Algorithm):** 一种用于计算字符串Z数组的线性时间算法。
- **Z数组 (Z-array):** 一个数组`Z`，其中`Z[i]`表示原字符串`S`从`i`位置开始的后缀，与`S`的整个前缀的最长公共前缀的长度。
- **Z-box:** 由`Z[i]`定义的、从`i`开始的匹配区间`[i, i+Z[i]-1]`。
- **扩展KMP (Extended KMP):** Z算法的别称，因为它所计算的Z数组，可以用来解决一些KMP无法直接解决的、更复杂的匹配问题。
- **区间复用:** Z算法的核心思想，即利用已知的最右Z-box `[L, R]`的信息，来加速后续Z值的计算。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（模板与理解）**  
1.  **手动实现Z算法** ⭐⭐⭐ —— 亲手实现Z算法，计算一个给定字符串的Z数组。这是理解其“区间复用”和“扩展”思想的必经之路，挑战性较高。
2.  **用Z算法实现strStr()** ⭐⭐ —— 在你实现了Z算法的基础上，用`P + # + T`的模式，来解决经典的LC 28. Implement strStr() 问题。

**进阶巩固（模型应用）**  
3.  LC 214. Shortest Palindrome ⭐⭐⭐ —— 最短回文串。要求在字符串前面添加最少的字符，使其成为一个回文串。这个问题可以转化为：寻找原字符串`s`的“最长回文前缀”。可以通过将`s`和`s`的逆序`rev_s`拼接（`s + # + rev_s`），然后计算Z数组来解决。
4.  **寻找字符串的所有周期** ⭐⭐⭐ —— （理论题）一个字符串`S`的周期`T`是指`S`是`T`的若干次重复。如果`S`的长度`N`可以被`N - Z[i]`整除，那么`S`就拥有一个长度为`i`的周期。利用Z数组，可以高效地找到所有周期。
