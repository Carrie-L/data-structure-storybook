### **2.6 思绪漫溢的便签花墙【链表·刷题精选】**

*"当理论的丝线，于指尖化为真实的代码，每一次指针的游走与链接，都如在思绪的花墙上，贴上一枚枚记录着灵感的便签，最终，汇成一片绚烂的风景。"*

在系统地学习了链表的各种形态、操作与复杂度权衡之后，春日午后的阳光，变得愈发柔和。社团活动室里，那面原本空白的墙壁，已经被女孩们用彩色的便签，贴成了一面“花墙”。每一张便签上，都记录着一个算法的知识点、一个巧妙的思路，或是一段让她们刻骨铭心的代码。

“理论的珍珠已经串好，现在，是时候用真正的谜题，来检验我们的项链是否牢固了。”希娅伸了个懒腰，打开了她的笔记本电脑，“我挑选了几道最经典、最高频的链表题目。它们就像是链表世界的‘毕业考试’，通过了它们，才算真正掌握了链表的‘穿针引线’之术。”

#### **第一道谜题：反转的思念 (Reverse Linked List)**

希娅点开了第一题，也是她们在白板编程练习中，已经“预演”过的那道题：**LC 206. 反转链表**。

“虽然我们已经知道思路了，”黛芙说，“但这一次，要求每个人，都必须亲手、不借助任何提示，用‘迭代法’和‘递归法’两种方式，都实现一遍。这是基本功中的基本功，没有任何捷径。”

安妮点了点头，在自己的电脑上，开始认真地编写代码。她先是熟练地写出了“三指针”的迭代版本。

**迭代法回顾：**
-   `prev`指针，像一个“收线人”，初始为`null`，它永远指向已经反转好的那部分链表的“新头”。
-   `curr`指针，是“当前处理的节点”，初始为`head`。
-   `next_temp`指针，是“临时工”，负责在`curr`改变指向前，保存好它的下一个节点，防止“断链”。
-   循环的核心，就是不断地执行`curr.next = prev`（将当前节点指向前一个），然后将三个指针整体向后“滚动”一步（`prev = curr; curr = next_temp;`）。

接着，她又开始挑战更具思维性的递归版本。

**递归法回顾：**
-   **基例：** 当链表为空，或只有一个节点时，它本身就是反转后的样子，直接返回。
-   **递归调用：** “信任的飞跃”——我假设`reverseList(head.next)`这个函数，已经能完美地，将`head`之后的所有节点，都反转好，并返回了新的头节点`new_head`。
-   **当前层处理：** 我现在手头有两样东西：头节点`head`，和已经反转好的、以`new_head`为头的后续链表。我需要做的，只是将`head`，接到这个新链表的“尾巴”上。而这个“尾巴”，恰好就是`head.next`！
-   所以，操作是：`head.next.next = head;`（让原来的第二个节点，反过来指向我），然后`head.next = null;`（我成为新的尾巴，要断开原来的指向）。

当两种解法都顺利通过时，安妮感觉自己对链表指针的理解，才真正地，从“知道”，变成了“掌握”。

#### **第二道谜题：快慢的相遇 (Linked List Cycle)**

“下一题，来一个有趣的追及问题。”希娅展示了第二题：**LC 141. 环形链表**。

“题目要求我们判断一个给定的链表，是否存在‘环’。比如，尾节点指向了链表中的某一个节点。”

“这个问题，如果用哈希集合，可以很简单地解决。”伊莎贝尔提示道，“我们遍历链表，每遇到一个节点，就把它存入哈希集合。如果在存入前，发现它已经存在了，那就说明我们‘又一次’走到了这个节点，链表有环。时间复杂度O(N)，空间复杂度O(N)。”

“这个方法很好，但面试官通常会追问：‘能否用O(1)的空间复杂度来解决？’”黛芙说。

这个问题，让安妮陷入了沉思。不用额外的空间，又要判断是否重复……

“想象一下，在一个环形的跑道上，一个跑得快的人，和一个跑得慢的人，同时从起点出发，会发生什么？”伊莎贝尔再次给出了那个生动的比喻。

“跑得快的人，迟早会从后面，‘追上’那个跑得慢的人，并且是‘套圈’追上！”安妮的眼睛一亮。

“正是如此！这就是‘**快慢指针**’（Fast & Slow Pointers）技巧，也叫‘弗洛伊德判环算法’！”黛芙肯定道，“我们创建两个指针，`slow`和`fast`，都从头节点出发。`slow`一次走一步，`fast`一次走两步。”

-   **如果链表无环：** `fast`指针会率先到达终点（`null`），比赛结束。
-   **如果链表有环：** `fast`指针会先进入环，然后`slow`指针也会进入环。之后，它们俩就像在环形跑道上赛跑。因为`fast`比`slow`快，所以`fast`一定会在未来的某一圈，从后面追上`slow`。

```cpp
bool hasCycle(ListNode *head) {
    ListNode *slow = head, *fast = head;
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { // 快慢指针相遇
            return true;
        }
    }
    return false; // 快指针到头，无环
}
```

“这个算法，不仅空间复杂度是O(1)，而且思想极其巧妙，是链表问题中必须掌握的核心技巧之一。”

#### **第三道谜题：有序的融合 (Merge Two Sorted Lists)**

“最后一题，回归到‘有序’。”希娅点开了 **LC 21. 合并两个有序链表**。

“题目要求我们将两个已排序的链表，合并成一个新的、仍然有序的链表。”

“这个问题，和归并排序里的`merge`操作，思想是一样的！”安妮立刻看出了它的本质，“我们只需要创建一个新的‘虚拟头节点’`dummy`，然后用一个`current`指针，来像‘穿糖葫芦’一样，把两个链表中较小的节点，一个个地串起来。”

**解题思路：**
1.  创建一个`dummy`节点，作为新链表的“哨兵”头节点。`current`指针初始指向`dummy`。
2.  当两个链表`l1`和`l2`都非空时，循环：
    -   比较`l1.val`和`l2.val`。
    -   将值较小的那个节点，链接到`current.next`。
    -   将`current`指针，和被选中的那个链表的指针，都后移一位。
3.  循环结束后，最多只会有一个链表还有剩余。将这个剩余的链表，直接链接到`current.next`。
4.  返回`dummy.next`，即为新链表的真正头节点。

“虚拟头节点`dummy`的使用，是这道题的一个关键技巧。”黛芙总结道，“它让我们无需对‘新链表的第一个节点’进行特殊的`if-else`判断，使得整个代码逻辑，变得统一而简洁。”

窗外的樱花，仍在飘落。安妮感觉，自己对链表的理解，也在这三道题的锤炼中，完成了最后的“拼合”。从指针的反转，到快慢的追逐，再到有序的融合，她已经能熟练地，在这条由“数据”与“指针”构成的、精巧的“珍珠项链”上，跳出属于自己的、优雅而自信的舞步了。

---

🌸 **链表解题核心要点** 🌸

**1. 算法设计的根本思想**
- **指针操作是核心：** 所有链表题，万变不离其宗，都是在考察对指针（引用）的理解和操作能力。画图，是保证指针操作正确性的不二法门。
- **虚拟头节点（Dummy Head）：** 在任何可能涉及到“修改头节点”的操作中（如头部插入、头部删除、反转），都应优先考虑使用虚拟头节点。它可以极大地简化边界条件的处理，让代码更健壮、更优雅。
- **快慢指针：** “快慢指针”是链表问题中的一个“万能”技巧。它不仅能用来判环，还能用来找中点、找倒数第K个节点等，其应用非常广泛。

**2. 核心设计哲学**
- **迭代 vs. 递归：** 很多链表问题，都同时存在“迭代”和“递归”两种解法。迭代法通常空间复杂度更优（O(1)），逻辑更直接；递归法代码可能更简洁，更符合问题的数学定义，但有栈溢出的风险。在面试中，能写出两种解法，并分析其优劣，是加分项。
- **空间换时间：** （回顾）在判环问题中，哈希表法用O(N)的空间，换来了简单的逻辑。而快慢指针法，则用更巧妙的思路，达到了O(1)的空间。

**3. 算法思维的启发**
- **将问题分解：** 复杂的链表问题（如K个一组反转），可以分解为“反转一个小组”、“连接各个小组”等子问题。先实现核心的子功能，再将它们组合起来。
- **“穿针引线”的耐心：** 链表题，急不得。每一步指针的修改，都要想清楚它对前后节点的影响。宁可在纸上多画几分钟，也不要急着上手写出充满bug的代码。
- **从链表到其他：** 快慢指针的思想，不仅用于链表，在数组中（如寻找重复数）也有应用。将从一个数据结构上学到的技巧，迁移到其他问题上，是能力提升的标志。

---

🎀 **安妮的小小日记本**

今天的解谜游戏，太过瘾了！

我发现，链表题，真的就像是在做一场精细的“指针手术”。反转链表，是把所有的连接都反向；快慢指针判环，是让两个“探测器”在血管里赛跑；合并有序链表，则是把两条血管，完美地吻合在一起。

写代码的时候，我感觉自己真的像一个医生，手里拿着`prev`, `curr`, `next`这三把“手术刀”，小心翼翼地，在数据的脉络间，进行着切断、分离和缝合。每当一个指针指向了它该去的地方，一个节点被完美地链接或断开，那种逻辑严丝合缝的快感，真的让人着迷！

特别是“虚拟头节点”这个技巧，它就像一个万能的“手术定位器”，让我的所有操作，都有了一个稳固的起点，再也不用担心对“头”动刀时，手忙脚乱了。

我感觉，我好像，有点爱上这种在指针之间“穿针引线”的感觉了！

---

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium ⭐⭐⭐ = Hard
> （本章的练习题已在2.1节中详细列出，此处不再重复。请参考2.1节的推荐列表，并额外挑战以下几道经典题目，以深化对链表技巧的理解。）

**额外挑战**
1.  LC 142. Linked List Cycle II ⭐⭐ —— 环形链表II。在判断有环的基础上，还需要准确地找到“环的入口节点”。这需要一些额外的数学推导：当快慢指针相遇后，将一个指针放回头节点，然后两个指针都以一次一步的速度前进，它们再次相遇的地方，就是环的入口。
2.  LC 19. Remove Nth Node From End of List ⭐⭐ —— 删除链表的倒数第N个节点。可以用“快慢指针”来解决。让快指针先走N+1步，然后快慢指针一起走。当快指针走到头时，慢指针恰好指向“倒数第N个节点的前一个节点”。
3.  LC 23. Merge k Sorted Lists ⭐⭐⭐ —— 合并K个排序链表。这是“合并两个有序链表”的升级版。可以用“分治法”（类似归并排序）或者“优先队列（最小堆）”来解决，是综合运用多种数据结构和算法思想的绝佳题目。
4.  LC 25. Reverse Nodes in k-Group ⭐⭐⭐ —— K个一组翻转链表。链表操作的终极考验之一，要求你对链表的断开、反转、重连，有极其精准的掌控力，非常考验代码的细节和鲁棒性。
