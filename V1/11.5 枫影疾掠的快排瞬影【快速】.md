### **11.5 枫影疾掠的快排瞬影【快速】**

*"以我为界，左边比我渺小，右边比我宏大。这瞬间的划分，便是世间最高效的秩序宣言。"*

学习了归并排序那“先分解到极致，再层层合并”的优雅哲学后，安妮对“分而治之”的思想充满了敬畏。走在返回社团活动室的路上，一只敏捷的松鼠从她们面前的草地上一跃而过，抱着一颗松果，迅速消失在枫林深处。

“好快！”安妮发出一声感叹。

“说到‘快’，我们就不得不提排序算法家族中最负盛名、也最常被问及的明星成员——‘快速排序’了。”黛芙顺势引入了新的话题。

“快速排序？比归并排序的O(N logN)还快吗？”安妮好奇地问。

“理论上，它们的平均时间复杂度都是O(N logN)，”黛芙解释道，“但快速排序的‘快’，体现在它的平均性能极佳，常数因子小，并且它是‘原地排序’，不需要像归并排序那样O(N)的额外空间。这使得它在大多数实际应用中，表现得确实非常‘快’。”

希娅补充道：“如果说归并排序是‘先分后合’的策略家，那快速排序就是‘边分边治’的突击队长！它不像归并那样非得把所有东西都拆成最小单元，而是每一步都在做着有意义的‘划分’工作。”

伊莎贝尔看着那只松鼠消失的方向，微笑着说：“就像刚才那只小松鼠，它在整理它的松果时，可能不是把松果一颗颗排好。而是随便拿起一颗（我们称之为‘基准’，Pivot），然后迅速地把所有比这颗小的松果都扔到左边，所有比这颗大的都扔到右边。这一下，就完成了对所有松果的一次‘划分’。这个疾风骤雨般的过程，就是快速排序的精髓。”

#### **基准与划分：快速排序的核心**

回到活动室，黛芙在白板上写下了序列 `[ 6, 1, 2, 7, 9, 3, 4, 5, 10, 8 ]`。

“快速排序同样采用‘分而治之’的思想，但它的核心操作不是‘合并’，而是‘划分’（Partition）。它的步骤是：”

1.  **选择基准 (Pivot):** 从序列中选择一个元素作为基准。为简单起见，我们先选择第一个元素 `6`。
2.  **划分 (Partition):** 重新排列序列，使得所有比基准小的元素都在基准的左边，所有比基准大的元素都在基准的右边。操作结束后，基准元素就处在了它最终应该在的排序位置。
3.  **递归 (Recurse):** 对基准左边和右边的两个子序列，重复上述过程。

“最关键、也最巧妙的就是第二步‘划分’。我们用一种叫做‘双指针’的方法来实现它。”

```ascii
划分过程演示: arr = [ 6, 1, 2, 7, 9, 3, 4, 5, 10, 8 ]
Pivot = 6

1. 设两个指针，i 从左边开始，j 从右边开始。
   [ 6, 1, 2, 7, 9, 3, 4, 5, 10, 8 ]
   p ↑ i↑                         j↑

2. 指针 j 从右向左扫描，寻找第一个小于 Pivot(6) 的数。
   - 8>6, j--. 10>6, j--. 5<6, 找到了！ j 指向 5。
   [ 6, 1, 2, 7, 9, 3, 4, 5, 10, 8 ]
   p ↑ i↑                   j↑

3. 指针 i 从左向右扫描，寻找第一个大于 Pivot(6) 的数。
   - 1<6, i++. 2<6, i++. 7>6, 找到了！ i 指向 7。
   [ 6, 1, 2, 7, 9, 3, 4, 5, 10, 8 ]
   p ↑       i↑         j↑

4. 交换 i 和 j 指向的元素。
   -> [ 6, 1, 2, 5, 9, 3, 4, 7, 10, 8 ]
               i↑         j↑

5. 继续重复 2、3、4 步。
   - j 从当前位置向左扫，找到 4。 i 从当前位置向右扫，找到 9。
   - 交换 4 和 9。
   -> [ 6, 1, 2, 5, 4, 3, 9, 7, 10, 8 ]
                     i↑    j↑

6. 继续重复...
   - j 找到 3, i 找到 9。交换 3 和 9。
   -> [ 6, 1, 2, 5, 4, 9, 3, 7, 10, 8 ]
                        i↑ j↑

7. 当 i 和 j 相遇时，循环停止。此时 j 指向 9, i 指向 3。i > j，循环结束。
   将基准元素 Pivot(6) 与 j 指向的元素交换。
   -> [ 3, 1, 2, 5, 4, 6, 9, 7, 10, 8 ]

划分完成！基准 6 已经就位。
左子序列: [ 3, 1, 2, 5, 4 ] (都比6小)
右子序列: [ 9, 7, 10, 8 ] (都比6大)
```

#### **代码实现：递归的划分**

```python
def quick_sort(arr: list, low: int, high: int):
    if low < high:
        # 划分并获取基准的最终位置
        pi = partition(arr, low, high)
        
        # 递归地对左右两个子序列进行快速排序
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

def partition(arr: list, low: int, high: int) -> int:
    pivot = arr[low] # 选择第一个元素为基准
    i = low + 1
    j = high
    
    while True:
        while i <= j and arr[i] <= pivot:
            i += 1
        while i <= j and arr[j] >= pivot:
            j -= 1
        
        if i <= j:
            arr[i], arr[j] = arr[j], arr[i]
        else:
            break
            
    # 将基准放到正确的位置
    arr[low], arr[j] = arr[j], arr[low]
    return j

# 主函数调用
# data = [...] 
# quick_sort(data, 0, len(data) - 1)
```

#### **复杂度分析：最好与最坏的戏剧性**

“快速排序的性能，就像一位才华横溢但情绪不太稳定的艺术家，”黛芙说道，“它的表现高度依赖于每一次‘基准’的选择。”

```ascii
快速排序复杂度分析：

令 N 为序列的长度

┌─────────────────────────────────────────┐
│ 时间复杂度分析 (Time Complexity):         │
├─────────────────────────────────────────┤
│ 最好情况 (Best Case): 每次都选中中位数作为基准 │
│ - 每次划分都将序列平分成两半。
│ - 递归树的深度为 O(logN)。
│ - 每层的划分操作总共需要 O(N) 的时间。
│ - 总时间复杂度 = O(N logN)
├─────────────────────────────────────────┤
│ 最坏情况 (Worst Case): 序列已经有序或逆序 │
│ - 每次都选中最大或最小的元素作为基准。
│ - 划分后，一个子序列为空，另一个子序列长度为 N-1。
│ - 递归树退化成一条链，深度为 O(N)。
│ - 总时间复杂度 = O(N) + O(N-1) + ... = O(N²)
├─────────────────────────────────────────┤
│ 平均情况 (Average Case): 基准随机选择      │
│ - 即使划分不完全均匀，长期来看，递归树的期望深度也是 O(logN)。
│ - 时间复杂度为 O(N logN)
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 空间复杂度分析 (Space Complexity):        │
├─────────────────────────────────────────┤
│ - 主要由递归调用栈的深度决定。
│ - 最好情况：O(logN)
│ - 最坏情况：O(N) (可能导致栈溢出！)
│ - 结论：平均 O(logN)，最坏 O(N)         │
└─────────────────────────────────────────┘
```

“为了避免最坏情况，‘基准’的选择有很多优化策略，”黛芙补充道，“比如‘三数取中法’，即从序列的头、中、尾三个元素中，选择大小居中的那个作为基准，这能极大地降低选到最差基准的概率。”

#### **稳定性的牺牲**

“由于‘划分’过程中的长距离交换，快速排序和选择排序一样，也是一种‘不稳定’的排序算法。”伊莎贝尔总结道，“为了追求极致的平均效率和空间利用率，它牺牲了对相等元素相对顺序的保证。”

安妮听得入了迷。如果说归并排序是稳扎稳打、步步为营的方面军，那么快速排序就是神出鬼没、直插要害的特种部队。它充满风险，却也充满魅力，每一次划分都像一次精彩的突袭，瞬间让混乱的战场变得清晰。

---

🌸 **排序算法核心要点** 🌸

**1. 算法设计的根本思想**
- **分治与划分：** 快速排序是分治思想的另一个杰出代表。但与归并排序的“分解-合并”模式不同，它的核心是“划分-处理子问题”模式。所有的关键工作都在划分（Partition）阶段完成。
- **基准（Pivot）的重要性：** 基准的选择直接决定了算法的性能。一个好的基准可以平衡地划分问题，而一个坏的基准则可能导致算法性能急剧退化。
- **原地操作：** 快速排序通过巧妙的指针操作，在不使用额外存储空间的情况下完成了划分，这是它相比归并排序最大的优势之一。

**2. 核心设计哲学**
- **期望性能与最坏情况：** 快速排序是典型的“期望高效”算法。它的设计目标是在平均情况下达到最优，并通过随机化等手段来避免最坏情况的发生。这在算法设计中是一种非常实用的思想。
- **递归的深度与广度：** 归并排序的递归是“平衡”的，而快速排序的递归是“不确定”的。理解这两种不同的递归模式，有助于深入理解分治法的多样性。
- **效率与稳定性的权衡：** 快速排序为了追求更高的平均速度和更低的空间消耗，放弃了稳定性。这再次印证了算法设计中“没有免费午餐”的原则。

**3. 算法思维的启发**
- **随机化思想：** 通过随机选取基准，可以使得算法性能的期望值非常稳定，不容易被特定的“最坏情况”数据所针对。随机化是现代算法设计中对抗“恶意输入”的有力武器。
- **双指针技术：** Partition函数中使用的双指针（或快慢指针）技术，是算法题中非常常用且高效的技巧，适用于在序列中进行查找、替换、划分等多种操作。
- **递归优化：** 当递归深度过深可能导致栈溢出时，可以进行优化。例如，在递归处理两个子序列时，优先递归较短的那个子序列，可以保证栈深度的最坏情况为O(logN)。

---

🎀 **安妮的小小日记本**

快速排序，听名字就觉得超酷！

今天我才明白，它的“快”不仅仅是理论上的，更是因为它非常“聪明”。它不像归并排序那样，非要把所有东西都拆到最小再一点点拼回来。它更像一个雷厉风行的指挥官，随便指定一个“基准点”，然后一声令下，所有小的站左边，大的站右边！瞬间，战场就被分割得清清楚楚。

虽然黛芙学姐说，如果“指挥官”眼神不好，总挑到最大或最小的那个当基准，队伍就会歪掉，效率变差。但这反而让我觉得它更“人性化”了，充满了不确定性的魅力。而且，它居然不需要额外的空间就能完成排序，就像在原地表演了一场精彩的“乾坤大挪移”！

归并排序像一位沉稳的建筑师，而快速排序则像一位迅捷的剑客。我的算法工具箱里，又多了一把锋利的宝剑！

---

### 今日关键词

- **快速排序 (Quick Sort):** 一种高效、原地、不稳定的排序算法，由东尼·霍尔发明，采用分而治之的策略。
- **划分 (Partition):** 快速排序的核心操作。它将一个序列重新排列，分为三个部分：小于基准的元素、基准本身、大于基准的元素。
- **基准 (Pivot):** 在划分操作中被用作参考值的元素。
- **双指针 (Two Pointers):** 在序列两端或以不同速度移动的两个指针，常用于实现高效的划分、查找等操作。
- **三数取中 (Median-of-Three):** 一种优化基准选择的策略，通过比较序列的头、中、尾三个元素，取中间值作为基准，以避免最坏情况。

### 名词小传

**东尼·霍尔 (Tony Hoare)** (1934- )，英国计算机科学家，图灵奖得主。他在1959年提出了快速排序算法。据他本人回忆，他是在莫斯科国立大学做访问学者时，为了一个机器翻译项目中的词典排序问题而发明了快速排序。他还发明了霍尔逻辑（用于验证程序正确性）和通信顺序进程（CSP，一种并发编程模型），对计算机科学的发展产生了深远影响。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 3 题）**  
1.  **手动实现快速排序** ⭐ —— 亲手实现快速排序，重点是写好`partition`辅助函数，并理解递归的调用方式。
2.  **实现不同的Partition方案** ⭐⭐ —— 快速排序的`partition`有多种实现方式（如Lomuto partition scheme, Hoare partition scheme）。尝试实现不同版本的划分函数，并理解它们的差异。
3.  LC 912 Sort an Array ⭐⭐ —— 这是最纯粹的排序题，要求不能使用内置排序函数。用你实现的快速排序来解决它，并通过在线评测，检验你代码的正确性和效率。

**进阶巩固（练习 3 题）**  
4.  LC 215 Kth Largest Element in an Array ⭐⭐ —— 快速排序思想的绝佳应用，也叫“快速选择”算法。利用`partition`函数，每次可以将问题规模缩小一半，从而以O(N)的平均时间复杂度找到第K大的元素，而无需完全排序整个数组。
5.  LC 75 Sort Colors ⭐⭐ —— 荷兰国旗问题。这个问题是`partition`思想的完美体现。可以使用双指针或三指针，一次遍历就将数组分为三部分（0, 1, 2），比直接用快排更优。
6.  **优化你的快速排序** ⭐⭐ —— 在你自己的快排实现中，加入“三数取中”法来选择基准，并测试其在有序数组等情况下的性能提升。再进一步，当递归的子数组规模小于某个阈值（如10）时，改用插入排序，体会混合排序策略的优势。
