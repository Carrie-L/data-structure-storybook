### **17.3 封装之铠与继承之盾【类与面向对象】**

*"为数据穿上封装的重铠，抵御外界的无端侵扰；为思想持起继承的坚盾，于层层抽象中，构建不朽的秩序。"*

在掌握了指针这把锋利的“双刃剑”之后，安妮对C++的底层掌控力有了新的认识。但她也发现，在构建复杂的数据结构，如链表、二叉树时，单纯地使用`struct`和零散的函数，总感觉有些混乱。

“学姐，我们用C语言风格的`struct`来定义节点，再写一堆独立的函数来操作它，感觉数据和操作是‘分离’的。”安妮在一次代码复盘时说，“有时候会搞不清哪个函数对应哪个数据，或者不小心直接修改了数据内部的结构，造成错误。”

“你说到了点子上，”黛芙点头道，“这正是C语言这种‘面向过程’编程的局限性。为了解决这个问题，C++引入了更高级的组织方式——‘**面向对象编程**’（Object-Oriented Programming, OOP）。它的核心，就是‘**类**’（Class）。”

伊莎贝尔拿起一个保温杯，举例说明：“你看这个杯子。它有自己的‘**属性**’（Attributes），比如材质、容量、颜色。它也有自己的‘**行为**’（Behaviors），比如打开、关闭、保温。我们不关心它内部是真空层还是什么黑科技，我们只通过它提供的‘打开’和‘关闭’这两个‘接口’来使用它。这种将‘数据’和‘操作数据的方法’打包在一起，并隐藏内部细节的方式，就叫做‘**封装**’（Encapsulation）。”

#### **从`struct`到`class`：封装的力量**

“在C++中，`class`是对`struct`的扩展。”黛芙在白板上写道，“一个`class`，可以同时包含‘成员变量’（属性）和‘成员函数’（方法）。”

```cpp
// C风格的struct + 全局函数
struct Node_C {
    int data;
    Node_C* next;
};
void print_node(Node_C* node) { /*...*/ }

// C++的class
class Node_CPP {
public: // 公共接口
    int data;
    Node_CPP* next;

    void print() {
        // 方法可以直接访问自己的成员变量
        std::cout << this->data;
    }
};
```

“`class`还引入了‘访问控制’的概念，”黛芙补充道，“用`public`, `private`, `protected`这些关键字，我们可以精确地控制，哪些属性和方法是对外开放的‘接口’，哪些是只能在内部使用的‘秘密’。这就像为你的数据，穿上了一层坚固的‘封装之铠’，防止了外界的无意或恶意的修改。”

#### **继承与多态：思想的传承与演化**

“OOP更强大的地方，在于‘**继承**’（Inheritance）和‘**多态**’（Polymorphism）。”

希娅觉得这个话题有点偏离竞赛的“短平快”，插话道：“在算法竞赛里，我们很少会用到复杂的继承和多态。通常`struct`或者一个简单的`class`就够用了。”

“希娅说得对，”黛芙表示同意，“在分秒必争的竞赛中，我们追求的是极致的效率，往往会简化代码结构。但是，理解OOP的思想，对于我们未来走向更广阔的软件工程领域，至关重要。它是一种构建大型、可维护、可扩展软件系统的核心思想。”

伊莎贝尔用一个比喻来帮助安妮理解：“‘继承’，就像是‘算法思想’的传承。比如，‘二叉树’是一个‘基类’，它定义了节点、左右指针这些基本属性。而‘二叉搜索树’、‘平衡二叉树’、‘红黑树’，都是它的‘派生类’。它们‘继承’了二叉树的基本结构，又各自增添了新的、更强的‘特性’和‘规则’。”

“而‘多态’，则更像是一种‘抽象’的艺术。我们可能只需要下达一个通用的指令，比如`node->insert(value)`，程序会根据这个`node`到底是普通二叉搜索树，还是AVL树，‘智能地’执行各自不同的、专属的插入和旋转逻辑。这大大提高了代码的灵活性和可扩展性。”

#### **竞赛中的OOP：实用至上**

“所以，在集训阶段，我们对OOP的掌握，应遵循‘实用至上’的原则。”黛芙将话题拉回到竞赛本身。

1.  **用`class`或`struct`封装节点：** 在实现链表、树、图等数据结构时，用`class`或`struct`来定义节点，将数据和指向其他节点的指针封装在一起，是非常好的习惯。

2.  **构造函数 (Constructor):** 学会使用构造函数，来方便地初始化你的对象。这能让代码更简洁。
    ```cpp
    class Node {
    public:
        int val;
        Node* next;
        // 构造函数
        Node(int v) : val(v), next(nullptr) {}
    };
    // 创建节点时可以直接初始化
    Node* newNode = new Node(10);
    ```

3.  **操作符重载 (Operator Overloading):** 在某些情况下，比如在优先队列中使用自定义的`struct`，我们需要为它定义“小于”或“大于”的比较规则。这时，重载`<`操作符就非常有用。

安妮点了点头。她明白了，虽然在算法竞赛的“战场”上，她们需要的是最轻便、最锋利的匕首，而不是最华丽、最复杂的全身重铠。但是，理解这身重铠的设计思想——封装、继承、多态——能让她对“代码”这件武器，有更深刻的认识。这不仅关乎如何解决一个问题，更关乎如何“构建”一个优雅、健壮、可持续的解决方案。这是一种从“解题者”到“创造者”的思维跃迁。

---

🌸 **C++集训核心要点** 🌸

**1. OOP的核心思想**
- **封装 (Encapsulation):** 将数据（属性）和操作数据的方法（函数）捆绑在一起，形成一个独立的单元（对象），并对外界隐藏其内部实现细节。这是OOP的基石。
- **继承 (Inheritance):** 允许一个类（子类/派生类）获取另一个类（父类/基类）的属性和方法。它实现了代码的复用，并建立了类之间的“is-a”层次关系。
- **多态 (Polymorphism):** 允许不同类的对象对同一消息做出响应，即“同一接口，多种实现”。它通过虚函数（Virtual Functions）来实现，大大增强了程序的灵活性和可扩展性。

**2. 面向对象 vs. 面向过程**
- **面向过程 (Procedure-Oriented):** 以“过程”（函数）为中心，思考“一步步做什么”。数据和操作是分离的。
- **面向对象 (Object-Oriented):** 以“对象”为中心，思考“谁来做什么”。数据和操作被封装在一起。

**3. 竞赛中的实用主义OOP**
- **封装节点是首要应用：** 用`struct`或`class`来定义数据结构（如图节点、树节点）是最常见、最有用的实践。
- **构造函数简化代码：** 善用构造函数进行初始化，可以减少大量的重复代码。
- **操作符重载服务于STL：** 当需要将自定义类型放入`std::priority_queue`或`std::map`/`std::set`时，可能需要重载`<`操作符，或者提供一个自定义的比较函数（Functor）。

---

🎀 **安妮的小小日记本**

今天学习了“面向对象”，感觉像是从一个工匠，变成了一位建筑师。

以前我写代码，就像是把砖头（数据）和水泥（函数）分开堆放，用的时候再临时拿来组合。而面向对象的`class`，则像是预制好的一块块“墙体模块”。每一块墙体，都自带了窗户、门和内置的管线，功能齐全，接口清晰。我只需要把这些模块拼装起来，就能快速地盖起一栋大楼！

虽然黛芙学姐说，在竞赛中我们可能用不到太复杂的继承和多态，更像是在“搭帐篷”而不是“盖大楼”。但理解了“封装”这身铠甲的意义，让我以后在定义节点、处理数据时，会更有“整体”和“安全”的意识。

为我的数据穿上“封装之铠”，感觉它们也变得更安全、更有“尊严”了呢！

---

### 今日关键词

- **面向对象编程 (OOP):** 一种以“对象”为核心的编程范式，主要特征是封装、继承和多态。
- **类 (Class):** 在OOP中，用于创建对象的蓝图。它定义了一组属性（成员变量）和方法（成员函数）。
- **对象 (Object):** 类的一个实例。
- **封装 (Encapsulation):** 将数据和操作捆绑在一起，并隐藏内部细节的机制。
- **继承 (Inheritance):** 一个类派生自另一个类的机制，实现了代码复用。
- **多态 (Polymorphism):** “一个接口，多种实现”的特性，允许对不同类型的对象执行相同的操作。
- **构造函数 (Constructor):** 类的一种特殊成员函数，在创建对象时被自动调用，用于初始化对象。
- **操作符重载 (Operator Overloading):** 允许为自定义类型（如`class`或`struct`）重新定义标准操作符（如`+`, `-`, `<`）行为的C++特性。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议顺序：将OOP思想应用于数据结构实现中。

**基础入门（封装与构造）**  
1.  **用Class实现链表/二叉树** ⭐⭐ —— 将之前用指针和`struct`实现的链表或二叉树，用`class`进行改写。将`insert`, `delete`, `search`等操作，作为类的成员函数来实现，体会封装带来的好处。
2.  LC 707. Design Linked List ⭐⭐ —— 设计链表。这道题要求你完整地设计和实现一个链表类，包括获取、添加、删除节点等多种操作，是练习`class`封装的绝佳题目。
3.  LC 706. Design HashMap ⭐⭐ —— 设计哈希映射。不使用内置的哈希表库，亲手实现一个哈希映射。你需要设计一个`Node`结构来处理哈希冲突（拉链法），并用一个`class`来封装整个哈希表的`put`, `get`, `remove`等操作。

**进阶巩固（操作符重载与STL）**  
4.  **自定义类型的优先队列** ⭐⭐ —— 定义一个`struct`或`class`来表示一个任务（如 `struct Task { int priority; string name; }`）。然后，通过重载`<`操作符，使得这个自定义类型可以直接放入`std::priority_queue`中，并按优先级正确排序。
5.  LC 973. K Closest Points to Origin ⭐⭐ —— 寻找离原点最近的K个点。可以用一个大顶堆（`priority_queue`）来解决。你需要将“点”定义为一个`struct`或`class`，并自定义比较规则（按距离比较），以便优先队列能正确工作。
