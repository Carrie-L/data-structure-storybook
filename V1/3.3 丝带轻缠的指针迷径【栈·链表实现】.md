### **3.3 丝带轻缠的指针迷径【栈·链表实现】**

*"我以节点为珠，以指针为丝，每一次的压入，都是在项链之首，系上一颗新的晨星；每一次的弹出，都是解开那最旧的、对过往的牵绊。"*

在学习了如何用“数组”这个规整的“锦盒”，来构建高效的“顺序栈”之后，黛芙将话题，引向了栈的另一种、更具“动态”与“自由”之美的实现方式。

“数组实现的栈，无论是静态还是动态，都有一个共同的前提：它需要一块‘连续’的内存空间。”黛芙说，“但在某些内存碎片化严重，或者我们无法预知栈的最大深度，又不希望承担动态数组‘扩容’那一次O(N)开销的场景下，我们就需要另一种选择。”

“用链表！”安妮立刻想到了她们在第二章学习的那个“老朋友”，“我们可以用链表的‘头节点’，来作为栈的‘栈顶’！”

“完全正确。”伊莎贝尔拿起一根彩色的丝带，和几颗带孔的、漂亮的玻璃珠。“如果说，顺序栈，是用一个‘盒子’来约束数据。那么‘**链式栈**’（Linked-list-based Stack），就是用这根‘丝带’（指针），来定义数据的‘顺序’。”

#### **链式栈的实现：头插与头删的艺术**

“我们来思考一下，”黛芙引导道，“为什么选择‘头部’，而不是‘尾部’，来作为栈顶？”

“因为……”安妮回忆着链表的操作复杂度，“在单向链表上，‘头部插入’和‘头部删除’，都是O(1)的操作！而如果用尾部作栈顶，那`pop`（尾部删除）就需要O(N)的时间来找到倒数第二个节点，效率太低了！”

“无懈可击的分析。”黛芙赞许道，“所以，链式栈的实现，就是对‘链表头操作’的一次完美应用。”

她在白板上，画出了链式栈的内部结构和操作流程。

**数据结构：**
“我们只需要一个指针`top`，它永远指向链表的头节点，也就是我们的‘栈顶’。”

```cpp
// C++ 链式栈节点与栈定义
struct ListNode {
    int data;
    ListNode* next;
};

class LinkedStack {
private:
    ListNode* top = nullptr;
    int current_size = 0;
};
```

**1. 压入 (Push):**
“`push(item)`操作，等价于‘**在链表头部插入一个新节点**’。”

-   **步骤：**
    1.  创建一个新节点`newNode`。
    2.  让`newNode`的`next`指针，指向当前的`top`节点。
    3.  更新`top`指针，让它指向这个`newNode`。
-   **复杂度:** **O(1)**

```cpp
void push(int value) {
    ListNode* newNode = new ListNode(value);
    newNode->next = top;
    top = newNode;
    current_size++;
}
```

**2. 弹出 (Pop):**
“`pop()`操作，等价于‘**从链表头部删除一个节点**’。”

-   **步骤：**
    1.  检查栈是否为空（`top == nullptr`）。
    2.  用一个临时指针，保存当前的`top`节点，以便后续释放内存。
    3.  更新`top`指针，让它指向`top->next`。
    4.  返回并释放旧`top`节点。
-   **复杂度:** **O(1)**

#### **顺序栈 vs. 链式栈**

“现在，我们的两种‘栈’都已经打造完成了。”黛芙在白板上，并列出了它们的优缺点，像一位经验丰富的武器大师，在比较两把宝剑的特性。

```ascii
          栈的两种实现方式对比：顺序栈 vs. 链式栈

+--------------+------------------------------------+------------------------------------+
|     特性     |          顺序栈 (基于数组)           |          链式栈 (基于链表)           |
+==============+====================================+====================================+
|     优点     | 1. 内存连续，缓存友好，访问速度快。  | 1. 容量高度灵活，无须预估大小。    |
|              | 2. 无额外的指针开销，内存利用率高。  | 2. 不会产生扩容时的性能抖动。      |
+--------------+------------------------------------+------------------------------------+
|     缺点     | 1. 静态数组大小固定，有溢出风险。    | 1. 每个节点都有额外指针开销。      |
|              | 2. 动态数组有均摊的扩容成本和性能抖动。| 2. 内存不连续，缓存不友好。        |
+--------------+------------------------------------+------------------------------------+
|     选择     | 在栈的最大深度可知，或性能要求极致时。 | 在栈的深度变化剧烈、难以预测时。   |
+--------------+------------------------------------+------------------------------------+
```

“在绝大多数的应用场景中，”希娅总结道，“由于数组优异的缓存性能和更少的内存开销，基于动态数组的‘顺序栈’，是更常用、也通常是性能更好的选择。我们STL中的`std::stack`，其默认底层容器，也是`std::deque`（一种动态数组的变体），而不是`std::list`。”

安妮看着伊莎贝尔手中那根，用丝带（指针）串起来的玻璃珠（节点），又看了看黛芙画的那个，用`top`指针在格子里移动的“锦盒”（数组）。她明白了，为了实现“栈”这个统一的、抽象的“LIFO”行为，我们可以有截然不同的“物理路径”。而选择哪条路径，则取决于我们对时间、空间、灵活性等各种因素的综合“权衡”。

---

🌸 **链式栈核心要点** 🌸

**1. 算法设计的根本思想**
- **逻辑与实现的映射：** 链式栈，将“栈顶”这一逻辑概念，映射到了链表的“头部”。所有对栈顶的操作，都转化为对链表头部O(1)的增删操作。
- **动态性的极致：** 链式栈是完全动态的。它的容量，只受限于机器的总内存，每一次`push`，都精确地只申请一个节点的空间，没有丝毫浪费，也没有任何扩容的性能抖动。

**2. 核心设计哲学**
- **指针作为核心：** 整个数据结构的维系，完全依赖于`top`指针和节点内部的`next`指针。对指针的正确理解和操作，是实现链式栈的唯一关键。
- **优雅但有代价：** 链式栈在理论上，非常优雅地解决了顺序栈的“容量固定”或“扩容开销”问题。但它付出的代价，是额外的指针空间开销和潜在的、因内存不连续而导致的缓存性能下降。

**3. 算法思维的启发**
- **“头操作”的威力：** 链表的“头操作”（头部插入/删除）是O(1)的，这一特性，是它能被用作栈和队列（出队端）实现的基础。在设计算法时，要善于利用不同数据结构在“特定位置”操作的效率优势。
- **再次理解抽象：** （回顾）无论是顺序栈还是链式栈，它们对外暴露的接口（`push`, `pop`, `peek`）是完全一样的。使用者无需，也不应该关心其底层实现。这就是“抽象数据类型”的强大之处。

---

🎀 **安妮的小小日记本**

今天，我们用“链表”也造了一个栈！

这个过程，就像是在编一根只有一头可以加珠子的“手链”。每次`push`，就是拿一颗新珠子，用线穿过它，然后把线头系在这颗新珠子上，让它成为新的“链头”。每次`pop`，就是把链头的第一颗珠子解下来，然后把线头，重新系在它的下一颗珠子上。

所有的操作，都只在“链头”这个地方发生，所以都非常快！

我发现，数组和链表，就像两种不同性格的工匠。数组工匠，喜欢先把一个巨大、规整的工作台准备好，然后在上面快速地操作。而链表工匠，则更喜欢“随用随取”，每次只拿一小块材料来加工，虽然零散，但非常灵活。

用它们来实现同一个“栈”，让我更清楚地看到了它们各自的优点和缺点。感觉就像，为了到达同一个目的地，我可以选择坐“高铁”（数组栈，通常更快），也可以选择坐“飞机”（链式栈，更灵活）。真是太有趣了！

---

### 今日关键词

- **链式栈 (Linked-list-based Stack):** （回顾）使用链表作为底层容器来实现的栈。
- **顺序栈 (Array-based Stack):** （回顾）使用数组作为底层容器来实现的栈。
- **缓存友好 (Cache Friendly):** （回顾）指数据结构的内存布局，能很好地利用CPU的高速缓存机制，从而提高访问速度。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议：通过亲手实现，来巩固对两种栈实现的理解。

**练习**  
1.  **手动实现链式栈** ⭐⭐ —— 用你熟悉的语言，基于链表，亲手实现一个完整的栈类，包括`push`, `pop`, `peek`, `is_empty`, `size`等方法。并与你之前实现的“顺序栈”进行对比。
2.  **栈与队列的互相实现** ⭐⭐ —— （回顾）再次思考“用栈实现队列”和“用队列实现栈”这两个经典问题。现在，你可以从更底层的角度去思考：如果底层的实现分别是“数组”和“链表”，那么这些模拟操作的复杂度，是否会有不同？
