### **7.1 椰影婆娑的递归心跳【树遍历】**

*"每一棵树的生长，都遵循着一种递归的心跳。从根到枝，再到每一片叶，脉络里流淌着亘古不变的遍历诗篇。"*

海边的烧烤晚宴结束后，盛夏的白日带着灼人的热情再次降临。为了躲避正午的烈日，女孩们从开阔的沙滩，移步到不远处一片宁静的椰林中。高大的椰树投下斑驳的树影，海风穿过林间，带来阵阵清凉，连空气都似乎慢了下来。

安妮靠在一棵椰树下，仰头望着头顶的景象。阳光透过层层叠叠的宽大叶片，洒下无数细碎的光斑。她看到粗壮的树干（Trunk）在顶端分出几个大枝（Branch），每个大枝又分出更小的枝条，枝条的末端则挂着一片片独立的叶子（Leaf）。

“学姐们，”安妮悠悠地开口，她的思绪已经从假期的闲适，自然而然地飘回了算法的世界，“我们之前学的数组、链表、栈和队列，都像是一条线，或是一条路，我们总能顺着走下去。可是……这棵椰子树，它有好多的分岔，根本不是一条线。如果它也是一种数据结构，我们要怎么‘访问’到它的每一片叶子，才不会迷路或者漏掉呢？“

安妮的问题，标志着她们的探险之旅，正式从“线性世界”迈入了更为广阔和复杂的“非线性世界”。

“这真是一个绝佳的观察，安妮。”伊莎贝尔的声音温柔得如同林间的风，“你眼前的这棵椰子树，就是我们即将探索的、最重要的一种非线性数据结构——**树（Tree）**。”

黛芙已经在她的白板上，将一棵椰子树简化成了一个由节点和连线组成的、倒挂的树形结构。

```ascii
      ( A )  <-- 根节点 (Root)
      /   \
    ( B )   ( C ) <-- A的子节点 (Children)
    / \       /
  (D) (E)     (F)
             ^-- 叶子节点 (Leaf, 没有子节点)
```

“树由一个个**节点（Node）**和连接节点的**边（Edge）**组成。”黛芙解释道，“最顶端的节点叫**根（Root）**，每个节点下面连接的节点叫它的**子节点（Child）**，它自身则是子节点的**父节点（Parent）**。没有子节点的节点，就像树梢的叶子，我们叫它**叶子节点（Leaf）**。”

“你的问题——如何不重不漏地访问所有节点——就是树结构最基本、也最重要的操作：**树的遍历（Tree Traversal）**。”

#### **递归的心跳：深度优先遍历 (DFS)**

“想象我们是一群想要检查每一片树叶健康状况的小精灵，”伊莎贝尔生动地比喻道，“但我们有一个规则：必须系统性地飞，不能乱飞。一种最自然的策略是：**先一头扎到底，再回头换路。** 这种策略，我们称之为**深度优先遍历（Depth-First Search, DFS）**。”

“‘一头扎到底’……”安妮喃喃道，“这听起来有点像……我们之前在《秋镜湖畔》里遇到的‘递归’！”

“完全正确！”黛芙眼中闪过一丝惊喜，“树的结构与递归的思想，有着天然的、心跳般的共鸣。一个大树，是由几棵小一点的树组成的；而小树，又是由更小的树组成的……直到最小的‘树’——一片叶子。这种‘自我相似’的结构，正是递归大显身手的舞台。”

“深度优先遍历，根据我们访问‘根节点’的时机不同，主要分为三种：”

**1. 前序遍历 (Pre-order): 根 → 左 → 右**

“第一种策略，像个雷厉风行的指挥官。”黛芙说，“每到一个分岔路口（节点），他会先大声宣布‘我到了！’（访问根节点），然后命令部队：‘全力探索左边！’（递归遍历左子树），左边全部探索完毕后，再命令：‘全力探索右边！’（递归遍历右子树）。”

```python
def preorder_traversal(node):
    if node is None:
        return
    print(node.value)  # 1. 访问根节点
    preorder_traversal(node.left)  # 2. 递归遍历左子树
    preorder_traversal(node.right) # 3. 递归遍历右子树

# 对于上面的树，遍历顺序: A -> B -> D -> E -> C -> F
```

**2. 中序遍历 (In-order): 左 → 根 → 右**

“第二种策略，像个谦逊的协调者。”伊莎贝尔接着比喻，“每到一个路口，他会说：‘左边的同事请先汇报’（递归遍历左子树）。等左边全部完成后，他才总结陈词：‘轮到我了’（访问根节点）。最后，他会说：‘现在请右边的同事汇报’（递归遍历右子树）。”

```python
def inorder_traversal(node):
    if node is None:
        return
    inorder_traversal(node.left)   # 1. 递归遍历左子树
    print(node.value)   # 2. 访问根节点
    inorder_traversal(node.right)  # 3. 递归遍历右子树

# 对于上面的树，遍历顺序: D -> B -> E -> A -> F -> C
```

**3. 后序遍历 (Post-order): 左 → 右 → 根**

“第三种策略，则像个沉稳的汇总者。”黛芙继续道，“他总是说：‘你们先讨论，把左右两边的情况都搞清楚了再来找我。’于是，他会等待左子树和右子树都完全探索完毕后，最后才处理自己这个根节点，进行最终的汇总。”

```python
def postorder_traversal(node):
    if node is None:
        return
    postorder_traversal(node.left)   # 1. 递归遍历左子树
    postorder_traversal(node.right)  # 2. 递归遍历右子树
    print(node.value)   # 3. 访问根节点

# 对于上面的树，遍历顺序: D -> E -> B -> F -> C -> A
```

安妮看着这三种如诗篇般整齐的递归结构，仿佛真的能听到那棵椰子树“根-左-右”、“左-根-右”的、富有节奏的脉搏。递归，就像树木生长的内在指令，让复杂的遍历过程，在几行优美的代码中得以实现。

#### **涟漪的扩散：广度优先遍历 (BFS)**

“哇，深度优先遍历好神奇，就像一条路走到黑再回头。”希娅一边说，一边从背包里拿出了一个半透明的水球，“不过，有没有不那么‘执着’的遍历方法呢？比如，我想像水波纹一样，一层一层地往外逛，可不可以？”

她说着，将水球轻轻抛入不远处一个平静的小水洼中。水波以水球落点为中心，一圈一圈地、均匀地向外扩散开去。

“当然可以！”黛芙笑道，“你的这个比喻，正好描述了另一种重要的遍历方式——**广度优先遍历（Breadth-First Search, BFS）**，也叫**层序遍历（Level-order Traversal）**。”

“这种方法不再使用递归，而是需要借助我们一位老朋友的帮助。”黛芙的目光投向安妮。

安妮想起了在卷一《春日学园祭》中学过的知识，试探着回答：“是……**队列（Queue）**吗？先进先出的那种？”

“完全正确！”希娅兴奋地打了个响指，“BFS和队列是绝配！过程就像这样：”

1.  “首先，我们把树根（A）请进一个队列里排队。”
2.  “然后，只要队列里还有人，我们就一直循环：把队头的人请出来（A出队），访问他。”
3.  “最关键的一步：A出队后，立刻把他所有的孩子（B和C），按从左到右的顺序，送进队列的末尾排队！”
4.  “接下来，队头轮到了B，B出队被访问，然后把他的孩子（D和E）送进队尾……”

黛芙在白板上，清晰地展示了队列的变化过程：

```ascii
队列 (Queue)                 访问顺序
------------------------------------------------
1. [ A ]                      
2. [] (A出队) -> 把B,C入队      A
3. [ B, C ]
4. [ C ] (B出队) -> 把D,E入队      A, B
5. [ C, D, E ]
6. [ D, E ] (C出队) -> 把F入队      A, B, C
7. [ D, E, F ]
8. [ E, F ] (D出队)             A, B, C, D
9. [ F ] (E出队)               A, B, C, D, E
10.[ ] (F出队)                 A, B, C, D, E, F

队列为空，遍历结束。
最终层序遍历顺序: A -> B -> C -> D -> E -> F
```

```python
from collections import deque

def levelorder_traversal(root):
    if root is None:
        return
    queue = deque([root])
    while queue:
        node = queue.popleft() # 队头出队
        print(node.value)
        if node.left:
            queue.append(node.left) # 左孩子入队
        if node.right:
            queue.append(node.right) # 右孩子入队
```

安妮仰望着椰林，阳光透过叶隙，在地面投下晃动的光斑。她仿佛看到，那些光斑正以一种奇妙的规律在闪烁。时而像心跳般，从树干到枝干再到叶梢（DFS）；时而又像微风拂过，从内到外，一层层地拂过所有叶片（BFS）。她终于明白，面对再复杂的非线性结构，只要掌握了遍历的“心法”，便能拥有在其中自由穿梭、从容漫步的自信。

--- 

🌸 **树遍历核心要点** 🌸

**1. 算法设计的根本思想**
- **系统性访问：** 树遍历的核心目标是设计一个无遗漏、无重复的系统性规则，来访问一个非线性结构中的所有节点。它是对树进行任何其他操作（如查找、修改、计算）的基础。
- **递归与迭代的对偶性：** 深度优先遍历（DFS）天然地适用于递归实现，其“深入-回溯”的行为模式与函数调用栈的“压栈-出栈”完美对应。而广度优先遍历（BFS）则天然地适用于迭代（循环）和队列实现，其“逐层扩展”的行为模式与队列的“先进先出”特性高度契合。这揭示了算法世界中递归与迭代的对偶关系。
- **结构决定行为：** 树的递归定义（一棵树由根和几棵子树构成）是DFS算法能够如此简洁优雅的根本原因。而树的层次结构，则是BFS能够借助队列逐层扫描的基础。这体现了数据结构本身的设计，深刻地影响着作用于其上的算法。

**2. 核心设计哲学**
- **“深度” vs “广度”的抉择：** DFS和BFS代表了两种最基本的图景搜索策略。DFS倾向于“一条路走到黑”，能快速找到一个解（可能不是最优解），适用于需要探索所有可能性或查找路径的问题。BFS则像“地毯式搜索”，能保证找到距离起点最近的解，适用于最短路径等问题。
- **访问时机的三种范式（对于DFS）：** 前序、中序、后序遍历的核心区别，仅仅在于“访问根节点”这一操作，相对于“处理左右子树”这两个递归调用的时机。这个微小的时机差异，导致了截然不同的遍历序列和应用场景，体现了算法设计中“时序”的重要性。
- **隐式栈 vs 显式队列：** 递归实现的DFS，其背后是程序调用栈在隐式地工作，帮助我们“记住”回溯的路径。而迭代实现的BFS，则是我们主动地使用一个队列（一种显式的数据结构）来“规划”下一步要访问的节点。理解这种隐式与显式的对应关系，是深入理解算法本质的关键。

**3. 算法思维的启发**
- **分而治之：** 树的递归遍历是“分而治之”思想的完美体现。一个“遍历大树”的复杂问题，被分解为“访问根节点”、“遍历左子树”、“遍历右子树”三个更小的、同质的子问题。
- **状态与路径的保存：** 无论是递归调用栈还是BFS的队列，它们的核心功能都是保存“待处理”的状态和路径信息。这启发我们在解决复杂问题时，要思考用什么样的数据结构来有效地管理和追踪问题的状态。
- **不同视角看同一问题：** 对于同一棵树，四种遍历方式给出了四种不同的线性序列。这告诉我们，从不同的视角或按不同的规则去观察同一个复杂事物，会得到完全不同的、但各自都有用的解读。

--- 

🎀 **安妮的小小日记本**

今天真是太奇妙了！我第一次发现，原来仰望一棵树，也能学到算法！

以前总觉得树好复杂，有那么多分岔，肯定很容易迷路。但今天学了“树的遍历”之后，我感觉自己像是拿到了一张秘密地图！

深度优先遍历（DFS）就像是在玩迷宫，一条路走到头再换下一条。它还有三种不同的“性格”：雷厉风行的“前序”（根左右），谦虚稳重的“中序”（左根右），还有总是负责断后的“后序”（左右根）。而这一切，只需要几行简单的递归代码就能实现，递归真是太神奇了，就像树的“心跳”一样！

广度优先遍历（BFS）也很有趣，它像水波纹一样，一层一层地探索，公平地对待每一个距离的节点。而且它还用到了我们的老朋友——队列！看到以前学的知识能在新地方派上用场，真的好有成就感！

现在，我再看这片椰林，它们在我眼里不再是普通的树了，而是一个个等待我去探索的美丽数据结构！

--- 

> **树（Tree）** 是一种由n（n≥0）个有限节点组成一个具有层次关系的集合。它被用来模拟具有层级或分支结构的数据。每个树结构都有一个特殊的**根（Root）**节点，其余节点可分为m（m≥0）个互不相交的有限集合，其中每一个集合本身又是一棵树，并被称为根的**子树（Subtree）**。**树的遍历（Tree Traversal）**是指按照某种特定的规则，系统地访问树中所有节点，且每个节点仅被访问一次的过程，是树结构上最基本的操作。主要分为**深度优先搜索（DFS）**（包括前序、中序、后序遍历）和**广度优先搜索（BFS）**（即层序遍历）。

### 今日关键词

- **树 (Tree):** 模拟层次关系的非线性数据结构。
- **节点 (Node):** 构成树的基本单元。
- **根 (Root):** 树的最顶层节点。
- **子树 (Subtree):** 树中某个节点的所有后代节点构成的结构。
- **叶子节点 (Leaf):** 没有子节点的节点。
- **深度优先遍历 (DFS):** “一头扎到底”的遍历策略，常由递归实现。
- **前序遍历 (Pre-order):** 遍历顺序为：根 → 左子树 → 右子树。
- **中序遍历 (In-order):** 遍历顺序为：左子树 → 根 → 右子树。
- **后序遍历 (Post-order):** 遍历顺序为：左子树 → 右子树 → 根。
- **广度优先遍历 (BFS) / 层序遍历:** “逐层扫描”的遍历策略，常由队列实现。
- **递归 (Recursion):** 函数调用自身的编程技巧，与树的结构天然契合。
- **队列 (Queue):** “先进先出”的数据结构，是实现BFS的核心工具。

### 名词小传

**递归（Recursion）** 的概念远早于计算机的诞生，它在数学和逻辑学中有着悠久的历史。然而，将其作为一种强大的编程工具，并使其广为人知的，当属**约翰·麦卡锡（John McCarthy）**。他在1958年发明了**LISP**语言，这门语言将“列表”作为核心数据结构，并把“递归”作为处理列表的基本方式。LISP的优雅和强大，深刻地展示了递归在处理像树和列表这类“自我相似”结构时无与伦比的表达力，对后世的函数式编程语言乃至整个计算机科学都产生了深远的影响。可以说，麦卡锡让递归从一个数学概念，真正变成了程序员手中一把解决复杂问题的利剑。

### 树与遍历定义

**树 (Tree)** 是一种抽象数据类型（ADT），它由一组通过边连接的节点构成，用以表示层次关系。树的一个关键特性是任意两个节点之间有且仅有一条唯一的路径。**树的遍历 (Tree Traversal)** 是一种算法过程，旨在系统性地访问（处理）树中的每一个节点一次。根据访问节点的顺序，遍历分为两大类：**深度优先搜索 (DFS)**，它尽可能深地探索树的分支，包括前序、中序和后序三种具体方式；以及**广度优先搜索 (BFS)**，它从根开始，逐层地访问节点。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard
> 建议顺序：基础 ➜ 进阶 ➜ 面试 ➜ 考研  
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 5 题）**  
1.  LC 144 Binary Tree Preorder Traversal ⭐ —— **必做**。练习并背诵前序遍历的递归和迭代（使用栈）两种写法。
2.  LC 94 Binary Tree Inorder Traversal ⭐ —— **必做**。练习并背诵中序遍历的递归和迭代写法，这是二叉搜索树的基础。
3.  LC 145 Binary Tree Postorder Traversal ⭐ —— **必做**。练习并背诵后序遍历的递归和迭代写法，迭代写法相对最复杂，需重点理解。
4.  LC 102 Binary Tree Level Order Traversal ⭐⭐ —— **必做**。练习使用队列实现层序遍历，并处理好分层存储结果的逻辑。
5.  LC 104 Maximum Depth of Binary Tree ⭐ —— 递归入门经典。树的最大深度可以分解为 `1 + max(左子树深度, 右子树深度)`，完美体现递归思想。

**进阶巩固（练习 5 题）**  
6.  LC 226 Invert Binary Tree ⭐ —— 递归应用。交换一个节点的左右子树，然后递归地去交换其左右子树即可，代码简洁优美。
7.  LC 101 Symmetric Tree ⭐ —— 递归进阶。判断一棵树是否镜像对称。需要设计一个辅助递归函数 `isMirror(node1, node2)`，比较两棵树是否互为镜像。
8.  LC 111 Minimum Depth of Binary Tree ⭐⭐ —— 易错题。求最小深度，需要注意的是，如果一个节点只有左子树或右子树，不能直接取`min`，因为最小深度是指到叶子节点的距离。用BFS是解此题的更佳选择。
9.  LC 543 Diameter of a Binary Tree ⭐⭐ —— 经典题目。一个节点的直径 = 左子树深度 + 右子树深度。在求深度的后序遍历过程中，顺便更新全局的直径最大值即可。
10. LC 100 Same Tree ⭐ —— 递归基础。判断两棵树是否相同。递归地判断根节点值是否相同，且左子树相同，且右子树相同。
