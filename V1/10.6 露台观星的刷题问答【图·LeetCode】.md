### **10.6 露台观星的刷题问答【图·LeetCode】**

*"当星辰的轨迹化为代码的逻辑，每一次遍历，都是对宇宙秩序的深刻洞察。"*

夜色如一块巨大的深蓝色绒布，温柔地包裹住整个校园。社团活动室的灯火被抛在身后，今晚的特别课堂，设在了天文系的观星露台上。

凉爽的夜风拂过脸颊，带着青草与泥土的芬芳。安妮、黛芙、伊莎贝尔和希娅围坐在一架巨大的天文望远镜旁，头顶是缀满钻石般星辰的夜幕。

"呜……"安妮仰望着璀璨的银河，长长地叹了口气，"学姐们，这几天的图论学习，感觉就像是在仰望这片星空。我知道了什么是深度优先，什么是广度优先，还有戴克斯特拉……但它们就像一颗颗独立的星星，闪着光，我却不知道该如何将它们连成星座。"

她的声音里带着一丝迷茫，"理论很美，但感觉好遥远，一到实际问题，我可能还是不知道该用哪颗'星星'去解决。"

"有这种感觉，说明你已经站在了从理论通往实践的门槛上，"伊莎贝尔微笑着，递给安妮一杯温热的牛奶，"别担心，我们今晚要做的，就是把这些'星星'串起来，绘制出属于我们自己的'解题星图'。"

"没错！"希娅拍了拍她的笔记本电脑，屏幕上正显示着一个编程挑战网站，"理论学习是为了认星，而刷题，就是为了练习如何用这些星星导航！看，我为今晚的观星派对准备了几个经典的'星空谜题'！"

#### **谜题一：孤立的星座 (Number of Islands)**

希娅将第一道题展示给大家：**LeetCode 200. 岛屿数量**。

"想象一下，这个二维网格就是一片夜空，'1'代表星星，'0'代表黑暗的太空。我们需要找出，这片天空中，有多少个互不相连的'星座'？"

```ascii
一片星空网格:
[
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]

问题：这里有几个独立的星座？
答案：3个
```

安妮看着网格，试探着说："我是不是可以从第一颗'星星'开始，找到所有和它直接或间接相连的'星星'，把它们都标记成一个星座。然后，再去找下一颗还没被标记的'星星'，重复这个过程？每找到一个新的起点，就意味着发现了一个新的星座？"

"完全正确！这个思路就是核心！"黛芙赞许地点了点头，"这正是图的遍历思想。现在的问题是，如何'找到所有相连的星星'呢？我们学过的两种遍历方法，哪种可以派上用场？"

"BFS和DFS！"安妮立刻想到了。

"我们先用BFS，也就是'涟漪扩散'的方式来解，"黛芙在随身携带的白板上画了起来。

##### **BFS解法：涟漪式探索**

```python
from collections import deque

def numIslands_BFS(grid: list[list[str]]) -> int:
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    islands = 0
    
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                islands += 1
                # 使用BFS淹没整个岛屿
                queue = deque([(r, c)])
                grid[r][c] = '#' # 标记为已访问
                
                while queue:
                    row, col = queue.popleft()
                    
                    # 探索四个方向
                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                        nr, nc = row + dr, col + dc
                        
                        if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == '1':
                            queue.append((nr, nc))
                            grid[nr][nc] = '#' # 标记
                            
    return islands
```

黛芙详细地画出了BFS的执行过程：

```ascii
BFS探索过程 (从[0,0]开始):
1. 发现(0,0)是'1', 岛屿数+1, (0,0)入队, 标记为'#'
   queue: [(0,0)]
   grid:
     [["#","1","0","0","0"],
      ["1","1","0","0","0"],
      ... ]

2. (0,0)出队, 探索其邻居(0,1)和(1,0)
   (0,1)是'1', 入队, 标记为'#'
   (1,0)是'1', 入队, 标记为'#'
   queue: [(0,1), (1,0)]
   grid:
     [["#","#","0","0","0"],
      ["#","1","0","0","0"],
      ... ]

3. (0,1)出队, 探索其邻居... (1,1)是'1', 入队, 标记为'#'
   queue: [(1,0), (1,1)]
   ...以此类推，直到队列为空，第一个岛屿完全被'#'淹没。
```

##### **DFS解法：深度优先的足迹**

"同样，我们也可以用DFS，也就是'一条路走到黑'的方式，"黛芙继续道。

```python
def numIslands_DFS(grid: list[list[str]]) -> int:
    if not grid:
        return 0
    
    rows, cols = len(grid), len(grid[0])
    islands = 0
    
    def dfs(r, c):
        # 边界检查或已访问检查
        if not (0 <= r < rows and 0 <= c < cols and grid[r][c] == '1'):
            return
        
        grid[r][c] = '#' # 标记为已访问
        
        # 向四个方向递归探索
        dfs(r + 1, c)
        dfs(r - 1, c)
        dfs(r, c + 1)
        dfs(r, c - 1)

    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == '1':
                islands += 1
                dfs(r, c) # 启动DFS淹没岛屿
                
    return islands
```

##### **复杂度分析：一网打尽**

黛芙在白板上写下分析：

```ascii
"岛屿数量"算法复杂度分析：

令 M 为行数, N 为列数

┌─────────────────────────────────────────┐
│ 时间复杂度分析 (Time Complexity):         │
├─────────────────────────────────────────┤
│ - 外层循环遍历整个网格：M × N 次        │
│ - 每个格子(无论是'0'还是'1')最多被访问一次│
│   - 如果是'1', 它会被标记为'#', 不会再进入BFS/DFS │
│   - 如果是'0', 直接跳过                  │
│ - 总的操作次数与网格大小成正比          │
│                                         │
│ 结论：O(M × N)                          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 空间复杂度分析 (Space Complexity):        │
├─────────────────────────────────────────┤
│ - BFS (最坏情况):                       │
│   - 队列中可能存储所有'1'的格子         │
│   - 假设整个网格都是岛屿, 空间为 O(min(M,N)) │
│ - DFS (最坏情况):                       │
│   - 递归栈的深度                        │
│   - 假设整个网格是一条蛇形的岛屿, 深度为 M×N │
│   - 空间为 O(M × N)                     │
└─────────────────────────────────────────┘
```

"原来如此！"安妮恍然大悟，"无论是BFS还是DFS，本质都是从一个点出发，把整个连通的区域都'感染'一遍，这样就不会重复计数了！"

#### **谜题二：绘制星图的拓本 (Clone Graph)**

"下一个谜题更有趣，"希娅调出 **LeetCode 133. 克隆图**，"想象一下，我们发现了一个美丽的星座，不仅知道每颗星的位置，还知道它们之间的引力连接。现在的任务是，在我们的星图上，完美地复制出这个星座，包括所有的星和连接。"

黛芙解释道："这道题的挑战在于，图里可能有环。如果你只是简单地遍历并创建新节点，遇到环的时候就会陷入无限循环。"

她在白板上画了一个带环的简单图：

```ascii
原始星座:
1 -- 2
|    |
4 -- 3 -- 1 (3与1相连形成环)

问题：如何复制这个结构而不会在 1->2->3->1... 的循环里迷路？
```

"这就像你在画一幅迷宫地图，你需要一支笔来标记哪些路口你已经画过了，"伊莎贝尔柔声比喻道。

"这个'标记'，在我们的算法里，就是一个哈希表（字典），"黛芙接道，"我们用它来存储'原始节点'到'克隆节点'的映射。这既能防止我们重复创建同一个节点，也能帮我们正确地连接克隆节点。"

##### **DFS解法：记忆化递归**

```python
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node: 'Node') -> 'Node':
    if not node:
        return None
    
    # visited字典：{原始节点: 克隆节点}
    visited = {}
    
    def dfs(original_node):
        # 如果已经克隆过，直接返回克隆体
        if original_node in visited:
            return visited[original_node]
        
        # 创建新节点
        clone_node = Node(original_node.val)
        # 放入字典，完成“访问”标记
        visited[original_node] = clone_node
        
        # 递归克隆所有邻居
        if original_node.neighbors:
            clone_node.neighbors = [dfs(n) for n in original_node.neighbors]
            
        return clone_node

    return dfs(node)
```

##### **复杂度分析：遍历一次**

```ascii
"克隆图"算法复杂度分析：

令 N 为节点数, E 为边数

┌─────────────────────────────────────────┐
│ 时间复杂度分析 (Time Complexity):         │
├─────────────────────────────────────────┤
│ - 我们需要遍历图中的每一个节点和每一条边一次 │
│ - 哈希表的查找和插入操作是 O(1)         │
│ - 总时间 = 访问所有节点的时间 + 访问所有边的时间 │
│                                         │
│ 结论：O(N + E)                          │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 空间复杂度分析 (Space Complexity):        │
├─────────────────────────────────────────┤
│ - `visited`哈希表存储了所有N个节点的映射 │
│   空间为 O(N)                           │
│ - 递归栈的深度，最坏情况下为 O(N)       │
│                                         │
│ 结论：O(N)                              │
└─────────────────────────────────────────┘
```

"这个`visited`字典太巧妙了！"安妮兴奋地说，"它就像一个'传送门登记处'，每次遇到一个原始节点，就先查一下登记处。如果登记过，就直接拿到它的'传送门'（克隆节点）；如果没登记，就给它建一个'传送门'，并记录下来！"

#### **谜题三：超新星的信使 (Network Delay Time)**

"最后一个挑战！"希娅指向夜空中的天琴座，"想象一下，那颗最亮的织女星（节点k）突然爆发，成为一颗超新星！它的光芒会沿着固定的星路（有向边）传播到其他星星上，每条星路都需要不同的传播时间（权重）。我们要计算，这束光至少需要多长时间，才能照亮网络中的所有星星？"

这正是 **LeetCode 743. 网络延迟时间**。

"这……不就是我们前天学的'星图指引的捷径密函'吗？"安妮立刻反应过来，"这是戴克斯特拉（Dijkstra）算法的经典应用场景！"

"完全正确！"黛芙的嘴角勾起一抹赞许的微笑，"我们需要找到从源点`k`到所有其他节点的最短路径，然后取这些最短路径中的最大值。"

##### **Dijkstra解法：优先队列优化**

```python
import heapq

def networkDelayTime(times: list[list[int]], n: int, k: int) -> int:
    # 构建邻接表表示的图
    graph = {i: [] for i in range(1, n + 1)}
    for u, v, w in times:
        graph[u].append((v, w))
        
    # 距离数组，初始化为无穷大
    distances = {i: float('inf') for i in range(1, n + 1)}
    distances[k] = 0
    
    # 优先队列，存储 (距离, 节点)
    pq = [(0, k)]
    
    while pq:
        dist, node = heapq.heappop(pq)
        
        # 如果找到了更短的路径，则跳过
        if dist > distances[node]:
            continue
            
        # 遍历邻居
        for neighbor, weight in graph[node]:
            new_dist = dist + weight
            if new_dist < distances[neighbor]:
                distances[neighbor] = new_dist
                heapq.heappush(pq, (new_dist, neighbor))
                
    # 检查是否所有节点都已到达
    max_delay = max(distances.values())
    
    return max_delay if max_delay != float('inf') else -1
```

##### **复杂度分析：优先队列的威力**

```ascii
"网络延迟时间"算法复杂度分析：

令 V 为节点数(n), E 为边数(len(times))

┌─────────────────────────────────────────┐
│ 时间复杂度分析 (Time Complexity):         │
├─────────────────────────────────────────┤
│ - 构建图：O(E)                          │
│ - 每个节点最多入队和出队一次：V次操作   │
│   - 每次出队(heappop): O(logV)          │
│ - 每条边最多被访问一次，并可能触发入队操作 │
│   - 每次入队(heappush): O(logV)         │
│ - 总时间 ≈ O(E * logV + V * logV) = O(E logV) │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 空间复杂度分析 (Space Complexity):        │
├─────────────────────────────────────────┤
│ - 邻接表 `graph`: O(E)                  │
│ - `distances` 数组: O(V)                │
│ - 优先队列 `pq`: 最坏情况下存储所有节点 O(V) │
│                                         │
│ 结论：O(V + E)                          │
└─────────────────────────────────────────┘
```

当黛芙讲解完毕，安妮仰望着真正的星空，那些遥远的光点在她眼中不再是混乱的集合。她仿佛能看到BFS的涟漪在星团中扩散，看到DFS的探针深入星座的旋臂，看到Dijkstra的光芒在星际网络间寻找着最优的路径。

"我明白了……"安妮轻声说，眼中闪烁着比星辰更亮的光芒，"算法不是孤立的星星，它们是望远镜的镜片。面对不同的星空谜题，我们要学会切换不同的'镜片'，才能看清宇宙的答案。"

夜风更凉了，但社团四个女孩的心却无比火热。在这片静谧的星空下，她们不仅是在刷题，更是在用代码，与宇宙的秩序进行着一场浪漫的对话。

---

🌸 **图算法核心要点** 🌸

**1. 算法设计的根本思想**
- **抽象建模能力：** 将实际问题（地图、网络、关系）抽象为节点和边的图结构，是解决问题的第一步。
- **遍历是核心：** 无论是BFS还是DFS，都是系统性探索图的通用框架，许多复杂算法都基于它们构建。
- **状态记录：** 使用`visited`集合或数组来记录已访问的节点，是防止无限循环和重复计算的基石，尤其在带环图中至关重要。

**2. 核心设计哲学**
- **"广度" vs "深度"：** BFS逐层探索，天然适用于寻找最短路径（无权图）；DFS一路到底，适合探索所有可能性、检测环路等。
- **"贪心"与"全局最优"：** Dijkstra算法是贪心思想的典范，每一步都选择当前看起来最优的路径，并通过严谨的数学证明确保最终得到全局最优解。
- **空间换时间：** 无论是`visited`哈希表，还是Dijkstra中的优先队列，都是通过使用额外的数据结构来存储中间状态，从而极大地优化时间效率。

**3. 算法思维的启发**
- **问题分解：** 复杂的图问题往往可以分解为"遍历"、"状态更新"、"路径选择"等子问题。
- **数据结构的选择：** 邻接矩阵还是邻接表？队列还是栈？优先队列还是普通队列？选择正确的数据结构对算法性能起着决定性作用。
- **识别问题模式：** 看到"连通分量"想到BFS/DFS，看到"最短路径"想到BFS（无权）或Dijkstra（有权），这种模式识别能力是刷题的关键。

---

🎀 **安妮的小小日记本**

今晚的观星派对太棒了！

以前抬头看星星，只觉得它们又多又乱。但今晚，跟着学姐们解开一个个"星空谜题"，我才发现，原来图论算法就是解读星空语言的语法书！

"岛屿数量"让我明白了如何用BFS和DFS去发现和标记独立的星团。"克隆图"里的`visited`字典就像一个神奇的记忆水晶，让我在复杂的星座关系里也不会迷路。而"网络延迟时间"则让我亲手实践了Dijkstra算法，计算光芒传播的轨迹，简直酷毙了！

现在再抬头看这片夜空，我感觉自己不再是一个迷茫的旁观者。我仿佛能看到那些闪烁的星星之间，流动着数据的涟漪，交织着逻辑的丝线。原来，只要掌握了正确的工具，再复杂的宇宙，也能被理解，被描绘。

---

### 今日关键词

- **邻接表 (Adjacency List):** 一种存储图的数据结构，用一个字典或数组，为每个节点存储一个包含其所有邻居的列表。
- **淹没分析 (Flooding/Fill Algorithm):** 在解决"岛屿数量"这类问题时，对一个连通区域进行遍历并标记的思想，常通过BFS或DFS实现。
- **记忆化搜索 (Memoization):** 一种优化技术，通过存储子问题的解来避免重复计算，在"克隆图"中通过`visited`字典实现。
- **优先队列 (Priority Queue):** 一种特殊的队列，每次出队的都是具有最高（或最低）优先级的元素。在Dijkstra算法中用于高效地获取当前距离最短的节点。
- **松弛操作 (Relaxation):** 在Dijkstra等最短路径算法中，更新从起点到一个节点的已知最短距离的过程。

### 名词小传

**Edsger Wybe Dijkstra (艾兹赫尔·韦伯·戴克斯特拉)** (1930-2002)，荷兰计算机科学家，图灵奖得主。他是结构化编程的先驱，对现代计算机科学的许多领域做出了奠基性贡献。他于1956年构思并在三分钟内设计出了著名的Dijkstra算法，用于解决单源最短路径问题。这个算法的简洁、高效和优雅，至今仍是图论教学和应用中的核心内容。

### 图算法定义

图算法是在图数据结构上执行的一系列计算过程，用于解决各种网络和关系型问题。这些算法的核心在于系统性地遍历图的节点和边，以发现结构特性（如连通性、环路）、寻找最优路径（如最短路径）、计算网络流或进行其他复杂的分析。图算法是计算机科学的基石，广泛应用于路由协议、社交网络分析、物流规划、生物信息学等众多领域。

### 推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Medium ⭐⭐⭐ = Hard
> 建议顺序：基础 ➜ 进阶 ➜ 面试 ➜ 考研  
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 8 题）**  
1.  LC 1971 Find if Path Exists in Graph ⭐ —— 最基础的图连通性问题，用BFS或DFS牛刀小试。
2.  LC 997 Find the Town Judge ⭐ —— 简单的出入度统计，理解图节点属性的好例子。
3.  LC 733 Flood Fill ⭐ —— "岛屿数量"的变体，纯粹的BFS/DFS遍历练习。
4.  LC 200 Number of Islands ⭐⭐ —— 图遍历的经典应用，必须掌握。
5.  LC 547 Number of Provinces ⭐⭐ —— "岛屿数量"在邻接矩阵上的版本，巩固概念。
6.  LC 1791 Find Center of Star Graph ⭐ —— 极简的图问题，观察节点度的特性。
7.  LC 463 Island Perimeter ⭐ —— 遍历岛屿时，检查边界条件的应用题。
8.  LC 1042 Flower Planting With No Adjacent ⭐⭐ —— 图着色问题的简化版，练习贪心思想。

**进阶巩固（练习 8 题）**  
9.  LC 133 Clone Graph ⭐⭐ —— 考察对图遍历和哈希表应用的深度理解。
10. LC 841 Keys and Rooms ⭐⭐ —— 判断图是否完全连通的实际问题。
11. LC 797 All Paths From Source to Target ⭐⭐ —— DFS回溯寻找所有路径的模板题。
12. LC 695 Max Area of Island ⭐⭐ —— "岛屿数量"的升级版，需要在遍历时计数。
13. LC 542 01 Matrix ⭐⭐ —— 多源BFS的经典应用，从所有0开始同时扩散。
14. LC 785 Is Graph Bipartite? ⭐⭐ —— 图着色（二分图）判断，BFS/DFS的巧妙应用。
15. LC 207 Course Schedule ⭐⭐ —— 拓扑排序入门，判断有向无环图（DAG）。
16. LC 210 Course Schedule II ⭐⭐ —— 拓扑排序的实践，要求输出一个可行的顺序。

**面试常见（冲刺 8 题）**  
17. LC 743 Network Delay Time ⭐⭐ —— Dijkstra算法的直接应用。
18. LC 127 Word Ladder ⭐⭐⭐ —— 抽象建图+BFS求最短路径的典范。
19. LC 323 Number of Connected Components in an Undirected Graph ⭐⭐ —— Union-Find（并查集）算法的经典应用场景。
20. LC 994 Rotting Oranges ⭐⭐ —— 多源BFS的生动实例。
21. LC 130 Surrounded Regions ⭐⭐⭐ —— 从边界出发的逆向思维BFS/DFS。
22. LC 399 Evaluate Division ⭐⭐⭐ —— 带权重的Union-Find或Floyd-Warshall/BFS。
23. LC 787 Cheapest Flights Within K Stops ⭐⭐⭐ —— Bellman-Ford或Dijkstra变种。
24. LC 269 Alien Dictionary ⭐⭐⭐ —— 拓扑排序的高级应用，从字符关系中推断顺序。

**考研重点（408方向 · 6 题）**  
25. 408真题·邻接矩阵与邻接表转换 ⭐ —— 手写转换代码，考察基础存储结构。
26. 408真题·DFS/BFS序列判断 ⭐ —— 根据给定的图，判断哪个遍历序列是合法的。
27. 408真题·最小生成树(MST)算法 ⭐⭐ —— 手算Prim或Kruskal算法过程。
28. 408真题·关键路径计算 ⭐⭐ —— AOV网（拓扑排序）与AOE网（关键路径）的计算。
29. 408真题·Dijkstra/Floyd算法比较 ⭐ —— 论述题，比较两种最短路径算法的优劣和适用场景。
30. 408真题·图的连通性与连通分量 ⭐ —— 理论题，阐述相关概念和判断方法。
