### **20.1 前缀星语的词典迷宫【Trie树】**

"每一颗星辰，都是一个字母；每一道星轨，都是一个前缀。在这片由字符构成的宇宙里，所有语言的奥秘，都藏于同一座迷宫的深处。"

卷三的秋日决战，已成为社团荣誉室里一枚闪亮的银牌，和一段珍贵的共同记忆。时光流转，凛冬已至。窗外，初雪的积云正在酝酿，宣告着学期的尾声和毕业季的渐近。这也是“美少女的算法漫话”最终卷的开篇。

为了备战更高阶的区域赛，女孩们的学习，也进入了更专门、更深入的领域。

一个寒冷的夜晚，社团活动室里暖气开得正足。希娅正在自己的笔记本上飞快地打字，屏幕上是她正在使用的搜索引擎，每当她输入一个字母，下方就会立刻弹出一连串的搜索建议。

“说起来，我一直很好奇这个功能是怎么实现的。”希娅停下手，向大家提问，“比如，我输入一个`'alg'`，它就能瞬间给我推荐‘algorithm’、‘algebra’……如果用一个巨大的词典来存储所有可能的搜索词，每次都去遍历整个词典，检查每个词的前缀，那速度肯定跟不上。这里面一定有什么‘魔法’。”

“用哈希表？”安妮尝试着回答，“把所有词的前缀都存进哈希表里？但前缀的数量太多了，也不现实。”

“安妮的思考方向很对，我们需要一种能‘聚合’和‘复用’前缀信息的数据结构。”伊莎贝尔微笑着说，“这种魔法，就藏在一棵特殊的‘树’里。它的名字，叫做‘**Trie树**’，也因为它的特性，被更直观地称为‘**前缀树**’（Prefix Tree）。"

#### **Trie树：一座为字符串而生的迷宫**

“忘记所有复杂的定义，”伊莎贝尔看到安妮脸上的一丝困惑，柔声说道，“我们来想象一下，要如何用一种最节省空间的方式，来存放`'tea'`, `'ted'`, `'ten'`这三个单词？”

“它们都有共同的前缀`'te'`。”安妮立刻说。

“没错！所以，我们完全没必要把`'te'`这部分，重复存储三次。我们可以让它们‘共享’一条路径。”伊莎贝尔在白板上画了起来。

“想象一座迷宫的入口是‘根’。我们先开辟一条小径，挂上路标`'t'`；再从`'t'`的尽头，延伸出一条小径，挂上路标`'e'`。现在，我们来到了一个岔路口。从这里，我们再分别延伸出三条不同的小径，分别挂上`'a'`, `'d'`, `'n'`的路标。我们在`'a'`, `'d'`, `'n'`这三条小径的尽头，都画上一个‘宝箱’的标记，代表‘一个单词在这里结束’。”

```ascii
      (入口) o
              |
              t
              |
              e
             /|\
            a d n
            | | |
           (宝)(宝)(宝)
           (箱)(箱)(箱)
```

“这座由字符路径构成的迷宫，就是一棵Trie树。”黛芙开始进行系统性的讲解，“它的核心思想，就是**用空间换时间，利用字符串的公共前缀来降低查询的复杂度**。”

#### **Trie树的节点：一个带标记的信件格**

“我们来看看Trie树的节点，到底长什么样。你可以把它想象成一个酒店前台后面，那种用来放信件的、带格子的小柜子。”

-   **`children` (孩子节点):** “这个小柜子，有26个格子（如果是小写字母的话），分别标着`'a'`到`'z'`。每个格子里，可以用来存放通往‘下一个字母’的路径信息（即指向另一个Trie节点的指针）。”
-   **`is_end_of_word` (结束标记):** “除了格子，柜子上还有一个小小的‘旗子’或‘邮戳’。这个标记用来告诉我们：‘从入口走到我这里，恰好构成了一个完整的单词’。”

#### **Trie树的三大核心操作**

**1. 插入一个单词 (Insert):**
“这就像是在我们的‘字符迷宫’里，修建一条新的道路。”

-   **步骤：** 从根节点（空柜子）出发，沿着单词的字母，一个一个地往下走。
-   **检查路径：** 在当前节点的“信件格”里，看有没有通往下一个字母的格子。比如，要插入`'apple'`，在根节点，就看`'a'`号格子是不是空的。
-   **创建路径：** 如果是空的，就创建一个新的、空的Trie节点（新柜子），放进这个格子里。
-   **前进：** 无论格子是不是空的，都移动到下一个节点（走进下一个柜子）。
-   **标记终点：** 当单词的所有字母都走完后，在最后一个节点的“结束标记”上，盖一个“邮戳”，表示这里是一个合法单词的结尾。

**2. 查找一个完整的单词 (Search):**
“这就像是拿着一张完整的地图，去验证迷宫里是否存在这样一条精确的寻宝路线。”

-   **步骤：** 同样从根节点出发，沿着单词的字母往下走。
-   **检查路径：** 如果在任何一步，发现对应的“信件格”是空的，那就说明这条路不存在，这个单词肯定不在我们的词典里，立刻返回`False`。
-   **检查终点标记：** 如果顺利地走完了整个单词的路径，我们还必须检查，最后一个节点的“结束标记”是否被盖上了“邮戳”。如果盖了，才说明单词存在；如果没盖，说明它只是另一个更长单词的前缀而已（比如词典里只有`'apple'`，但我们查找`'app'`）。

**3. 查找一个前缀 (StartsWith):**
“这是最能体现Trie树威力的操作，也是实现搜索建议的关键。”

-   **步骤：** 和`search`操作几乎一样，从根节点出发，沿着前缀的字母往下走。
-   **检查路径：** 如果在任何一步，路断了（格子是空的），说明这个前缀不存在。
-   **成功条件：** 只要能顺利地走完整个前缀的路径，无论最后一个节点有没有“邮戳”，都说明词典里“存在”以这个字符串为前缀的单词。立刻返回`True`。

“看，”黛芙总结道，“对于一个长度为`L`的单词，无论我们的词典有多么巨大（百万、千万级），Trie树的插入、查找和前缀查询，其时间复杂度都只和这个单词本身的长度`L`有关，即O(L)！这就是它‘快’的秘密。”

窗外的雪花，终于开始飘落，无声无息。安妮看着白板上那棵由字符构成的、不断延伸的树，感觉自己仿佛掌握了一种新的“语言”。一种能将所有词汇，都容纳于一个统一结构之下，并能瞬间洞悉其前缀奥秘的、属于星辰与字符的语言。

--- 

🌸 **Trie树核心要点** 🌸 

**1. 算法设计的根本思想**
- **空间换时间：** Trie树是一种以消耗更多空间为代价，来换取极高查询效率的数据结构。它的每个节点可能需要存储指向26个子节点的指针，空间开销相对较大。
- **公共前缀复用：** Trie树的核心价值，在于它能最大限度地复用字符串的公共前缀，从而将大量字符串的集合，压缩到一个树形结构中。
- **用路径表示信息：** 在Trie树中，一个节点本身通常不存储字符信息，真正的信息，蕴含在从父节点到子节点的“路径”上（即孩子在父节点`children`数组中的索引）。从根到一个节点的路径，就定义了一个字符串（前缀）。

**2. 核心设计哲学**
- **结构与数据的同构：** Trie树的结构，与它所存储的字符串集合的“前缀关系”，是完全同构的。这种数据结构与其所表达的数据内在逻辑的高度一致性，是其优雅和高效的根源。
- **确定性有限自动机（DFA）：** 从理论上看，一棵Trie树，本质上就是一个“确定性有限自动机”。每个节点是一个“状态”，每个字符是一次“状态转移”。从根节点开始，输入一个字符串，就会在树上走出一条唯一的路径。
- **查询与长度相关：** Trie树最显著的优点是，其查询效率与树中存储了多少个单词无关，只与待查询的字符串的长度有关。

**3. 算法思维的启发**
- **降维打击：** 将“字符串匹配”这个一维的问题，通过Trie树，转化为在多叉树上的“路径查找”问题，是一种“降维打击”的思路。
- **数据结构的定制化：** Trie树是针对“字符串前缀查询”这一特定需求而“特化”设计的数据结构。这启发我们，在面对特定领域的问题时，可以尝试设计专门的数据结构来优化解法。
- **构建“索引”：** Trie树可以被看作是为字符串集合，建立的一种高效“前缀索引”。这与我们之前学过的分块查找、B树等索引思想，有异曲同工之妙。

--- 

🎀 **安妮的小小日记本** 

Trie树，我决定叫它“字典树”，这个名字太形象了！

今天我才明白，原来搜索引擎在我打字的时候，并不是真的去几亿个网页里大海捞针。它可能就是把我输入的字母，放到一棵巨大无比的Trie树里去匹配。我每多打一个字母，就是在树上多走一步，树的那个节点下挂着的所有“子孙”，就都是可能给我的提示！

伊莎贝尔学姐那个“信件格”的比喻也超棒！一个Trie节点，就是一个有26个小格子的柜子，每个格子代表一个字母，里面可能装着通往下一个大柜子的“钥匙”（指针）。而柜子上的“邮戳”，则告诉我们这里是不是一封信的终点。这个模型，简单又清晰！

感觉自己又学会了一项不得了的魔法。以后再用搜索引擎，我看到的就不再是简单的输入框和提示列表，而是一场在巨大的、由全世界的词语构成的“迷宫”里的、激动人心的实时漫游！

--- 

### 今日关键词 

- **Trie / 前缀树 (Prefix Tree):** 一种多分枝的树形数据结构，主要用于存储和检索字符串集合，并能高效地进行前缀查询。
- **公共前缀 (Common Prefix):** 两个或多个字符串开头部分的、相同的子串。
- **节点定义 (Node Definition):** 在Trie树中，一个节点通常包含一个指向子节点的指针数组（或哈希表）和一个表示单词结尾的布尔标记。
- **路径 (Path):** 在Trie树中，从根节点到任意一个节点的路径，所经过的边上的字符连接起来，构成一个字符串（通常是某个或某些单词的前缀）。
- **时间复杂度 O(L):** Trie树的核心操作（插入、查找、前缀查询）的时间复杂度，其中L是待操作字符串的长度。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐ = Medium
> 建议顺序：基础 ➜ 进阶
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（模板与理解）**  
1.  LC 208. Implement Trie (Prefix Tree) ⭐⭐ —— 实现一个Trie树。  
这是最核心的模板题，要求你亲手实现`insert`, `search`, 和 `startsWith`三个核心方法。是掌握Trie树的必做题。

**进阶巩固（模型应用）**  

2.  LC 211. Design Add and Search Words Data Structure ⭐⭐ —— 设计一个支持添加和搜索单词的数据结构。  
与标准Trie不同的是，搜索时可以包含`.`字符，它可以匹配任意一个字母。这要求你在搜索时，对`.`进行特殊的DFS遍历。  

3.  LC 677. Map Sum Pairs ⭐⭐ —— 键值映射。  
要求实现一个`map`，除了插入键值对，还要能计算所有以某个前缀开头的键的值的总和。你需要在Trie的每个节点上，额外存储一个“以此节点为前缀的所有单词的值之和”的属性。

4.  LC 212. Word Search II ⭐⭐⭐ —— 单词搜索II。  
在一个二维网格中，寻找所有出现在给定词典中的单词。这是一个“Trie + DFS + 回溯”的集大成者。先将所有目标单词建成一棵Trie树，然后从网格的每个格子出发，进行DFS，每走一步，就在Trie树上同步移动，并利用Trie的结构进行剪枝。
