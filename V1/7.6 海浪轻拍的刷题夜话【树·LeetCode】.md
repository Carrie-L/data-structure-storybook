### **7.6 海浪轻拍的刷题夜话【树·LeetCode】**

*"当知识的星辰，在实践的夜空中被一一串联，整个宇宙的图景，便在心中豁然开朗。"*

夜色渐深，篝火的烈焰已化为一堆温暖的、明灭不定的余烬。女孩们并排坐在柔软的沙滩上，背后是无垠的夜空和闪烁的繁星，身前是温柔的海浪，不知疲倦地、轻柔地拍打着海岸，奏着永恒的摇篮曲。

“今天我们学了好多关于树的知识，”安妮抱着膝盖，轻声说，“从遍历到BST，再到AVL树的平衡，我感觉脑子里多了很多新工具，但又好像不太确定该怎么使用它们。”

“有这种感觉就对了，”黛芙微笑着说，“理论学习和动手实践，就像是呼吸的两个过程，缺一不可。现在，就让我们在这片星空下，进行一场轻松的‘刷题夜话’，把你今天吸入的‘氧气’，真正转化为你自己的力量吧。”

希娅早已准备好了她的笔记本电脑，屏幕的光芒在夜色中显得格外明亮。

#### **第一题：验证二叉搜索树 (Validate BST)**

“第一题，也是一道面试高频题，非常考验对BST性质的理解 —— **LeetCode 98. 验证二叉搜索树**。”

> **题目描述：** 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
> 
> **有效 BST 定义如下：**
> - 节点的左子树只包含**小于**当前节点的数。
> - 节点的右子树只包含**大于**当前节点的数。
> - 所有左子树和右子树自身也必须是二叉搜索树。

“这个简单！”安妮立刻有了思路，“我只要检查每一个节点，看看它的左孩子的值是不是比它小，右孩子的值是不是比它大。如果整棵树的所有节点都满足这个条件，那它就是一棵BST了！”

黛芙听完，没有直接否定，而是在沙滩上画出了一个反例：

```ascii
      ( 10 )
      /    \
    ( 5 )    ( 15 )
             /   \
           ( 6 )   ( 20 )
```

“安妮，你看这棵树。”黛芙指着节点`15`，“它的左孩子`6`比它小，右孩子`20`比它大，满足你的条件。节点`10`的左孩子`5`比它小，右孩子`15`比它大，也满足。但是，这棵树是BST吗？”

安妮看着节点`6`，它虽然在`15`的左边，但它同时也处在根节点`10`的**右子树**中。“啊！`6`比`10`小，却在`10`的右边！它不应该在这里！所以这不是一棵BST！”她瞬间明白了自己想法的漏洞，“光比较父子节点是不够的，我们必须保证一个节点要比它所有‘左边’的祖先小，比所有‘右边’的祖先大。”

“那该怎么办呢？”

“我们可以……在递归的时候，把这个‘祖先的限制’也带下去！”安妮的思路被打开了，“当我们检查一个节点时，我们不仅检查它自己，还要告诉它，你值的范围必须在一个`（下界, 上界）`之间！比如，检查`15`的左子树时，它的上界就是`15`，下界则是`10`。当检查到`6`时，它虽然小于`15`，但不满足大于`10`的下界要求，所以验证失败！”

```python
def is_valid_bst_recursive(node, lower=float('-inf'), upper=float('inf')) -> bool:
    if not node:
        return True
    
    # 检查当前节点是否在(下界, 上界)的有效范围内
    if not (lower < node.val < upper):
        return False
    
    # 递归检查左右子树，并更新范围
    # 左子树的上界是当前节点的值
    # 右子树的下界是当前节点的值
    return (is_valid_bst_recursive(node.left, lower, node.val) and
            is_valid_bst_recursive(node.right, node.val, upper))
```

“非常棒的递归思路！”黛芙赞许道。这时，伊莎贝尔提出了另一个同样优美的解法：“大家还记得BST的一个奇妙特性吗？当我们对它进行**中序遍历**时，会得到什么？”

“一个严格递增的有序序列！”安妮和希娅同声回答。

“所以，我们也可以换一个角度，”伊莎贝尔微笑着说，“我们对这棵树进行一次中序遍历，然后检查遍历得到的序列，是不是一个严格递增的序列。如果是，那它就是一棵BST；如果不是，那就不是。”

#### **第二题：二叉树的最大深度 (Maximum Depth)**

“好了，我们来个轻松点的。”伊莎贝尔提议，“**LeetCode 104. 二叉树的最大深度**。”

> **题目描述：** 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

这个问题，对于刚刚理解了递归和树高的安妮来说，显得格外亲切。她看着远方的夜空，仿佛树的结构就在星辰间展开。

“我好像知道！”她试着将心中的想法说出来，“一棵树的深度……如果它是一棵空树，那深度就是0。如果它不是空的，那它的深度，应该就是 **1**（算上它自己这一层），再加上它**最深的那个孩子**的深度！”

“也就是说，”她越说越清晰，“一棵树的最大深度 = 1 + max(左子树的最大深度, 右子树的最大深度)！这……这又是一个递归！”

```python
def max_depth(root) -> int:
    """递归计算二叉树的最大深度"""
    if not root:
        return 0
    
    left_depth = max_depth(root.left)
    right_depth = max_depth(root.right)
    
    return 1 + max(left_depth, right_depth)
```

“完美。”黛芙言简意赅地评价道。这个简洁而优美的递归解法，正是树结构递归本质的最佳体现。

#### **第三题：二叉搜索树的最近公共祖先 (LCA)**

“最后，我们来一道能将BST性质运用到极致的题目。”黛芙提出了今晚的压轴题，“**LeetCode 235. 二叉搜索树的最近公共祖先**。”

> **题目描述：** 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先（LCA）。
> 
> **最近公共祖先的定义为：** “对于有根树T的两个节点p、q，最近公共祖先表示为一个节点x，满足x是p、q的祖先且x的深度尽可能大。”

“LCA……”安妮看着这个概念，有点犯难，“要怎么找呢？”

“别急，记住，这是一棵**二叉搜索树**。”黛芙提醒道，“它那‘左小右大’的铁律，能给我们什么提示？”

假设我们要找`p`和`q`的LCA，我们从根节点`root`开始。

安妮顺着这个思路想了下去：“如果`p`和`q`的值，都比`root`的值小，那说明它俩肯定都在`root`的左子树里。那它们的公共祖先，也一定在左子树里！我们就不需要看右子树了！”

“反过来，如果`p`和`q`都比`root`大，那我们就应该去右子树里找！”

“那……如果……如果`root`的值，正好在`p`和`q`的值之间呢？”安妮的思路在这里停顿了一下，随即，一个念头如闪电般划过脑海，“啊！如果`root`正好在它俩中间，或者`root`就是它俩中的一个，那`p`和`q`就从此‘分道扬镳’了，一个在左边，一个在右边！那这个`root`，不就是它们分开前的最后一个‘共同的祖先’吗？也就是最近公共祖先！”

“精彩绝伦的推理！”黛芙忍不住鼓掌，“这正是解决这个问题的完美逻辑。”

```python
def lowest_common_ancestor(root, p, q):
    """在BST中查找最近公共祖先"""
    while root:
        # 如果p和q都比当前节点大，去右子树找
        if p.val > root.val and q.val > root.val:
            root = root.right
        # 如果p和q都比当前节点小，去左子树找
        elif p.val < root.val and q.val < root.val:
            root = root.left
        # 否则，当前节点就是LCA（p和q在此分岔，或其中一个是另一个的祖先）
        else:
            return root
```

海浪声声，夜色温柔。三道题目，如同三把钥匙，为安妮打开了通往树应用世界的大门。她不再仅仅是知道那些概念，而是真正开始学会如何在实际问题中，运用这些概念去分析、去推理、去创造。那是一种比单纯记忆更深刻、也更快乐的体验。

夜深了，笔记本的电量也已耗尽。女孩们收拾好东西，最后望了一眼这片星空下的大海。安妮知道，今晚的这场“刷题夜话”，连同这片海浪的声音，将永远珍藏在她的记忆里，成为她算法之路上，一段闪闪发光的航程。

--- 

🌸 **树（BST）核心解题模式** 🌸

**1. 递归是第一直觉**
   - **核心模式：** 树的问题，天然地适合用递归来解决。将一个对整棵树的操作，分解为对当前节点的操作，以及对左右子树的递归调用。思考递归函数的定义、基本情况（base case，通常是节点为空）和递归逻辑，是解决树问题的通用起点。
   - **典型应用：** `二叉树的最大深度`、`验证二叉搜索树`的递归解法。

**2. 充分利用BST的性质**
   - **核心模式：** 遇到BST问题时，永远不要把它当成一棵普通的树。“左<根<右”的性质是解题的“金手指”。利用这个性质，可以极大地剪枝，将搜索空间减半，实现`O(log n)`的效率。
   - **典型应用：** `二叉搜索树的最近公共祖先`，通过比较`p, q`与当前节点的值，果断地选择向左或向右，避免了全树扫描。

**3. 中序遍历与“有序”的转化**
   - **核心模式：** 许多看似复杂的BST问题，一旦利用“中序遍历结果为有序序列”这一特性，就可以转化为我们更熟悉的、在线性结构（有序数组）上解决的问题。
   - **典型应用：** `验证二叉搜索树`的另一种解法、`BST的最小绝对差`、`寻找第k小元素`等。

**4. 迭代实现：栈与队列的登场**
   - **核心模式：** 任何递归都可以用迭代+显式栈来模拟，这对于理解DFS的本质和避免栈溢出很有帮助。而BFS（层序遍历）则必须使用队列。熟练掌握用栈和队列进行树的迭代遍历，是进阶的必备技能。
   - **典型应用：** 所有遍历问题的迭代解法，以及基于层序遍历的各种问题（如`找树左下角的值`）。

--- 

🎀 **安妮的小小日记本**

今晚的海边夜话，感觉比任何一节课都更让我受益匪浅！

原来，做题真的不是枯燥地背答案，而是一场精彩的侦探游戏。比如“验证BST”那道题，我一开始的“想当然”就被黛芙学姐一个巧妙的“反例”给击破了，这让我明白，思考算法一定要严谨，要考虑到所有边界情况！

而“LCA”那道题，则让我真正感受到了“利用规则”的快感。BST的“左小右大”规则，就像是藏宝图上的箭头，每一步都为我指明了方向，让我可以扔掉大半的错误路线，直奔答案。这种感觉，真的太爽了！

我发现，我现在看一道题，脑子里会开始浮现出学姐们的比喻：这个适合用“递归心跳”吗？还是可以用“队列水波纹”？这个是不是能利用“左轻右重”的法则？……这些知识，好像真的开始融入我的思维里了。真好。

--- 

> 蔚蓝海岸的探险暂告一段落。从哈希的瞬时魔法，到树的递归心跳，再到平衡的优雅回旋，安妮对非线性数据结构的理解，已从一片模糊的剪影，变得逐渐清晰和立体。但算法的世界，如同夏夜的星空，更深邃、更璀璨的星辰，还在远方等待着她们。下一章，她们将挑战那被称为“最优雅的平衡艺术”——红黑树。

### 本章推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard
> 建议顺序：基础 ➜ 进阶 ➜ 面试 ➜ 考研  
> 每题后附“为什么推荐”，帮助读者带着目标刷题。  

**基础入门（必做 10 题）**  
1.  LC 144, 94, 145 Binary Tree Traversal (Pre, In, Post) ⭐ —— **基础中的基础**。必须熟练掌握三种DFS遍历的递归与迭代（栈）写法。
2.  LC 102 Binary Tree Level Order Traversal ⭐⭐ —— **BFS基础**。必须熟练掌握用队列实现层序遍历。
3.  LC 104 Maximum Depth of Binary Tree ⭐ —— **递归入门**。理解树的递归定义的最佳练习。
4.  LC 226 Invert Binary Tree ⭐ —— **递归应用**。感受递归在树结构修改上的简洁之美。
5.  LC 100 Same Tree ⭐ —— **递归比较**。练习同时递归两棵树，进行结构和值的比较。
6.  LC 101 Symmetric Tree ⭐ —— **递归进阶**。需要设计一个辅助递归函数，比较一棵树的左右两边是否镜像对称。
7.  LC 700 Search in a Binary Search Tree ⭐ —— **BST基础**。练习利用BST性质进行高效查找。
8.  LC 98 Validate Binary Search Tree ⭐⭐ —— **BST核心**。深刻理解BST的全局有序性，是面试高频题。
9.  LC 108 Convert Sorted Array to Binary Search Tree ⭐⭐ —— **BST构建**。练习如何从有序数据构建一棵平衡的BST。
10. LC 110 Balanced Binary Tree ⭐⭐ —— **AVL前置**。练习如何递归计算树高并判断平衡性。

**进阶巩固（练习 10 题）**  
11. LC 112 Path Sum ⭐ —— 路径搜索入门。练习递归遍历，同时记录从根到叶子的路径和。
12. LC 543 Diameter of a Binary Tree ⭐⭐ —— 在后序遍历求深度的同时，计算并更新全局的直径变量。
13. LC 235 Lowest Common Ancestor of a BST ⭐⭐ —— **BST性质应用**。体会利用BST规则进行高效剪枝的乐趣。
14. LC 236 Lowest Common Ancestor of a Binary Tree ⭐⭐⭐ —— 与上一题对比，在普通二叉树中找LCA，无法利用BST性质，需要更通用的递归或哈希方法。
15. LC 199 Binary Tree Right Side View ⭐⭐ —— BFS应用。层序遍历时，将每一层的最后一个元素加入结果集即可。
16. LC 653 Two Sum IV - Input is a BST ⭐⭐ —— BST与哈希/双指针的结合。考验多种数据结构的综合运用能力。
17. LC 450 Delete Node in a BST ⭐⭐⭐ —— **BST硬核操作**。完整实现BST的删除，是对逻辑严谨性的极大考验。
18. LC 230 Kth Smallest Element in a BST ⭐⭐ —— BST中序遍历有序性的直接应用。
19. LC 113 Path Sum II ⭐⭐ —— 路径搜索进阶。不仅要判断路径和，还要记录下所有满足条件的路径本身。
20. LC 1382 Balance a Binary Search Tree ⭐⭐ —— BST与平衡的结合。先中序遍历得到有序数组，再重建成平衡树，是“重建”思想的体现。
