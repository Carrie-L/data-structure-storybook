### **9.6 水上乐园的刷题挑战【堆·LeetCode】**

*"算法的乐趣，在于将抽象的工具，化为解决现实谜题的钥匙。每一次成功的应用，都是对理解的最好加冕。"*

在经历了烟火的绚烂后，女孩们决定在水上乐园度过这个下午的最后时光。她们躺在巨大的浮圈上，随着“懒人河”缓慢的水流悠闲地漂浮，两岸是嬉戏的人群和各种水上设施，气氛轻松而愉快。

“从气泡的浮沉，到水滑梯的起落，再到烟火的排序，今天一整天都和‘堆’在一起呢！”安妮枕着手臂，惬意地感叹道，“我感觉自己对堆的理解，比以往任何时候都更深刻。真想看看在真正的编程挑战里，它是不是也这么大显神威。”

“那我们就来一场‘懒人河上的刷题漂流’吧。”黛芙笑着，在她的防水平板上调出了几个经典的题目，“让我们看看，‘堆’这个强大的工具，是如何解决一些看似棘手的问题的。”

#### **第一题：数据流中的第K大元素 (Kth Largest Element in a Stream)**

“第一题，也是最能体现优先队列‘动态’特性的一题 —— **LeetCode 703. 数据流中的第K大元素**。”

> **题目描述：** 设计一个类，可以找出指定一个整数流中，第 `k` 大的元素。
> 注意，你需要找的是排序后的第 `k` 大的元素，而不是第 `k` 个不同的元素。

“想象一下，”伊莎贝尔用一个生动的比喻来描述问题，“我们是这个水上乐园的管理员，`k`是我们VIP休息室的容量，比如`k=3`。我们需要随时知道，当前所有入园的游客里，身高排在第3位的人，身高是多少。”

“新人不断地进来，我们总不能每次都把所有人重新排一遍队吧？”安妮立刻意识到了问题的难点。

“当然不能。”伊莎贝尔笑道，“这时，我们就可以用一个容量只有`k`的‘VIP休息室’来解决问题。这个休息室，就是一个大小为`k`的**小顶堆**。”

“为什么是小顶堆？”安妮有些不解，“我们不是要找第k‘大’的吗？”

“问得好。”伊莎贝尔解释道，“因为这个休息室的‘准入门槛’，恰恰是**休息室里最矮的那个人**的身高，也就是我们小顶堆的堆顶。你想想，会发生什么？”

1.  “当一个新人到来，我们先看休息室满了没有。如果没满（不足k人），就直接请他进去。”
2.  “如果休息室满了，新人就要和里面最矮的那个人（堆顶）比身高。如果新人比‘准入门槛’还矮，那对不起，他没资格进入VIP室。”
3.  “如果新人比‘准入门槛’还高，那太好了！我们就请那位最矮的游客出去（删除堆顶），然后让这位新游客进来（插入新元素）。”

“这样一来，”伊莎贝尔总结道，“我们的‘VIP休息室’（小顶堆）里，永远都保存着当前已入园游客中，身高最高的`k`个人。而我们随时想知道的‘第k大元素’，不就是这个休息室的‘准入门槛’——那个最矮的人，也就是我们**小顶堆的堆顶**吗？”

```python
import heapq

class KthLargest:
    def __init__(self, k: int, nums: list[int]):
        self.k = k
        self.min_heap = []
        for num in nums:
            self.add(num)

    def add(self, val: int) -> int:
        if len(self.min_heap) < self.k:
            heapq.heappush(self.min_heap, val)
        elif val > self.min_heap[0]:
            heapq.heapreplace(self.min_heap, val) # 等价于pop再push，但更高效
        
        return self.min_heap[0]
```

“哇！”安妮恍然大悟，“用一个小顶堆来找第k‘大’的元素，这个思路太巧妙了！”

#### **第二题：合并K个升序链表 (Merge k Sorted Lists)**

“下一题，难度升级。这是一道在面试中极具分量的题目 —— **LeetCode 23. 合并K个升序链表**。”黛芙划动着屏幕。

> **题目描述：** 给你一个链表数组 `lists` ，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，并返回合并后的链表。

“k个队伍……”安妮立刻想到了具体的场景，“就像现在，懒人河里有k条不同颜色的泳道，每条泳道里的人都按身高排好了队。我们要怎么把所有泳道的人，都请出来，汇合成一条新的、从矮到高的大长队呢？”

“最笨的办法，就是把所有人先都拉出来，混在一起，再用`O(N log N)`的复杂度排一次序。”希娅说，“但这样完全浪费了‘每个队伍本身有序’这个重要条件。”

“没错。”黛芙说，“这个问题的核心，在于我们每一步，都需要从`k`个队伍的排头兵中，选出那个当前最矮的人。我们该用什么工具，来高效地完成这个‘k中选最’的操作呢？”

“**小顶堆（优先队列）**！”安妮已经能举一反三了。

“具体怎么做呢？”

“我猜……”安妮试着描述这个过程，“我们建一个小顶堆，然后，先把k条泳道里，排在最前面的那k个人，都请进堆里。堆会自动把最矮的那个人，送到堆顶。”

“然后，我们把堆顶的这个人请出来，让他进入最终的大队伍。他出列后，他原来所在的那条泳道，就空出了一个排头位，我们就让他的下一个同伴，进入堆里，参与新一轮的‘身高竞赛’！”

“我们不断地重复‘从堆顶取人，再补充新人入堆’这个过程，直到所有人都进入大队伍为止！”

“完美！”黛芙赞叹道，“这正是解决这个问题的最优解。我们用一个大小为`k`的优先队列，来时刻维护着`k`个链表的当前最小元素。每次取出和插入，都只需要`O(log k)`的时间。如果总共有`N`个元素，总的时间复杂度就是`O(N log k)`，远比`O(N log N)`要好！”

#### **第三题：前 K 个高频元素 (Top K Frequent Elements)**

“最后，我们来一个结合了我们之前知识的综合题。”希娅提议，“**LeetCode 347. 前 K 个高频元素**。”

> **题目描述：** 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。

“这个问题，可以分成两步。”黛芙提示道。

“第一步我肯定会！”安妮抢答，“我们先要统计每个数字都出现了多少次。这个用**哈希表（HashMap）**最合适了！键是数字，值是它出现的频率。”

“非常棒！”黛芙肯定了她的第一步，“现在，我们得到了一个‘数字-频率’的列表。问题就变成了：如何从这个列表里，找出频率最高的那k个？“

“这……这不就又回到了我们的第一题‘数据流中的第K大元素’了嘛！”安妮惊喜地发现，“我们同样可以维护一个大小为`k`的**小顶堆**！只不过，这次堆里比较的，不再是数字本身，而是它们的**频率**！”

“我们遍历哈希表，逐一将‘数字-频率’对加入小顶堆。如果堆没满，就直接加。如果堆满了，就拿当前元素的频率，和堆顶元素的频率（当前已知的第k高频）比较。如果当前频率更高，就把堆顶的踢出去，把新的加进来！”

“遍历结束后，小顶堆里剩下的k个元素，就是我们最终的答案！”

漂流的浮圈不知不觉已绕了乐园一圈，夕阳的最后一丝光芒也即将消失。女孩们从水中起身，带着一身的清爽和满脑的收获。安妮感觉自己对“堆”的理解，已经不再是那些零散的性质和操作，而是真正变成了一个强大的、可以随时从“工具箱”里拿出来，解决各种“优先级”、“Top K”、“多路合并”问题的趁手兵器。

---

🌸 **堆（优先队列）核心应用模式** 🌸

**1. Top K 问题**
   - **核心模式：** 寻找一个大数据集中的前K大或前K小元素。标准解法是，维护一个大小为`k`的堆。求前K大，就用**小顶堆**；求前K小，就用**大顶堆**。遍历数据集，将元素与堆顶比较，决定是否替换。最终堆中剩下的，就是答案。
   - **典型应用：** `Kth Largest Element`, `Top K Frequent Elements`。

**2. 多路归并 (k-way Merge)**
   - **核心模式：** 当需要从多个有序的数据源中，不断地选出全局的当前最优（最大或最小）元素时，使用一个大小为`k`的堆来管理这`k`个数据源的“排头兵”，是最高效的策略。
   - **典型应用：** `Merge k Sorted Lists`, `Kth Smallest Element in a Sorted Matrix`。

**3. 任务调度与模拟**
   - **核心模式：** 在模拟事件或任务调度时，如果需要频繁地“获取并处理下一个优先级最高的任务”，优先队列是天然的选择。堆能高效地管理一个动态变化的、带优先级的任务池。
   - **典型应用：** `Last Stone Weight`, `Task Scheduler`。

**4. 作为复杂算法的子模块**
   - **核心模式：** 在很多图论算法（如Dijkstra, Prim）和数据压缩算法（如霍夫曼编码）中，优先队列都扮演着至关重要的角色，用于在算法的每一步，都能快速找到当前的最优选择。

---

🎀 **安妮的小小日记本**

水上乐园的时光太快乐了，没想到在“懒人河”上漂流，也能刷题！

今天我才真正明白，为什么我们要学堆。它简直就是为了解决“Top K”问题而生的！那个用大小为k的小顶堆，来找第k大元素的“VIP休息室”比喻，真的太经典了，我一辈子都忘不了！

还有合并k个有序链表，用一个小顶堆当“裁判”，每次都从k个队长里选出最矮的那个，这个想法也酷毙了！

我发现，很多复杂的题目，拆解开来，都是我们学过的基础数据结构的组合应用。比如“前K个高频元素”，就是“哈希表”和“堆”的一次完美合奏！感觉自己的“算法工具箱”越来越丰富了，解决问题的思路也开阔了好多！

---

> 第九章的旅程，在水花与欢笑中画上了句点。从堆的性质，到动态操作，再到建堆魔法、排序礼赞，最终，我们领略了它作为“优先队列”在各种实际问题中的强大威力。堆，以其独特的结构和高效的操作，成为了算法世界中解决“最值”和“优先级”问题的中流砥柱。下一章，我们将踏入一片全新的、更为广阔的领域——图论，去探索由点和线交织成的、更为复杂的算法迷宫。

### 本章推荐练习题目 🧲  
> 难度标注：⭐ = Easy ⭐⭐ = Easy-Medium ⭐⭐⭐ = Medium-Hard

**Top K 问题**
1.  LC 215 Kth Largest Element in an Array ⭐⭐
2.  LC 703 Kth Largest Element in a Stream ⭐⭐
3.  LC 347 Top K Frequent Elements ⭐⭐
4.  LC 692 Top K Frequent Words ⭐⭐
5.  LC 973 K Closest Points to Origin ⭐⭐

**多路归并 & 矩阵问题**
6.  LC 23 Merge k Sorted Lists ⭐⭐⭐
7.  LC 378 Kth Smallest Element in a Sorted Matrix ⭐⭐
8.  LC 373 Find K Pairs with Smallest Sums ⭐⭐

**模拟与调度问题**
9.  LC 1046 Last Stone Weight ⭐
10. LC 621 Task Scheduler ⭐⭐
11. LC 295 Find Median from Data Stream ⭐⭐⭐ (需要同时维护一个大顶堆和一个小顶堆，是优先队列的终极应用之一)

**排序思想应用**
12. LC 912 Sort an Array (用堆排序实现) ⭐⭐
