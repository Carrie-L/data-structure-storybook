### **21.7 智慧殿堂的刷题试炼【技巧·刷题精选】**

*"步入这座由位集、树状数组、线段树与跳表共同构建的智慧殿堂，每一次的解题，都是对结构与效率奥义的再次朝圣。"*

在系统地学习了Bitset、树状数组、线段树、ST表、跳表和LRU缓存等一系列高级数据结构与技巧后，女孩们感觉自己的“算法武器库”，经历了一次史诗级的扩充。

这些“神兵利器”，每一个都精巧、强大，但也都有着自己独特的“脾气”和专属的“战场”。为了能真正地驾驭它们，一场高质量的实战试炼，必不可少。

冬日漫长的夜晚，活动室的灯火如同智慧的灯塔，黛芙为这场“智慧殿堂的刷题试炼”，准备了最后的、也是最富挑战性的几道谜题。

#### **第一重门：位运算的交响 (Single Number II)**

“我们先从最微观的‘位’开始。”黛芙展示了第一题：**LC 137. 只出现一次的数字 II**。

“在一个数组中，除了一个数字出现一次外，其他所有数字都恰好出现了三次。要求我们找出那个只出现一次的数字。并且，算法应该是线性时间复杂度，且不使用额外空间。”

“不能用哈希表计数，因为要求O(1)空间。”希娅首先排除了常规方法。
“如果其他数字都出现两次，我们可以用‘异或’，因为`a^a=0`。”安妮想起了之前的练习，“但出现三次，异或就不行了。”

“这正是问题的关键，”黛芙引导道，“我们必须深入到‘比特位’的层面去思考。想象一下，把所有数字，都看作是32位的二进制数。我们来考察它们的‘每一位’。”

**解题思路：**
1.  建立一个大小为32的数组`counts`，`counts[i]`用来记录所有数字在第`i`个二进制位上，出现`1`的总次数。
2.  遍历输入数组中的每一个数`num`。
3.  对于`num`，再从第0位到第31位，遍历它的每一个比特位。如果某一位是`1`，就给`counts`数组中对应的计数器加一。
4.  遍历完所有数字后，我们再次审视`counts`数组。对于`counts[i]`，如果那个“唯一的数字”在第`i`位上是0，那么所有其他数字在第`i`位上贡献的`1`的个数，必然是3的倍数。反之，如果那个“唯一的数字”在第`i`位上是1，那么`1`的总个数，必然是`3k+1`的形式。
5.  所以，我们只需要检查`counts[i]`对3取模的结果。如果`counts[i] % 3 != 0`，那就说明，我们寻找的那个数字，在第`i`位上，一定是`1`。
6.  根据这个规律，我们就可以一位一位地，把那个唯一的数字，“还原”出来。

“这个解法，没有使用任何高级数据结构，只用到了最底层的位运算思想。”黛芙总结道，“它告诉我们，当常规方法受限时，回归到数据的二进制表示，往往能发现意想不到的、精妙的解法。”

#### **第二重门：树状数组的逆序回响 (Count of Smaller Numbers After Self)**

“下一题，是我们之前提到过多次的经典难题。”伊莎贝尔展示了题目：**LC 315. 计算右侧小于当前元素的个数**。

“要求我们对一个数组`nums`，计算并返回一个新数组`counts`，其中`counts[i]`是`nums[i]`右侧，比`nums[i]`小的元素的数量。”

“暴力解法是O(N²)，会超时。”安妮已经有了经验。
“我们之前提过，可以用归并排序，在`merge`的过程中来计算。”希娅补充道。

“今天，我们用树状数组来解决它，这是一种更在线、更灵活的思路。”黛芙说。

**解题思路：**
1.  **问题的转化：** 从右到左遍历数组`nums`。当我们处理`nums[i]`时，我们需要查询的是“在它右边，已经出现过的数中，有多少个比它小”。
2.  **数据范围的问题：** `nums[i]`的值可能很大，也可能是负数，我们无法直接把它当作树状数组的下标。因此，需要进行“**离散化**”。即，将数组中所有出现过的数，映射到一个从1（或0）开始的、连续的、更小的整数区间。
3.  **算法流程：**
    -   对`nums`中所有独特的数进行排序，得到一个“值->排名”的映射（离散化）。
    -   初始化一个空的树状数组，其大小为独特数的个数。
    -   **从后往前**遍历原数组`nums`：
        -   对于当前的数`nums[i]`，获取其离散化后的排名`rank`。
        -   在树状数组中，**查询**`query(rank - 1)`。这个结果，就代表了“到目前为止（即在`i`右侧），已经出现过的、排名比`nums[i]`小的数的个数”。这就是`counts[i]`的答案。
        -   将`nums[i]`加入到我们的“历史记录”中。即，在树状数组的`rank`位置，执行`add(rank, 1)`操作。

“这个解法，将一个看似是‘查询右侧’的问题，巧妙地转化为了‘查询历史’的问题。”黛芙总结道，“而树状数组，正是维护这种‘可更新的、可查询前缀和的历史记录’的最强工具之一。”

#### **第三重门：线段树的区间交响 (My Calendar I)**

“最后一题，我们来看一个更贴近现实应用场景的问题。”希娅点开了 **LC 729. 我的日程安排表 I**。

“要求我们实现一个`MyCalendar`类，它有一个`book(start, end)`方法。每次调用这个方法，预订一个新的日程`[start, end)`。如果这个新日程与已有的任何日程，都没有发生‘双重预订’（即时间重叠），就接受它并返回`true`；否则，就拒绝它并返回`false`。”

“最暴力的方法，是维护一个列表，每次预订，都和列表里所有的已有日程，进行一次重叠检查。”安妮说，“但这样，`book`操作的复杂度是O(N)。”

“这个问题，可以看作是在一条巨大的‘时间轴’上，不断地标记‘已占用’的区间。”伊莎贝尔提示道，“我们需要一个能高效地‘查询某个区间是否已被占用’，并能‘更新某个区间为已占用’的数据结构。”

“是线段树！”安妮和希娅异口同声。

**解题思路（动态开点线段树）：**
1.  **建模：** 将整个时间轴（如`[0, 10^9]`）看作线段树要维护的区间。
2.  **懒惰标记:** 在线段树的每个节点上，维护一个标记，表示“该节点代表的整个时间段，是否已被完全预订”。
3.  **`book(start, end)`操作，本质上是一个`query`和`update`的结合：**
    -   **查询:** 先在线段树上，查询`[start, end-1]`这个区间，是否已经存在被预订的标记。如果查询过程中，发现任何一个子区间的标记为“已预订”，说明发生了冲突，立刻返回`false`。
    -   **更新:** 如果查询通过，说明没有冲突。我们再进行一次遍历，将`[start, end-1]`这个区间，在线段树上对应的节点，都打上“已预订”的标记。这里同样可以用到“懒惰标记”来优化。
4.  **动态开点:** 由于时间轴的范围可能非常大（10⁹），我们不能一开始就建立一棵完整的线段树。而应该在每次`book`操作，需要访问到某个节点时，才去创建它。这种“按需创建节点”的线段树，就叫做“动态开点线段树”。

冬夜的集训，在这三道充满智慧的题目中，走向了尾声。从最微观的位运算，到中观的树状数组，再到宏观的线段树，女孩们感觉自己像是打通了任督二脉，对数据结构和算法的理解，从一个个孤立的点，真正连成了一张融会贯通、错落有致的网。

---

🌸 **高级技巧应用核心要点** 🌸

**1. 算法设计的根本思想**
- **位运算是基石：** 很多看似复杂的计数、状态问题，其最优解都隐藏在二进制表示中。养成从“位”的角度去分析数字的习惯，是通往更底层、更高效解法的钥匙。
- **离散化是桥梁：** 当问题的数值范围过大，无法直接用作数组下标时，“离散化”是一种至关重要的预处理技巧。它在不改变数据相对大小关系的前提下，将数据“压缩”到一个紧凑的索引区间，为树状数组、线段树等数据结构的使用，搭建了桥梁。
- **动态开点是扩展：** 面对巨大的坐标范围，动态开点线段树（或字典树）提供了一种“以空间换实现”的思路。它用更复杂的指针操作，换取了对巨大、稀疏区间的有效管理能力。

**2. 核心设计哲学**
- **问题转化能力：** 高阶的题目，考验的往往不是对某个模板的记忆，而是“转化”的能力。能否将“计算右侧小数”，转化为“从右到左，查询历史”？能否将“日程预订”，转化为“区间染色查询”？这种转化的能力，是水平分水岭。
- **选择合适的工具：** 面对一个区间问题，是该用前缀和、差分、树状数组，还是线段树？这需要对每种工具的“能力边界”（如是否支持修改、是否支持最值、是否支持区间更新）有极其清晰的认识。
- **代码实现能力：** 高级数据结构，通常伴随着较高的代码实现复杂度。在竞赛中，拥有自己的一套经过千锤百炼的、正确、简洁的模板，是至关重要的。

**3. 算法思维的启发**
- **“在线”与“离线”的再思考：** 很多问题，如果是在线处理，可能需要复杂的数据结构。但如果允许“离线”（比如，把所有查询都读完再处理），有时可以用更简单的排序+扫描等方法解决。思考问题是否必须“在线”，是重要的解题视角。
- **“懒惰”的智慧：** （回顾）线段树的懒惰标记，是一种“将多次修改，合并为一次操作”的智慧。它告诉我们，在不影响最终结果的前提下，适当地“推迟”计算，可能会带来巨大的性能提升。
- **组合的力量：** “离散化 + 树状数组”、“Trie + DFS”、“哈希 + DP”…… 现代算法竞赛的难题，越来越多地考察对不同领域知识的综合运用和巧妙组合。

---

🎀 **安妮的小小日记本**

今晚的刷题，感觉像是在攀登一座算法的“琉璃之塔”。塔的每一层，都供奉着一种闪闪发光的数据结构。

第一层的“位运算”，像无数精密运转的齿轮，于无声处，完成了对数字的解构与重组。

第二层的“树状数组”，像一棵充满智慧的古树，它的每一圈年轮，都用`lowbit`的魔法，记录着一段历史的荣光。

第三层的“线段树”，则像一位全知全能的区间守护者，无论是单点修改，还是区间查询，甚至是懒惰的区间修改，它都能在`logN`的时光回响中，给出精准的答案。

攀登的过程虽然艰难，但每学会一种新的“魔法”，都让我感觉离天空更近了一步。我发现，我的“算法工具箱”变得越来越充实，面对问题时，我的选择也越来越多，思路也越来越开阔。这种不断变强的感觉，真的……太棒了！

---

### 今日关键词

- **位运算 (Bitwise Operation):** （回顾）直接对整数的二进制位进行操作。
- **离散化 (Discretization):** 一种数据预处理技术，将一个大范围、稀疏的数据，映射到一个小范围、紧凑的索引上。
- **动态开点 (Dynamic Node Allocation):** 在使用线段树、Trie树等指针实现的数据结构时，不预先创建所有节点，而是在需要访问时，才动态地创建节点。
- **单调队列 (Monotonic Queue):** （回顾）一种用于解决滑动窗口最值问题的、内部元素保持单调性的双端队列。

### 推荐练习题目 🧲  
> 难度标注：⭐⭐⭐ = Hard ⭐⭐⭐⭐ = Very Hard
> 建议顺序：基础 ➜ 进阶
> （本章的练习题已在21.1至21.6节中详细列出，此处不再重复。请参考之前的推荐列表，深入练习这些高级数据结构与技巧。）
