## 5.1 音符拼接的字符乐章【串·存储模型】

_"当你听见字符在内存里跳舞，世界也会为此调好音。"_

午后的音乐教室里，阳光透过百叶窗洒在木地板上，形成一条条如五线谱般的光带。安妮抱着粉色尤克里里小跑进来，手中的乐谱纸片哗啦啦散落，像彩色音符卡片一样飘舞在空中。

黛芙恰好经过，弯腰拾起一张印着音符"♩"的卡片，两人的指尖短暂相触。

"又是你的'台风'造成的音符雨吗？"黛芙轻笑着说。

"嘿嘿，今天想练习《樱之记忆》，"安妮有些不好意思地收拾散落的乐谱，"我已经把歌词输入电脑了，准备配合投影练习。"

她跑到彩色LED投影设备前，按下播放键。屏幕上突然显示出一串奇怪的符号："Ã¦ÂÂ¯Â¨…"

"咦？这是什么？"安妮困惑地敲了敲键盘，"明明复制的是《樱之记忆》的歌词啊！怎么变成了这些奇怪的方块？"

伊莎贝尔听到声音走了过来，弯腰检查设备："这是编码不统一造成的，UTF-8和GBK打架了。"

"编码？"安妮眨着眼睛，"那是什么？"

黛芙示意大家围到白板前："看来是时候学习字符串的存储模型了。这个'乱码'问题，其实揭示了一个很重要的计算机基础概念。"

"我们来做个实验，"黛芙拿出五线谱练习本放在桌上，"把这个当作计算机的内存。"

她开始摆放道具：五线谱练习本代表连续内存，彩色音符贴纸代表字符，白色胶带标记代表结束符。

"在计算机里，所有信息都必须用数字表示，"黛芙在白板上写下"字符编码"，"那我们怎么用数字来表示文字呢？"

希娅举手："用对照表？"

"完全正确！这个对照表就叫做字符编码，"黛芙画出一个简单的对照表：

```
字符编码对照表（简化版）
字符    编码值
A       65
B       66  
樱      27185
花      33457
```

"最早期的ASCII编码只能表示128个字符，主要是英文，"黛芙解释，"后来为了支持中文，出现了GBK、UTF-8等编码。"

"所以我的乱码是因为用错了编码表？"安妮恍然大悟。

"对！就像用错了乐谱，"伊莎贝尔温柔地比喻，"UTF-8是目前最通用的编码，它很巧妙——英文字符占1个字节，中文字符占3个字节。"

"什么是字节？"安妮好奇地问。

"一个字节等于8个二进制位，可以表示0到255的数值，"黛芙解释，"让我们看看实际效果。"

黛芙走到电脑前演示：

```python
# 让我们看看字符编码的实际效果
text = "A樱"

# 查看字符串长度（字符数）
print(f"字符数: {len(text)}")  # len()函数返回字符串中字符的个数

# 编码为字节序列
utf8_bytes = text.encode('utf-8')  # encode()方法将字符串按指定编码转换为字节
print(f"字节数: {len(utf8_bytes)}")  # 显示转换后的字节总数
print(f"字节内容: {utf8_bytes}")     # 显示实际的字节数据
```

屏幕显示：
```
字符数: 2
字节数: 4
字节内容: b'A\xe6\xa8\xb1'
```

"看！"希娅兴奋地指着屏幕，"总共2个字符却占了4个字节！说明字母A用了1个字节，'樱'用了3个字节！"

"但是为什么'樱'要用3个字节呢？"安妮追问道。

"这就涉及到UTF-8编码的精妙设计了，"黛芙在白板上画出编码规则：

```
UTF-8编码规则详解:
字符范围               字节数    编码格式                原因
U+0000 - U+007F       1字节     0xxxxxxx               兼容ASCII
U+0080 - U+07FF       2字节     110xxxxx 10xxxxxx      扩展拉丁字符
U+0800 - U+FFFF       3字节     1110xxxx 10xxxxxx 10xxxxxx  中文等
U+10000 - U+10FFFF    4字节     11110xxx 10xxxxxx 10xxxxxx 10xxxxxx  表情符号等
```

"以第一个字符范围为例，在计算机的早期，ASCII只使用7个二进制位（bit）就可以表示所有字符。2^7=128，所以ASCII码表里总共只有128个字符（编号从0到127），包括了大小写英文字母、数字、标点符号和一些控制符。"

"虽然ASCII只需要7位，但计算机存储数据的基本单位是字节（Byte），一个字节有8位。所以，在存储ASCII字符时，这7位被放在一个8位字节的低7位，而最高位通常被置为0（0xxxxxxx）。"

"为什么要这样设计呢？"安妮好奇地问。

"这是为了解决一个重要问题——向后兼容，"伊莎贝尔温柔地解释，"你看，0到127（十进制）对应0x00到0x7F（十六进制），正好是ASCII的范围。"

"等等，"安妮举手，"十六进制是什么？0x7F是多少？还有，0x是什么意思？"

黛芙耐心解释："让我从头解释：首先，`0x`是十六进制的前缀标记，告诉计算机后面的数字是十六进制格式，而不是十进制。"

她在白板上写下对照表：

```
十六进制符号对照表：
十进制:   0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15
十六进制: 0  1  2  3  4  5  6  7  8  9   A  B  C  D  E  F
```

黛芙道，"十六进制是逢16进1的计数系统，当数字超过9时，就用字母A-F来表示10-15。"

"现在我们计算0x7F：

```python
# 十六进制转十进制的计算
hex_7F = 0x7F  # 0x表示十六进制，7F是具体的十六进制数值
print(f"0x7F = {hex_7F}")  # Python会自动转换为十进制显示

# 手工计算过程：7F = 7×16¹ + F×16⁰ = 7×16 + 15×1 = 112 + 15 = 127
print(f"手工计算: 7×16 + 15 = {7*16 + 15}")
```

运行结果：
```
0x7F = 127
手工计算: 7×16 + 15 = 127
```

"随着计算机走向世界，只包含128个字符的ASCII码完全不够用了。为了容纳中文、日文、阿拉伯文等所有语言的字符，Unicode标准诞生了。它为世界上**每一个字符都分配了一个唯一的编号（码点，Code Point）**。"

"如果一个字符的Unicode编号在0到127之间（即老ASCII字符），那么就用一个字节来表示它。并且，这个字节的最高位永远是0，剩下的7位和原来的ASCII码一样。"伊莎贝尔温柔地解释道。

"例如A的Unicode编号为`U+0041`，`U+` 是一个标准的官方前缀，用来明确标识其后面的一串数字是Unicode码点，也就是十六进制码点为`0041`。

它的十进制为`4*16^1 + 1*16^0` = 65，UTF-8编码是 `0100 0001`，与旧ASCII系统中的字节表示 `0100 0001` 完全一样。"

"如果一个字符的Unicode编号`大于127`（例如汉字‘你’），那么就用2个、3个或4个字节来表示。为了区分，这些字节的最高位必须是`1`。"

"那2字节的`110xxxxx` `10xxxxxx`是怎么回事？"安妮继续问。

```
110xxxxx (起始字节 - Leading Byte) 
    - xxxxx: 真正有用的部分。这 5个比特位是用来存放字符Unicode编号数据的。

10xxxxxx (延续字节 - Continuation Byte)
    - xxxxxx: 真正有用的部分。这 6个比特位也是用来存放字符Unicode编号数据的。

👾 x位置一共有 5+6=11 个比特位可以用来编码
```

黛芙详细解释："`110` 是信号旗。当一个程序读到一个字节，发现它的前三位是 110 时，它立刻就知道，这是一个**多字节字符**的开始，110代表2字节，1110代表3字节。"

"`10` 也是一个信号旗。它表示：'我是多字节字符中的一个**延续部分**，不是一个独立的字符。' 所有多字节字符的第二个、第三个、第四个字节都必须以 `10` 开头。这可以防止程序在读取数据流中间时发生混乱。"

"以版权符号©为例, 它的Unicode编号是 `U+00A9`。"

```
A9 (十六进制) = 10 * 16^1 + 9 * 16^0 = 160 + 9 = 169 (十进制)

转换为二进制 (除以2，取余): 
    10101001
    因为模板里有11位x，为了填满11位，在前面补0:
    00010101001

填入模板：
    把这11位二进制数 00010 101001 从右到左依次填入 110xxxxx 10xxxxxx 模板的 x 中。

填充结果：
    第一个字节: 110 00010
    第二个字节: 10 101001

转换成十六进制：
    11000010 -> C2
    10101001 -> A9
```

黛芙总结道，"所以，© 字符在UTF-8编码的文本文件中，实际存储为两个字节：`0xC2` `0xA9`。"

"等等，二进制转换成十六进制是怎么计算的？"安妮蚊香眼。

黛芙无奈解释道："二进制和十六进制之间有一个非常美妙的关系：2^4=16。这意味着，任何一个4位的二进制数，都正好对应一个1位的十六进制数。利用这个关系，我们可以快速地进行转换。下面是速查表：

| 二进制 (Binary) | 十进制 (Decimal) | 十六进制 (Hex) |
|------------------|------------------|----------------|
| 0000            | 0                | 0              |
| 0001            | 1                | 1              |
| 0010            | 2                | 2              |
| 0011            | 3                | 3              |
| 0100            | 4                | 4              |
| 0101            | 5                | 5              |
| 0110            | 6                | 6              |
| 0111            | 7                | 7              |
| 1000            | 8                | 8              |
| 1001            | 9                | 9              |
| 1010            | 10               | A              |
| 1011            | 11               | B              |
| 1100            | 12               | C              |
| 1101            | 13               | D              |
| 1110            | 14               | E              |
| 1111            | 15               | F              |

"11000010 从右到左可分为 1100 0010 两组，由上可知，1100 -> C，0010 -> 2，拼接起来就是：11000010 -> C2."
"10101001 从右到左可分为 1010 1001 两组，由上可知，1010 -> A，1001 -> 9，拼接起来就是：10101001 -> A9."
"如果最左边的一组不足4位，就在前面补0凑齐4位。现在你应该知道怎么计算UTF-8编码的字符编码范围了吧？"

"唔，让我试试看。2字节的字符编码范围是 U+0080 - U+07FF ......"安妮在白板上写出计算过程。

```
十六进制                                                十进制
80                  8*16^1 + 0*16^0 =                   128
07FF  0*16^3 + 7*16^2 + F*16^1 + F*16^0 = 1792+240+15=  2047
0800            8*16^2 =                                2048
FFFF  15*16^3 + 15*16^2 + 15*16^1 + 15*16^0 = 61440+3840+240+15 = 65535
```

"不错，你已经完全掌握了进制的计算。"黛芙满意点头，"现在让我们运行代码看看'樱'字在哪个范围，"黛芙继续演示：

```python
# 查看'樱'字的Unicode编号
char = "樱"
unicode_point = ord(char)  # ord()函数返回字符的Unicode码点（十进制数值）
print(f"'樱'的Unicode编号: U+{unicode_point:04X} (十进制: {unicode_point})") 

# 判断在哪个范围
if unicode_point <= 0x007F: # 0x007F=127，范围：0~127
    print("在1字节范围")
elif unicode_point <= 0x07FF: # 0x07FF=2047, 范围：128~2047
    print("在2字节范围")
elif unicode_point <= 0xFFFF: # 0xFFFF=65535, 范围：2048~65535
    print("在3字节范围")
else:
    print("在4字节范围")
```

屏幕显示：
```
'樱'的Unicode编号: U+6A31 (十进制: 27185)
在3字节范围
```

> 💡 python语法解释 {:04X}
> "0"是填充字符，"4"：输出结果的最小总宽度,当格式化后的字符串长度>不足4位，就在前面补"0"，
> "X": 输出类型，大写X：大写形式的十六进制字符串，小写x：小写形式的十六进制字符串
> :04X 完整意思：“将一个数字格式化为至少4位宽的大写十六进制字符串，如果不足4位，则在左边用 0 补齐。”

"太棒了！现在我们看看'樱'字是怎么实际编码的，"黛芙演示编码过程，"在上面的过程里，我们知道了'樱'在3个字节范围，所以'樱'的编码范格式是'1110xxxx 10xxxxxx 10xxxxxx'。"

"为了填充里面的'x'，我们需要怎么做呢？"黛芙提问。

"获取'樱'的二进制字符串，从右到左填充到x里！"安妮举手回答。

"没错。"黛芙编写代码获取'樱'的二进制字符串。

```python
char = "樱"
unicode_point = ord(char)  # 获取Unicode码点，十进制值
print(f"'樱'的十进制码点: {unicode_point}")
hex_point = hex(unicode_point)
print(f"'樱'的十六进制码点: {hex_point}")
binary = bin(unicode_point)[2:]  # 将数字转为二进制字符串'0b110101000110001'，[2:]切片去掉开头的'0b'前缀
print(f"'樱'的二进制码点: {binary}")
print(f"二进制位数: {len(binary)}")
```

运行结果：
```
'樱'的十进制码点: 27185
'樱'的十六进制码点: 0x6a31
'樱'的二进制码点: 110101000110001
二进制位数: 15
```

"3字节的编码格式里有16个x，而输出的'樱'二进制位数只有15位，所以我们要在最左边补'0'，得到`0110101000110001`。"

"现在就可以把`0110101000110001`填充到`1110xxxx 10xxxxxx 10xxxxxx`里面啦。"伊莎贝尔道。

```
3字节编码格式：    1110xxxx 10xxxxxx 10xxxxxx
'樱'的二进制码点： 0110101000110001
从右到左填充x：    11100110 10101000 10110001
二进制转十六进制：     E6       A8       B1     （查看速查表）
```

"上面就是'樱'字的UTF-8编码过程。我们用代码来测试一下："

```python
# 演示'樱'字的UTF-8编码过程
utf8_bytes = char.encode('utf-8')  # encode()方法将字符串转换为指定编码的字节序列
print(f"UTF-8编码结果: {utf8_bytes}")

# 查看每个字节的十六进制值
hex_values = [hex(b) for b in utf8_bytes]  # hex()函数将数字转为十六进制字符串
print(f"各字节十六进制: {hex_values}")

# 验证解码
decoded = utf8_bytes.decode('utf-8')  # decode()方法将字节序列按指定编码转回字符串
print(f"解码回来: {decoded}")
```

运行结果：
```
UTF-8编码结果: b'\xe6\xa8\xb1'
各字节十六进制: ['0xe6', '0xa8', '0xb1']
解码回来: 樱
```

"嗯...`b'\xe6\xa8\xb1'`里面的`b`和`\x`是什么意思呢？"安妮不好意思地挠挠脸。

"`b`是Python中定义一个字节串（bytes）的语法，`b'...'` 创建的是一个字节序列，它不是文本，而是原始的二进制数据，用来给计算机看的。而`\x`是十六进制转义符，`\`是转义符，`x`你可以简单记忆为与`hex`同音，表示十六进制数。例如：`\xe6`表示一个字节，其值为十六进制的`E6`。"

"现在我明白啦！"安妮兴奋地睁大了眼，"黛芙你懂得好多呀。"

"多看书你也可以。"

"啊哈哈。"安妮不好意思地挠头。

希娅说道，"这就像是给每个字符分配专属的房子呀！英文字符住单间（1字节），中文字符住套房（3字节），表情符号住别墅（4字节）！"

"表情符号真的要4字节吗？"安妮好奇地问。

"让我们试试看，"伊莎贝尔提议：

```python
# 测试表情符号的字节占用
emoji = "🌸"
emoji_bytes = emoji.encode('utf-8')  # 将表情符号编码为UTF-8字节序列
print(f"'{emoji}' 占用字节数: {len(emoji_bytes)}")
print(f"字节内容: {emoji_bytes}")
print(f"十六进制: {[hex(b) for b in emoji_bytes]}")
```

运行结果：
```
'🌸' 占用字节数: 4
字节内容: b'\xf0\x9f\x8c\xb8'
十六进制: ['0xf0', '0x9f', '0x8c', '0xb8']
```

"哇！真的是4字节的豪华别墅！"安妮拍手笑道。

"现在我们用音符贴纸来演示内存布局，"黛芙将"A"贴纸贴入五线谱的第一格，然后把代表"樱"的3个小贴纸连续贴入后面3格。

```
内存布局演示:
[A][樱][樱][樱][\0]
1字节 ←3字节→ 结束符
```

"这个白色胶带是什么？"安妮指着最后的`[\0]`标记。

"这是`\0`结束符，"黛芙解释，"C语言风格的字符串用它来标记结束位置。"

伊莎贝尔补充："现代编程语言像Python，会在字符串对象中直接记录长度信息，这样查询长度就是O(1)时间复杂度。"

黛芙在白板上画出对比：

```
C风格: [H][e][l][l][o][\0]  ← 需要扫描到\0，O(n)

Python风格:
字符串对象 = {
    类型: "str",
    长度: 5,     ← 直接记录，O(1)
    数据: → [H][e][l][l][o]
}
```

"那字符串拼接呢？"希娅问道。

"这就涉及到一个重要概念——**不可变性**，一旦一个 String 对象被创建，它内部的字符序列就不能被更改。"黛芙把两页五线谱并排放置，"Python/Java/Kotlin 的字符串是不可变的，拼接时会**创建全新的字符串对象**。"

她演示拼接过程：

```python
# 演示字符串拼接的成本
def show_concat_cost():
    result = ""
    for i in range(4):
        old_result = result
        result = result + str(i)  # str()将数字转为字符串，+操作创建新字符串对象
        print(f"'{old_result}' + '{i}' → '{result}' (新字符串总长度:{len(result)}字节)")

show_concat_cost()
```

运行结果：
```
'' + '0' → '0'       (新字符串 '0' 总长度:1字节)
'0' + '1' → '01'     (新字符串 '01' 总长度:2字节)
'01' + '2' → '012'   (新字符串 '012' 总长度:3字节)
'012' + '3' → '0123' (新字符串 '0123' 总长度:4字节)
```

"我明白了！每次拼接都要创建一个新的更大的字符串，"安妮说，"但是为什么你说n次拼接的总时间复杂度是O(n²)呢？"

"好问题！让我详细分析给你看，"黛芙在白板上画出分析过程：

```
字符串拼接复杂度分析：

假设要拼接n次，每次添加1个字符：

第1次拼接: "" + "0" = "0"     → 复制0个字符 + 复制1个字符 = 1次操作
第2次拼接: "0" + "1" = "01"   → 复制1个字符 + 复制1个字符 = 2次操作  
第3次拼接: "01" + "2" = "012" → 复制2个字符 + 复制1个字符 = 3次操作
...
第n次拼接: → 复制(n-1)个字符 + 复制1个字符 = n次操作

总操作次数 = 1 + 2 + 3 + ... + n = n×(n+1)/2 ≈ n²/2

所以时间复杂度是 O(n²)
```

"原来如此！每次都要重新复制之前的所有内容，"安妮恍然大悟，"就像每次搬家都要把所有家具重新搬一遍。"

"那怎么优化呢？"希娅问。

"用列表收集，最后一次性连接！"希娅回答。

黛芙点头："Python 的 `join()` 方法会预先计算总长度，一次性分配足够的内存，然后把所有字符串复制到正确位置，总时间复杂度是` O(n)` 。"

```python
# 高效的字符串构建方式
def efficient_concat():
    parts = []  # 创建空列表，append()操作平均时间复杂度是O(1)
    for i in range(4):
        parts.append(str(i))  # append()只是在列表末尾添加引用，很快
        print(f"添加'{i}'到列表: {parts}")
    
    result = ''.join(parts)  # join()方法一次性分配足够内存并连接所有字符串
    print(f"最终结果: '{result}'")
```

运行结果：
```
添加'0'到列表: ['0']
添加'1'到列表: ['0', '1']
添加'2'到列表: ['0', '1', '2']
添加'3'到列表: ['0', '1', '2', '3']
最终结果: '0123'
```

"Java用 `StringBuilder` 或 `StringBuffer`(多线程环境)，Kotlin用 `joinToString`，时间复杂度都为 `O(n)`。"

```kotlin
val chunks = listOf("a", "b", "c", "d", "e")
val result = chunks.joinToString("")
println(result) // abcde
```

"让我们再对比一下不同字符的编码吧，"伊莎贝尔提议：

```python
# 对比不同字符的UTF-8编码
chars = ['A', '中', '樱', '🌸']
for char in chars:
    utf8_bytes = char.encode('utf-8')  # 编码为UTF-8字节序列
    if len(char) == 1:
        unicode_point = ord(char)  # 获取单个字符的Unicode码点
        print(f"'{char}': U+{unicode_point:04X}, {len(utf8_bytes)}字节")
    else:
        print(f"'{char}': 表情符号, {len(utf8_bytes)}字节")
```

运行结果：
```
'A': U+0041, 1字节
'中': U+4E2D, 3字节  
'樱': U+6A31, 3字节
'🌸': 表情符号, 4字节
```

安妮兴奋地跑到投影设备前，将编码设置改为UTF-8。《樱之记忆》的歌词立刻正确显示出来。

"成功了！"安妮开心地转过身，"现在我不仅知道怎么解决乱码，还明白了字符串在计算机里的真实面貌！"

伊莎贝尔温柔地说："每个字符都像音符一样，有自己独特的编码和在内存中的位置。"

在温暖的午后阳光中，四人围着白板继续探讨字符串在各种应用中的奥秘。安妮发现，学习编程就像学习音乐，每个基础概念都是构建美妙程序的重要音符。

"让我总结一下今天的重点，"安妮主动走向白板：

```
🌸 字符串存储模型核心要点 🌸

🔤 字符编码原理：
   - ASCII: 1字节，支持英文(U+0000-U+007F)
   - UTF-8变长编码: 1-4字节，支持全球字符
   - 中文字符: 通常3字节(U+0800-U+FFFF范围)
   - 表情符号: 4字节(U+10000-U+10FFFF范围)
   - 编码统一避免乱码

🧠 存储方式：
   - 连续内存布局，支持O(1)访问
   - C风格：\0结束符，需扫描获取长度
   - 现代风格：显式记录长度信息

⚡ 性能关键：
   - 字符串不可变，拼接需创建新对象
   - 频繁拼接：O(n²) → 用列表收集+join()优化为O(n)
   - 理解底层原理，选择合适方案
```

**安妮的小小日记本**
今天不仅解开了乱码之谜，还深入了解了UTF-8编码的奇妙设计！原来每个字符都有自己的"身份证号"（`Unicode码点`），根据号码大小住进不同大小的"房间"（字节数）。学会十六进制转换让我觉得像掌握了新的数学魔法，还理解了为什么频繁字符串拼接会让程序变慢。现在编程对我来说不再是黑盒子，每个概念都清晰可见！

---

> **字符串 (String)**：由字符组成的有限序列，是编程中最基本的数据类型。字符串通过字符编码（如UTF-8）将字符映射为字节序列，在内存中以连续数组形式存储。现代编程语言通常实现为不可变对象，提供高效访问和丰富操作方法，是文本处理、数据解析等应用的核心数据结构。

### 今日关键词
- **字符编码 (Character Encoding)**：将字符映射为数字的标准，决定字符在计算机中的存储方式
- **UTF-8变长编码**：兼容ASCII的Unicode编码，根据字符范围使用1-4字节，当前最流行的编码标准
- **Unicode码点 (Unicode Code Point)**：每个字符在Unicode标准中的唯一编号，决定字符的UTF-8字节数
- **连续内存存储**：字符串以连续字节序列存储，支持O(1)随机访问和高效内存管理
- **不可变对象 (Immutable Object)**：创建后不能修改的对象，修改操作会创建新对象
- **字符串拼接优化**：避免频繁拼接导致的O(n²)复杂度，使用列表收集再join()连接，时间复杂度 O(n)
- **空字符终止符 (\\0)**：C风格字符串的结束标记，用于确定字符串边界
- **显式长度存储**：现代语言在字符串对象中存储长度信息，实现O(1)长度查询

### 推荐练习题目

**基础入门必做**（7题）：
1. **LeetCode 344. Reverse String**：双指针反转字符数组，理解字符串的数组本质 ⭐
2. **LeetCode 557. Reverse Words in a String III**：反转字符串中的单词，练习子串操作 ⭐
3. **LeetCode 125. Valid Palindrome**：验证回文串，练习字符处理和编码理解 ⭐
4. **自实现：字符编码转换器**：实现UTF-8和GBK转换，深入理解编码原理 ⭐
5. **自实现：安全字符串拷贝**：用C语言实现安全strcpy，理解缓冲区管理 ⭐⭐
6. **LeetCode 14. Longest Common Prefix**：寻找最长公共前缀，练习字符串比较 ⭐⭐
7. **自实现：Unicode分析器**：分析字符串中各字符的Unicode码点和字节占用 ⭐⭐

**进阶推荐**（6题）：
8. **LeetCode 28. Find the Index of the First Occurrence**：实现strStr函数，为KMP算法做准备 ⭐⭐
9. **LeetCode 58. Length of Last Word**：获取最后单词长度，处理边界情况 ⭐⭐
10. **自实现：内存池字符串管理器**：实现高效的字符串内存分配策略 ⭐⭐⭐
11. **LeetCode 6. Zigzag Conversion**：Z字形变换，练习字符串索引计算 ⭐⭐⭐
12. **Unicode处理器**：实现UTF-8字符串的正确分割和索引 ⭐⭐⭐
13. **LeetCode 49. Group Anagrams**：字母异位词分组，综合字符串和哈希表 ⭐⭐⭐

**面试高频**（5题）：
14. **LeetCode 3. Longest Substring Without Repeating Characters**：最长无重复子串，滑动窗口经典 ⭐⭐⭐
15. **LeetCode 5. Longest Palindromic Substring**：最长回文子串，动态规划应用 ⭐⭐⭐
16. **LeetCode 76. Minimum Window Substring**：最小覆盖子串，滑动窗口进阶 ⭐⭐⭐⭐
17. **LeetCode 438. Find All Anagrams in a String**：找到所有字母异位词，窗口+哈希 ⭐⭐⭐
18. **字符串匹配算法实现**：实现KMP/Boyer-Moore算法，理解高效匹配 ⭐⭐⭐⭐

**考研重点**（4题）：
19. **串的模式匹配算法分析**：比较BF、KMP、BM算法的时间复杂度 ⭐⭐⭐
20. **字符串压缩算法设计**：设计并实现简单的字符串压缩算法 ⭐⭐⭐⭐
21. **串的存储结构对比**：分析定长、堆分配、块链存储的优缺点 ⭐⭐⭐
22. **编码转换的算法实现**：实现完整的字符编码检测和转换系统 ⭐⭐⭐⭐