# 第04章 双向的温柔

*双向链表如同牵手的朋友，每个人不仅知道前面是谁，也记得后面是谁。这种双向的连接让我们既能勇敢前行，也能温柔回望，在人生的路上永不孤单。*

第二天是周四，天空放晴了，温暖的阳光透过DSA Lab的百叶窗洒进来，在地板上投下斑驳的光影。安妮今天心情特别好，因为昨天终于搞懂了单向链表和时间复杂度的概念。

她早早来到实验室，在白板上画着昨天学到的单向链表结构，还用不同颜色的马克笔标注了各个部分。正当她专心致志地复习时，突然遇到了一个问题。

"咦？"安妮皱着眉头，盯着白板上的链表图，"如果我想从链表的末尾开始往前遍历怎么办？比如我想倒着输出所有的温度数据？"

她试着在纸上模拟这个过程：

```
正向遍历：22.5 → 23.1 → 24.8 → 23.7 → 22.9
想要倒向：22.9 ← 23.7 ← 24.8 ← 23.1 ← 22.5
```

"单向链表只能往前走，没办法往后走..."安妮嘟囔着，用手指轻敲着桌面，小兔子发卡在阳光下闪闪发光，"难道要先遍历一遍存到数组里，再倒着输出？感觉好麻烦啊。"

"遇到新的挑战了？"希娅的声音从门口传来，她手里拿着两杯香草拿铁，脸上带着温暖的笑容。今天的希娅戴着一副无框眼镜，显得格外知性。

"希娅姐！"安妮立刻转身，眼睛发亮，"我在想如果要倒着遍历链表该怎么办，单向链表好像做不到。"

希娅走过来，将咖啡递给安妮，然后看了看白板上的图。"这确实是单向链表的一个限制呢。不过，你还记得我昨天说的吗？今天我们可以学习双向链表。"

"双向链表？"安妮眨着大眼睛，"是不是每个节点都有两个方向的连接？"

"聪明！"希娅在安妮身边坐下，"双向链表的每个节点不仅有指向下一个节点的指针，还有指向前一个节点的指针。"

这时，伊莎贝尔也到了，她看到白板上的图示，微笑着说："看起来安妮想要学习双向遍历了。"伊莎贝尔今天把长发盘了起来，用一支木质发簪固定，显得优雅端庄。

"贝尔姐早上好！"安妮挥挥手，"我们在研究怎么往后遍历链表。"

伊莎贝尔放下包，走到白板前："那我们一起来看看双向链表是怎么解决这个问题的吧。"

她拿起马克笔，在白板上画出了双向链表的结构：

```
双向链表节点结构：
    ┌─────────┬─────────┬─────────┐
    │ 前指针  │  数据   │ 后指针  │
    │  prev   │ (22.5)  │  next   │
    └─────────┴─────────┴─────────┘
         ↑                   ↓
         │                   │
    ┌─────────┬─────────┬─────────┐
    │ 前指针  │  数据   │ 后指针  │
    │  prev   │ (23.1)  │  next   │
    └─────────┴─────────┴─────────┘
         ↑                   ↓
         │                   │
    ┌─────────┬─────────┬─────────┐
    │ 前指针  │  数据   │ 后指针  │
    │  prev   │ (24.8)  │  null   │
    └─────────┴─────────┴─────────┘
```

"哇！"安妮兴奋地说，"这样每个节点都知道前面和后面是谁了！"

希娅点点头："没错，这样我们就可以双向遍历了。从前往后，或者从后往前，都很方便。"

伊莎贝尔开始编写代码，每一行都仔细解释：

```python
# 双向链表的节点类 - 像是能前后牵手的朋友
class DoublyListNode:
    def __init__(self, data):
        self.data = data      # 存储数据（比如温度值）
        self.next = None      # 指向下一个节点的指针（向前的手）
        self.prev = None      # 指向前一个节点的指针（向后的手）

# 双向链表类 - 管理整个朋友圈
class DoublyLinkedList:
    def __init__(self):
        self.head = None      # 头指针，指向第一个朋友
        self.tail = None      # 尾指针，指向最后一个朋友
    
    # 在链表末尾添加新节点（新朋友加入圈子）
    def append(self, data):
        new_node = DoublyListNode(data)
        
        # if not self.head: 是Python的写法，意思是"如果head是空的"
        # 在Python中，None、0、空列表[]等都被认为是False
        # not self.head 就是"不是head"，也就是"head是空的"
        if not self.head:
            self.head = new_node
            self.tail = new_node
            return
        
        # 否则，在末尾添加新朋友
        new_node.prev = self.tail    # 新朋友的前一个是原来的最后一个
        self.tail.next = new_node    # 原来最后一个的下一个是新朋友
        self.tail = new_node         # 更新尾指针到新朋友
    
    # 从前往后遍历（正向）
    # 注意：遍历本身不需要存储数据，这里返回列表只是为了方便展示结果
    def forward_traverse(self):
        result = []               # 创建一个列表来收集遍历结果
        current = self.head       # 从第一个朋友开始
        while current:            # 当还有朋友时继续
            result.append(current.data)  # 把当前朋友的数据加到结果中
            current = current.next       # 跟着next指针往前走
        return result            # 返回收集到的所有数据
    
    # 从后往前遍历（反向）- 这是单向链表做不到的！
    def backward_traverse(self):
        result = []               # 创建一个列表来收集遍历结果
        current = self.tail       # 从最后一个朋友开始
        while current:            # 当还有朋友时继续
            result.append(current.data)  # 把当前朋友的数据加到结果中
            current = current.prev       # 跟着prev指针往后走
        return result            # 返回收集到的所有数据
    
    # 在指定位置插入新节点
    def insert_at(self, index, data):
        new_node = DoublyListNode(data)
        
        # 如果插入在开头
        if index == 0:
            if not self.head:      # 如果链表是空的
                self.head = new_node
                self.tail = new_node
            else:                  # 如果链表不是空的
                new_node.next = self.head
                self.head.prev = new_node
                self.head = new_node
            return
        
        # 找到插入位置
        current = self.head
        for i in range(index):
            if current.next:
                current = current.next
        
        # 插入新节点需要调整四个连接！
        new_node.next = current           # 新节点指向当前节点
        new_node.prev = current.prev      # 新节点指向当前节点的前一个
        current.prev.next = new_node      # 前一个节点指向新节点
        current.prev = new_node           # 当前节点指向新节点
```

"哇，代码比单向链表复杂了一些，"安妮仔细看着，"但是我能看懂！每个节点多了一个prev指针。还有，现在我明白`if not self.head`的意思了，就是判断head是不是空的！"

"对的，"希娅解释道，"双向链表的插入操作需要调整四个连接，而单向链表只需要调整两个。但是换来的好处是可以双向遍历。"

"还有一个重要的点，"伊莎贝尔补充道，"遍历操作本身并不需要把数据存储在数组里。我们这里返回列表只是为了方便展示结果。实际使用时，遍历通常是为了查找某个数据或者对每个数据进行处理，不一定要把所有数据收集起来。"

这时，黛芙推门进来，今天她看起来心情不错，银灰色的头发在阳光下泛着淡淡的光泽。"早上好，看起来你们在研究更复杂的数据结构了。"

"黛芙姐！"安妮兴奋地指着白板，"我们在学双向链表，现在可以往前走也可以往后走了！"

黛芙走过来，看了看代码："双向链表确实很有用。它在很多场景下都能提供更好的性能。"

"比如呢？"安妮好奇地问。

"比如说，如果你想删除某个特定的节点，"黛芙指着代码，"在单向链表中，你需要先找到这个节点的前一个节点，这需要从头开始遍历。但在双向链表中，如果你已经有了节点的引用，可以直接通过prev指针找到前一个节点，删除操作是O(1)的。"

伊莎贝尔补充道："这就像在人群中，如果每个人都只知道前面是谁，当你想让某人离开时，需要从头找到他前面的人；但如果每个人都知道前后是谁，就可以直接调整连接。"

她们一起测试了双向链表的功能：

```python
# 创建双向链表并添加温度数据
temp_list = DoublyLinkedList()
daily_temps = [22.5, 23.1, 24.8, 23.7, 22.9]

for temp in daily_temps:
    temp_list.append(temp)

# 正向遍历
print("正向遍历:", temp_list.forward_traverse())
# 输出: [22.5, 23.1, 24.8, 23.7, 22.9]

# 反向遍历 - 这是单向链表做不到的！
print("反向遍历:", temp_list.backward_traverse())
# 输出: [22.9, 23.7, 24.8, 23.1, 22.5]
```

"太棒了！"安妮拍手称赞，"这样我就可以很容易地得到倒序的数据了！"

希娅笑着说："不仅如此，双向链表在实际应用中也很有用。比如音乐播放器的播放列表，你可以顺序播放，也可以倒序播放。"

"完全正确，"伊莎贝尔温和地说，"双向链表更适合你需要在数据中间频繁插入删除，并且需要双向遍历的场景。比如文本编辑器中的行列表，或者LRU缓存的实现。"

"不过，"伊莎贝尔温和地提醒，"双向链表也有它的代价。每个节点需要额外的空间来存储prev指针，而且插入删除时需要维护更多的连接。"

安妮若有所思地说："所以这是一种权衡？我们用更多的空间和稍微复杂的操作，换来了双向遍历的便利？"

"说得很好，"黛芙的眼中闪过赞赏，"在计算机科学中，很多时候都是这样的权衡。没有完美的数据结构，只有最适合特定场景的选择。"

希娅补充道："这也像我们的友谊一样。有时候我们需要向前看，关注未来的目标；有时候我们需要回头看，珍惜过去的美好时光。双向的关怀让我们的关系更加稳固。"

听到这话，四个女孩都相视而笑。她们发现，学习数据结构不仅让她们掌握了技术知识，也让她们对生活有了更深的理解。

"那么，"安妮期待地问，"下次我们学什么呢？"

"栈，"黛芙微笑着说，"一种后进先出的数据结构，就像叠盘子一样。"

"听起来很有趣！"安妮开心地说，"我已经迫不及待了！"

阳光依然温暖地洒在实验室里，四个女孩继续她们的数据结构探索之旅。她们学会了，无论是在代码的世界里，还是在现实的生活中，双向的连接都让一切变得更加美好。


> 双向链表（Doubly Linked List）：节点包含指向前后两个节点的指针，支持双向遍历、插入和删除操作。

> 推荐练习题：LeetCode 146.LRU缓存, 432.全O(1)的数据结构, 1472.设计浏览器历史记录, 707.设计链表, 460.LFU缓存 