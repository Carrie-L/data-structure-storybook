## 第07章 圆桌的魔法

_"当直线变成圆圈，结束即是开始，队列也能获得永恒的生命力。"_

第二天下午，四人再次来到"算法奶茶"店。这次队伍明显短了很多，她们很快就进入了店内。

"嗨！又见面了～"那位戴着"队列管理员"名牌的店员小姐姐热情地招手，"昨天说的循环队列，想了解吗？"

安妮眼睛立刻亮了起来："想想想！我昨晚一直在想，循环是什么意思？"

"来来来，我带你们去后台看看！"店员小姐姐神秘地笑道，"我叫小雨，今天正好不太忙，可以给你们做个专场演示！"

她们跟着小雨走进了制作区域。眼前的景象让所有人都惊呆了——六个制作台围成一个完美的圆圈，每个台位前都有一个显示屏。

"哇！"安妮张大了嘴，"真的是一个圆圈！"

小雨骄傲地介绍："这是我们店的核心秘密——圆形工位调度系统！传统的直线排队容易造成空间浪费，但圆形就不会！"

她指着中央的控制台显示屏：
```
🎯 圆形工位状态（循环队列）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
      [2号：制作中]
           ⬆️
    [1号：空闲] ➜ ➜ ➜ [3号：等待]
       ⬆️                ⬇️
    [0号：空闲]        [4号：制作中]
       ⬆️                ⬇️
    [5号：空闲] ← ← ← [制作完成]

🔄 队列信息：
• 容量：6个工位（固定）
• 当前使用：3个工位
• 队首指针：工位2号
• 队尾指针：工位4号
• 状态：还能接收3个订单
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

希娅瞪大眼睛："这就是循环队列！我明白了！"

"等等，我还是有点糊涂，"安妮挠挠头，"为什么要变成圆圈？直线不是挺好的吗？"

黛芙简洁地说："空间浪费。"

小雨点点头："黛芙说得对！让我用一个简单的例子来解释。"

她拿出一张纸，画了一个简单的图：

```
普通队列的问题：
队列容量=6，有效索引0-5

初始状态：[A][B][C][_][_][_]  
          0  1  2  3  4  5    队首=0，队尾=3
          👆队首    👆队尾（下一个可插入位置）

出队一个：[_][B][C][_][_][_]  
          0  1  2  3  4  5    队首=1，队尾=3（A被移除，队首向后移）
             👆队首👆队尾
             
出队两个：[_][_][C][_][_][_]  
          0  1  2  3  4  5    队首=2，队尾=3（B被移除，队首继续向后）
                👆队首👆队尾
                
出队三个：[_][_][_][_][_][_]  
          0  1  2  3  4  5    队首=3，队尾=3（C被移除，空队列时队首=队尾）
                   👆队首/队尾
```

问题来了！现在想加入新元素：

```
如果要加新元素X、Y、Z：
[_][_][_][X][Y][Z]  队首=3，队尾=6（超出范围！）
 0  1  2  3  4  5
```

"但是前面的[0][1][2]位置明明是空的，却不能用！这就是'假溢出'现象！队尾指针到了数组末尾，就不能再加元素了。"

"啊！我懂了！"安妮恍然大悟，"就像停车场一样，前面有空位但你只能停最后面，太浪费了！"

"那循环队列是怎么解决的呢？"伊莎贝尔将黑色长发轻柔地别到耳后，温和地询问。

小雨兴奋地在平板上演示：

```python
class CircularQueue:
    def __init__(self, size):
        """初始化循环队列 🎡"""
        self.size = size          # 队列容量
        self.queue = [None] * size # 用固定大小的数组
        self.front = 0            # 队首指针
        self.rear = 0             # 队尾指针
        self.count = 0            # 当前元素个数（重要！）
    
    def is_empty(self):
        """判断队列是否为空 🔍"""
        return self.count == 0
    
    def is_full(self):
        """判断队列是否已满 📊"""
        return self.count == self.size
    
    def enqueue(self, item):
        """入队操作：在队尾添加元素 📥"""
        if self.is_full():
            print("❌ 队列已满，无法入队")
            return False
        
        self.queue[self.rear] = item
        print(f"📥 {item} 入队到位置 {self.rear}")
        
        # 关键：循环移动队尾指针！
        self.rear = (self.rear + 1) % self.size
        self.count += 1
        return True
    
    def dequeue(self):
        """出队操作：从队首移除元素 📤"""
        if self.is_empty():
            print("❌ 队列为空，无法出队")
            return None
        
        item = self.queue[self.front]
        self.queue[self.front] = None  # 清空位置
        print(f"📤 {item} 从位置 {self.front} 出队")
        
        # 关键：循环移动队首指针！
        self.front = (self.front + 1) % self.size
        self.count -= 1
        return item
    
    def display(self):
        """显示循环队列状态 🖥️"""
        print(f"循环队列：{self.queue}")
        print(f"队首指针👆={self.front}, 队尾指针👆={self.rear}")
        print(f"元素个数📊={self.count}/{self.size}")
        print("=" * 40)
```

"等等！"安妮激动地指着代码，"`(self.rear + 1) % self.size` 这个是什么意思？"

希娅详细解释："这就是循环的核心魔法！取模运算`%`让索引能够'绕一圈'：

```python
# 假设队列大小是6（位置0到5）
size = 6

# 正常情况：
rear = 2
new_rear = (2 + 1) % 6 = 3  # 从位置2移到位置3

# 到达边界时的"魔法"：
rear = 5  # 已经是最后一个位置了
new_rear = (5 + 1) % 6 = 0  # 从位置5"循环"到位置0！

# 这就像钟表一样：
# 12点后面是1点，而不是13点！
```

"哇塞！就像贪吃蛇的游戏！"安妮兴奋地比划着，"蛇头从右边出去，从左边进来！"

黛芙难得地点头："准确的比喻。"

小雨继续演示循环队列的实际操作：

```python
# 创建一个容量为6的循环队列
cq = CircularQueue(6)

print("=== 入队演示 ===")
cq.enqueue("抹茶拿铁")    # 位置0
cq.enqueue("珍珠奶茶")    # 位置1  
cq.enqueue("芋泥波波")    # 位置2
cq.display()

print("\n=== 出队演示 ===")
cq.dequeue()              # 从位置0出队
cq.dequeue()              # 从位置1出队
cq.display()

print("\n=== 循环特性演示 ===")
cq.enqueue("柠檬茶")      # 位置3
cq.enqueue("红豆奶昔")    # 位置4
cq.enqueue("咖啡拿铁")    # 位置5
cq.enqueue("草莓气泡")    # 位置0（循环回来了！）
cq.display()
```

运行结果：
```
=== 入队演示 ===
📥 抹茶拿铁 入队到位置 0
📥 珍珠奶茶 入队到位置 1
📥 芋泥波波 入队到位置 2
循环队列：['抹茶拿铁', '珍珠奶茶', '芋泥波波', None, None, None]
队首指针👆=0, 队尾指针👆=3
元素个数📊=3/6
========================================

=== 出队演示 ===
📤 抹茶拿铁 从位置 0 出队
📤 珍珠奶茶 从位置 1 出队
循环队列：[None, None, '芋泥波波', None, None, None]
队首指针👆=2, 队尾指针👆=3
元素个数📊=1/6
========================================

=== 循环特性演示 ===
📥 柠檬茶 入队到位置 3
📥 红豆奶昔 入队到位置 4
📥 咖啡拿铁 入队到位置 5
📥 草莓气泡 入队到位置 0
循环队列：['草莓气泡', None, '芋泥波波', '柠檬茶', '红豆奶昔', '咖啡拿铁']
队首指针👆=2, 队尾指针👆=1
元素个数📊=5/6
========================================
```

"太神奇了！"安妮看着最后的状态，揉弄着粉色头发，"位置0又被使用了！原来被释放的空间可以重新利用！"

"等等，我还有点糊涂，"安妮皱着眉头，"为什么最后是队首指针=2，队尾指针=1呢？"

希娅耐心地画图解释："我来详细说明一下指针的移动过程，在循环队列里：

- `front` 指向队头元素的位置, 即下一个要被移除（出队）的元素。
- `rear` 指向下一个可插入元素的位置（入队），即队尾的下一个空位。

```
详细指针追踪：

1. 初始：front=0, rear=0, count=0
   [None][None][None][None][None][None]
    👆front/rear

2. 加入3个元素后：front=0, rear=3, count=3
   [抹茶][珍珠][芋泥][None][None][None]
    👆front        👆rear

3. 出队2个元素后：front=2, rear=3, count=1
   [None][None][芋泥][None][None][None]
                👆front👆rear

4. 加入4个新元素的过程：
   
   加入"柠檬茶"：rear=3→4, count=2
   [None][None][芋泥][柠檬茶][None][None]
                👆front     👆rear
   
   加入"红豆奶昔"：rear=4→5, count=3  
   [None][None][芋泥][柠檬茶][红豆奶昔][None]
                👆front              👆rear
   
   加入"咖啡拿铁"：rear=5→0（循环！），count=4
   [None][None][芋泥][柠檬茶][红豆奶昔][咖啡拿铁]
    👆rear      👆front
   
   加入"草莓气泡"：rear=0→1（继续循环），count=5
   [草莓气泡][None][芋泥][柠檬茶][红豆奶昔][咖啡拿铁]
            👆rear 👆front

所以最终：队首指针=2（芋泥的位置），队尾指针=1（下一个插入位置）
```

"哇！原来队尾指针可以'跑'到队首指针前面去！"安妮兴奋地拍手。

"等等等等！"安妮又想到了什么，眼睛亮晶晶地问，"如果我们继续加入'芝芝莓莓'会怎么样？"

希娅笑了笑："那我们试试看！"她在平板上继续演示：

```
继续加入"芝芝莓莓"：rear=1→2，count=6
[草莓气泡][芝芝莓莓][芋泥][柠檬茶][红豆奶昔][咖啡拿铁]
                     👆rear/front

最终状态：队首指针=2，队尾指针=2，元素个数=6/6（满了！）
```

"咦？"安妮困惑地眨眨眼，"现在队首指针和队尾指针又重合了，但这次是满队列，不是空队列！"

黛芙点头："这就是为什么需要计数器。"

小雨竖起大拇指："没错！如果这时候再尝试加入新元素，比如'奥利奥奶昔'：

```python
cq.enqueue("奥利奥奶昔")  # 尝试加入第7个元素
```

会输出：
```
❌ 队列已满，无法入队
```

因为 `self.count (6) == self.size (6)`，is_full() 返回 True。"

"太巧妙了！"安妮感叹道，"用一个简单的计数器就解决了这个难题！"

"这也说明了为什么循环队列比普通队列高效，"希娅总结，"同样6个空间，普通队列可能因为假溢出只能用3-4个，但循环队列能100%利用！"

这时，黛芙突然问道："如何判断队列满还是空？"

"好问题！"小雨眨眨眼，"这是循环队列的经典难题。看起来简单，但有个陷阱：

```python
# 问题：如何区分空队列和满队列？
# 
# 空队列：front == rear （比如都是0）
# 满队列：front == rear （比如front=0, rear绕一圈也是0）
# 
# 看起来一样！怎么区分？

# 解决方案1：维护元素计数器（我们用的方法）
self.count = 0  # 记录当前元素个数
# 空：count == 0
# 满：count == size


# 解决方案2：牺牲一个位置（详细解释）
# 核心思想：故意让队列"永远装不满"，用这个特性来区分空满状态
class CircularQueueSacrifice:
    def __init__(self, size):
        self.size = size # 队列总容量
        self.queue = [None] * size # 用固定大小的列表来存储元素
        self.front = 0 # 指向队首元素的位置（即下一个要出队的元素）
        self.rear = 0 # 指向下一个可插入元素的位置
        # 注意：实际可用容量只有 size-1！
    
    def is_empty(self):
        return self.front == self.rear  # 队列判空：front 和 rear 指针重合
    
    def is_full(self):
        # 关键：当"队尾的下一位"等于队首时，队列判满
        return (self.rear + 1) % self.size == self.front
    
    def enqueue(self, item):
        if self.is_full():
            return False  # 队列已满（实际上还有1个空位）
        
        # 入队操作：在 rear 位置插入元素，并让 rear 指针后移一格
        self.queue[self.rear] = item
        self.rear = (self.rear + 1) % self.size
        return True

# 例子：容量为6的数组，实际只能存5个元素
# 满状态：[A][B][C][D][E][None]
#         👆front=0       👆rear=5
# 此时 (rear+1) % size = (5+1) % 6 = 0 = front，判定为满
# 但是rear位置其实是空的！这就是"牺牲"的那个位置


# 解决方案3：使用标志位
self.is_empty_flag = True
# 根据最后一次操作设置标志：入队后设为False，出队到空时设为True
```

"哇，方案2好聪明但好浪费！"安妮感叹，"为了区分状态，故意不用一个位置！"

希娅点头："这就像约定'满员'的电梯其实还能站一个人，但为了安全留出缓冲空间。"

小雨指着店里的圆形工位："我们店用的就是第一种方法，维护计数器。这样既不浪费空间，逻辑也最清晰。"

"那这个系统有什么实际好处呢？"伊莎贝尔好奇地问。

"太多了！"小雨兴奋地说，"首先是空间效率100%，不像直线队列会有假溢出。其次是公平性，每个工位的利用率都一样。最重要的是..."

她停顿了一下，"我们可以根据客流量动态调整。高峰期6个工位全开，低峰期只用3个，但数据结构保持不变！"

黛芙眼神一亮："动态扩容？"

"不，容量是固定的，"小雨摇摇头，"但是循环队列的美妙就在于，即使容量固定，也能最大化利用空间。这在很多系统中都很重要——比如操作系统的缓冲区、网络路由器的数据包队列..."

"还有游戏！"安妮突然想到，"回合制游戏的玩家顺序，不就是循环队列吗？A→B→C→D→A→B..."

"哇，安妮你越来越厉害了！"希娅夸赞道。

正在这时，店里来了一波客流高峰，小雨需要回去帮忙。

"不好意思，我得去工作了，"小雨歉意地说，"不过你们可以观察一下我们的圆形工位系统实际运作！"

四人在旁边安静地观察。只见六个工位有序地运转着：

1号工位的小哥正在打奶泡，手法娴熟地转动着蒸汽棒；
2号工位的小姐姐在调配茶底，按照配方精确地倒入茶汤；
3号工位正在加配料，珍珠、椰果、布丁一一添加；
4号工位负责封口，机器"啪嗒"一声完成密封；
5号工位暂时空闲，等待下一个订单；
6号工位的员工在清洗设备，为下轮制作做准备。

中央显示屏实时更新着工位状态，就像循环队列的可视化界面：当前处理的订单从1号工位开始，依次流转到下一个工位，完成后从4号工位"出队"，而新订单则从当前可用的工位"入队"。

"真的很像我们刚才学的循环队列，"安妮小声说道，"每个工位都在合适的时候被使用，没有浪费。"

希娅点点头："而且你注意到了吗？即使有工位暂时空闲，整体的调度逻辑还是循环的。"

"这让我想到了一个问题，"伊莎贝尔若有所思，"如果需要支持优先级怎么办？循环队列还适用吗？"

黛芙简洁地说："那就不是简单的FIFO了。"

"对！"希娅眼睛一亮，"如果要支持VIP插队，或者按照制作复杂度排序，就需要更高级的数据结构了..."

她们点了奶茶，离开时小雨特意叮嘱："下次来的时候，我教你们双端队列！那个更有趣，两边都能进出哦～"

走在回实验室的路上，安妮总结道："今天学到的循环队列真的很巧妙。用固定的空间，通过循环利用实现了最高的效率。"

"而且关键是那个取模运算，"希娅补充，"`(index + 1) % size`，让线性的数组变成了环形的结构。"

伊莎贝尔将黑色长发拨到耳后，温柔地说："这让我想起古代哲学中的'循环'概念——万物皆有轮回，结束即是开始。"

黛芙难得地展露一丝微笑："数学之美。"

回到实验室，白板上的队列图旁边，安妮画了一个新的图示：

```
循环队列（Circular Queue）
    [1]     [2]
 [0]    🎡     [3]  ← 循环利用空间
    [5]     [4]

关键：(index + 1) % size
```

夕阳透过窗户洒进来，四个人围着白板，继续讨论着循环队列的各种应用场景。在她们的世界里，每一个数据结构都不仅仅是冰冷的代码，而是充满智慧和美感的艺术品。

---

> **循环队列（Circular Queue）**：头尾相连的队列结构，解决普通队列中数组空间利用率低的问题。通过取模运算`(index + 1) % size`实现索引的循环，避免假溢出现象，使固定大小的数组能够被充分利用。主要挑战在于如何区分**空队列和满队列**状态，常用方法包括维护元素计数器、牺牲一个存储位置、或使用标志位。

> **推荐练习题目**：
> 1. LeetCode 622 - 设计循环队列 ⭐⭐  
> 2. LeetCode 641 - 设计循环双端队列 ⭐⭐⭐
> 3. **约瑟夫环问题**：n个人围成圆圈，每隔k个人淘汰一个，求最后剩下的人的位置。可用循环队列模拟这个过程，每次跳过k-1个人，淘汰第k个人，直到只剩一人。⭐⭐
> 4. **循环缓冲区设计**：实现一个生产者-消费者模型的环形缓冲区，支持多线程安全的读写操作，当缓冲区满时生产者等待，空时消费者等待。要求实现put()、get()、isFull()、isEmpty()等方法。⭐⭐⭐
> 5. LeetCode 1670 - 设计前中后队列 ⭐⭐⭐ 